// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`common common.parseReadme(data, metaKeys) should parse loom url as embed 1`] = `
Object {
  "allowfullscreen": "true",
  "frameborder": "0",
  "height": "360",
  "mozallowfullscreen": "true",
  "src": "https://www.useloom.com/embed/90102cf63263435faa7f867c1e9c2d33",
  "webkitallowfullscreen": "true",
  "width": "640",
}
`;

exports[`common common.parseReadme(data, metaKeys) should parse ok when all meta data is present 1`] = `
Object {
  "body": "<h3 id=\\"resumen\\">Resumen</h3>
<p>Llegamos al final de la unidad ;-)</p>
<p>En la programaci&#xF3;n funcional, las programadoras tienden a evitar dos h&#xE1;bitos
comunes en otros lenguajes:</p>
<ul>
<li><em>Mutaci&#xF3;n:</em> Cambio de los datos <em>in-situ</em> en vez de retornar un valor.</li>
<li><em>Estado compartido:</em> Contexto extra que no se provee como argumento a la
funci&#xF3;n, por ejemplo, variables globales.</li>
</ul>
<p>Al no depender del estado ni de las mutaciones, el comportamiento de cada
funci&#xF3;n est&#xE1; contenido. Por lo tanto, es m&#xE1;s sencillo realizar pruebas del
comportamiento de dichas funciones, entre otra serie de beneficios.</p>
<p>Una vez dicho todo esto, existen ocasiones donde el uso de funciones puras no es
posible, especialmente en funciones que emplean <em>side-effects</em> para llevar a
cabo su cometido, por ejemplo el uso de promesas en JavaScript. Pero este tema,
lo veremos en una siguiente lecci&#xF3;n.</p>
<h3 id=\\"respondamos-juntxs-las-preguntas-de-la-apertura\\">Respondamos juntxs las preguntas de la apertura</h3>
<ul>
<li>C&#xF3;mo evitar que nuestras funciones tengan efectos colaterales?</li>
<li>Por qu&#xE9; es beneficioso evitar el estado compartido?</li>
<li>Cu&#xE1;les son las ventajas que ofrecen las funciones puras, en particular a la
hora de hacer testing?</li>
<li>C&#xF3;mo evitar la mutaci&#xF3;n de objetos y arreglos?</li>
<li>Qu&#xE9; tipos de datos son mutables e inmutables en JavaScript?</li>
<li>C&#xF3;mo usar m&#xE9;todos de arreglos como <code>Array#concat</code>, <code>Array#slice</code>, <code>Array#map</code>,
<code>Array#filter</code>, ... para crear arreglos nuevos en vez de mutar (modificar)
valores existentes?</li>
<li>C&#xF3;mo usar m&#xE9;todos de objetos (por ejemplo <code>Object.assign()</code>) para copiar
propiedades y as&#xED; <em>clonar</em> objetos?</li>
<li>C&#xF3;mo usar el <em>spread operator</em> (<code>...</code>) para copiar objetos y arreglos?</li>
</ul>
<h3 id=\\"auto-evaluaci&#xF3;n\\">Auto-evaluaci&#xF3;n</h3>
<p>Tus instructorxs te compartir&#xE1;n un link al cuestionario de <em>auto evaliaci&#xF3;n</em>.
Este cuestionario no es calificado.</p>
",
  "duration": "15min",
  "format": "guiado",
  "title": "Cierre",
  "type": "seminario",
}
`;

exports[`common common.parseReadme(data, metaKeys) should parse slide url as embed 1`] = `
Object {
  "allowfullscreen": "true",
  "frameborder": "0",
  "height": "360",
  "mozallowfullscreen": "true",
  "src": "https://docs.google.com/presentation/d/e/2PACX-1vS_df7E0e1gALi_nUVpLN9D1eL2shAta_f8E7oI1N0nSv1u77EnIh9ZBAhaGOIN7saMcr6il3c7VjVv",
  "webkitallowfullscreen": "true",
  "width": "640",
}
`;

exports[`common common.parseReadme(data, metaKeys) should parse soundcloud url as embed 1`] = `
Object {
  "allow": "autoplay",
  "frameborder": "0",
  "height": "180",
  "scrolling": "no",
  "src": "https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/332779915",
  "width": "640",
}
`;

exports[`common common.parseReadme(data, metaKeys) should parse typeform url as embed 1`] = `
Object {
  "allowfullscreen": "true",
  "frameborder": "0",
  "height": "100%",
  "mozallowfullscreen": "true",
  "src": "https://laboratoria.typeform.com/to/J8fzhH",
  "style": "height: 100vh;",
  "webkitallowfullscreen": "true",
  "width": "100%",
}
`;

exports[`common common.parseReadme(data, metaKeys) should parse vimeo url as embed 1`] = `
Object {
  "allowfullscreen": "true",
  "frameborder": "0",
  "height": "360",
  "mozallowfullscreen": "true",
  "scrolling": "no",
  "src": "https://player.vimeo.com/video/94950270?title=0&byline=0&portrait=0",
  "webkitallowfullscreen": "true",
  "width": "640",
}
`;

exports[`common common.parseReadme(data, metaKeys) should parse youtube short url as embed 1`] = `
Object {
  "frameborder": "0",
  "height": "360",
  "id": "ytplayer",
  "src": "https://www.youtube.com/embed/ge4h5uJN6KI?autoplay=0",
  "type": "text/html",
  "width": "640",
}
`;

exports[`common common.parseReadme(data, metaKeys) should pass through query string params when embedding youtube videos (long url) 1`] = `
Object {
  "frameborder": "0",
  "height": "360",
  "id": "ytplayer",
  "src": "https://www.youtube.com/embed/ft5TzxG-LAc?cc_lang_pref=es&cc_load_policy=1&autoplay=0",
  "type": "text/html",
  "width": "640",
}
`;

exports[`common common.parseReadme(data, metaKeys) should pass through query string params when embedding youtube videos (short url) 1`] = `
Object {
  "frameborder": "0",
  "height": "360",
  "id": "ytplayer",
  "src": "https://www.youtube.com/embed/ge4h5uJN6KI?cc_lang_pref=es&cc_load_policy=1&autoplay=0",
  "type": "text/html",
  "width": "640",
}
`;

exports[`common common.parseReadme(data, metaKeys) should warn when missing meta data 1`] = `
Object {
  "body": "<p>La t&#xE9;cnica de definir funciones atadas a m&#xFA;ltiples par&#xE1;metros como una serie de
funciones anidadas que solo esperan un par&#xE1;metro fue popularizada por el
matem&#xE1;tico <a href=\\"https://en.wikipedia.org/wiki/Haskell_Curry\\" target=\\"_blank\\">Haskell Curry</a>, aunque inicialmente observada por <a href=\\"https://en.wikipedia.org/wiki/Gottlob_Frege\\" target=\\"_blank\\">Frege</a> en
1893, a dicha cadena de funciones anidadas se les llama funciones curry o
<em>curried functions</em>.</p>
<h2 id=\\"&#xBF;qu&#xE9;-es-currying\\">&#xBF;Qu&#xE9; es <em>currying</em>?</h2>
<p>En pocas palabras, <em>currying</em> es una t&#xE9;cnica que traduce la evaluaci&#xF3;n de una
funci&#xF3;n que toma m&#xFA;ltiples argumentos en una evaluaci&#xF3;n de una secuencia de
funciones, cada una de funciones de la secuencia espera un &#xFA;nico argumento.
<em>Currying</em> est&#xE1; relacionado con el concepto de <a href=\\"https://en.wikipedia.org/wiki/Partial_application\\" target=\\"_blank\\">aplicaci&#xF3;n
parcial</a>, pero no es lo mismo.</p>
<p>El <em>currying</em> es elemental en la mayor&#xED;a de los lenguajes de programaci&#xF3;n
funcional, por ejemplo Haskell o Scala. A pesar que JavaScript ofrece soporte
para algunas caracter&#xED;sticas funcionales, al menos en las versiones actuales, el
<em>currying</em> no es una de ellas. Sin embargo, podemos <em>emular</em> este patr&#xF3;n con las
caracter&#xED;sticas actuales del lenguaje.</p>
<p>Para darte una idea de c&#xF3;mo este concepto podr&#xED;a funcionar, vamos a crear
nuestra primera funci&#xF3;n <em>curry</em> en JavaScript, utilizando la sintaxis familiar
para construir la funcionalidad <em>currying</em> que queremos. Como ejemplo,
imaginemos una funci&#xF3;n que salude a alguien por su nombre. Todos sabemos c&#xF3;mo
crear una funci&#xF3;n simple de saludo que toma un nombre y un saludo, y registra el
saludo con el nombre:</p>
<pre><code class=\\"language-js\\">const greet = (greeting, name) =&gt; \`\${greeting}, \${name}\`

test(&apos;Should say Hello&apos;, () =&gt; {
  expect(greet(&apos;Hello&apos;, &apos;Heidi&apos;)).toBe(&apos;Hello, Heidi&apos;)
})</code></pre>
<p>Esta funci&#xF3;n requiere que el nombre y el saludo se pasen como argumentos para
que funcione correctamente. Pero podr&#xED;amos reescribir la funci&#xF3;n usando
<em>currying</em> anidado simple, de modo que la funci&#xF3;n b&#xE1;sica s&#xF3;lo requiera un
saludo, y devuelve otra funci&#xF3;n que toma el nombre de la persona que queremos
saludar.</p>
<h2 id=\\"nuestro-primer-curry\\">Nuestro primer <em>curry</em></h2>
<pre><code class=\\"language-js\\">const greetCurried = greeting =&gt; name =&gt; \`\${greeting}, \${name}\`</code></pre>
<p>Este peque&#xF1;o ajuste a la forma en que escribimos la funci&#xF3;n anterior nos permite
crear una nueva funci&#xF3;n para cualquier tipo de saludo, y pasar a esa nueva
funci&#xF3;n el nombre de la persona que queremos saludar:</p>
<pre><code class=\\"language-js\\">test(&apos;Should allow to reuse functions&apos;, () =&gt; {
  const greetHello = greetCurried(&apos;Hello&apos;)

  expect(greetHello(&apos;Heidi&apos;)).toBe(&apos;Hello, Heidi&apos;)
  expect(greetHello(&apos;Eddie&apos;)).toBe(&apos;Hello, Eddie&apos;)
})</code></pre>
<p>Tambi&#xE9;n podemos llamar a la funci&#xF3;n en modo <em>curry</em> original directamente,
simplemente pasando cada uno de los par&#xE1;metros en un conjunto separado de
par&#xE9;ntesis, uno despu&#xE9;s del otro:</p>
<pre><code class=\\"language-js\\">test(&apos;Should work with all the parameters&apos;, () =&gt; {
  expect(greetCurried(&apos;Hi there&apos;)(&apos;Howard&apos;)).toBe(&apos;Hi there, Howard&apos;)
})</code></pre>
<h2 id=\\"apliquemos-curry-a-todo\\">Apliquemos <em>curry</em> a todo</h2>
<p>Lo bueno es que ahora que hemos aprendido a modificar nuestra funci&#xF3;n
tradicional para usar este enfoque para manejar los argumentos, podemos hacerlo
con tantos argumentos como queramos:</p>
<pre><code class=\\"language-js\\">const greetDeeplyCurried = greeting =&gt;
  separator =&gt;
    emphasis =&gt;
      name =&gt;
        \`\${greeting}\${separator}\${name}\${emphasis}\`</code></pre>
<p>Tenemos la misma flexibilidad con cuatro argumentos que con dos. No importa lo
lejos que vaya el anidamiento, podemos crear nuevas funciones personalizadas
para saludar a tantas personas como escojamos de tantas maneras como nos
convenga:</p>
<pre><code class=\\"language-js\\">test(&apos;Should allow nested calls&apos;, () =&gt; {
  const greetAwkwardly = greetDeeplyCurried(&apos;Hello&apos;)(&apos;...&apos;)(&apos;?&apos;)

  expect(greetAwkwardly(&apos;Heidi&apos;)).toBe(&apos;Hello...Heidi?&apos;)
  expect(greetAwkwardly(&apos;Eddie&apos;)).toBe(&apos;Hello...Eddie?&apos;)
})</code></pre>
<p>Adem&#xE1;s, podemos pasar tantos par&#xE1;metros como quisi&#xE9;ramos al crear variaciones
personalizadas de nuestra funci&#xF3;n <em>curry</em> original, creando nuevas funciones que
son capaces de tomar el n&#xFA;mero apropiado de par&#xE1;metros adicionales, cada uno se
pasa por separado en su propio conjunto de par&#xE9;ntesis:</p>
<pre><code class=\\"language-js\\">test(&apos;Other variations&apos;, () =&gt; {
  const sayHello = greetDeeplyCurried(&apos;Hello&apos;)(&apos;, &apos;)

  expect(sayHello(&apos;.&apos;)(&apos;Heidi&apos;)).toBe(&apos;Hello, Heidi.&apos;)
  expect(sayHello(&apos;.&apos;)(&apos;Eddie&apos;)).toBe(&apos;Hello, Eddie.&apos;)</code></pre>
<p>Y se pueden definir variaciones subordinadas:</p>
<pre><code class=\\"language-js\\">  const askHello = sayHello(&apos;?&apos;)

  expect(askHello(&apos;Heidi&apos;)).toBe(&apos;Hello, Heidi?&apos;)
  expect(askHello(&apos;Eddie&apos;)).toBe(&apos;Hello, Eddie?&apos;)
})</code></pre>
<h2 id=\\"aplicando-curry-a-funciones-tradicionales\\">Aplicando <em>curry</em> a funciones tradicionales</h2>
<p>Puedes ver lo poderoso que es este enfoque, especialmente si necesitas crear
muchas funciones personalizadas muy detalladas. El &#xFA;nico problema es la
sintaxis, pues a medida que construyes estas funciones con <em>curry</em>, debes
mantener las funciones devueltas anidadas, y llamarlas con nuevas funciones que
requieran varios conjuntos de par&#xE9;ntesis, cada uno conteniendo su propio
argumento aislado. Se puede poner dif&#xED;cil y enredado.</p>
<p>Antes de abordar la implementaci&#xF3;n de nuestra funci&#xF3;n <em>curry</em>, consideremos por
ejemplo que para toda funci&#xF3;n <code>f(x, y)</code>, existe una funci&#xF3;n <code>f&apos;</code> tal que
<code>f&apos;(x)</code> es una funci&#xF3;n que puede ser aplicada a <code>y</code> que obtenga
<code>(f&apos;(x))(y) = f(x, y)</code>.</p>
<p>La funci&#xF3;n <code>f&apos;</code> del ejemplo anterior es llamada forma <em>curried</em> de la funci&#xF3;n.
Desde una perspectiva de programaci&#xF3;n funcional, <em>currying</em> puede ser descrita
por la funci&#xF3;n: <code>curry : ((a, b) -&gt; c) -&gt; (a -&gt; b -&gt; c)</code></p>
<p>Ahora bien, un enfoque es crear una <strong>funci&#xF3;n de orden superior</strong> (<em>Higher
Order Function</em> en ingl&#xE9;s) que tome como argumento una funci&#xF3;n existente que
fue escrita sin todas las devoluciones anidadas (<em>uncurried form</em>). Nuestra
funci&#xF3;n de orden superior debe retornar otra funci&#xF3;n que espera un solo
argumento,...</p>
<pre><code class=\\"language-js\\">const curryIt = f =&gt; x =&gt; {
  // ...
}</code></pre>
<p>Luego que se suministra dicho argumento se procede a verificar si el n&#xFA;mero de
argumentos esperados (<code>Function.length</code>) por la funci&#xF3;n <em>uncurried</em> es igual o
menor a 1, de ser as&#xED; ejecuta dicha funci&#xF3;n, esta condici&#xF3;n particular tambi&#xE9;n
nos servir&#xE1; como condici&#xF3;n de parada en nuestra llamada recursiva.</p>
<pre><code class=\\"language-js\\">const curryIt = f =&gt; x =&gt; {
  if (f.length &lt;= 1) {
    f(x)
  } else {
    // ...
  }
}</code></pre>
<p>En cambio, si el n&#xFA;mero de par&#xE1;metros esperados es mayor a 1 debemos recurrir a
la recursi&#xF3;n y aplicar de nuevo nuestra funci&#xF3;n de orden superior, en este
&#xFA;ltimo caso pasaremos como argumento una nueva funci&#xF3;n equivalente, por medio
de <code>Function.prototype.bind()</code>, a la funci&#xF3;n <em>uncurried</em> excepto por su
par&#xE1;metro inicial. Algo similar a los siguiente:</p>
<pre><code class=\\"language-js\\">// funci&#xF3;n uncurried
const greet = (greeting, name) =&gt; \`\${greeting}, \${name}\`
// funci&#xF3;n equivalente a excepci&#xF3;n del argumento inicial
const greetWithGreeting = greet.bind(null, &apos;Hello&apos;) // [Function: bound greet]
greetWithGreeting(&apos;Heidi&apos;)
// =&gt; &apos;Hello, Heidi&apos;</code></pre>
<p>Sin mayor pre&#xE1;mbulo veamos el resultado final de nuestra funci&#xF3;n <code>curryIt</code>:</p>
<pre><code class=\\"language-js\\">const curryIt = f =&gt; x =&gt; f.length &lt;= 1 ? f(x) : curryIt(f.bind(null, x))</code></pre>
<p>Para usar esto, le pasamos una referencia a una funci&#xF3;n que toma cualquier
n&#xFA;mero de argumentos, junto con tantos de los argumentos como queremos
pre-poblar. Lo que recuperamos es una funci&#xF3;n que est&#xE1; a la espera de los
argumentos restantes:</p>
<pre><code class=\\"language-js\\">const greeter = (greeting, separator, emphasis, name) =&gt;
  \`\${greeting}\${separator}\${name}\${emphasis}\`

test(&apos;should return a curried equivalent of the provided function&apos;, () =&gt; {
  const greetHello = curryIt(greeter)(&apos;Hello&apos;)(&apos;, &apos;)(&apos;.&apos;)

  expect(greetHello(&apos;Heidi&apos;)).toBe(&apos;Hello, Heidi.&apos;)
  expect(greetHello(&apos;Eddie&apos;)).toBe(&apos;Hello, Eddie.&apos;)</code></pre>
<p>Y al igual que antes, no estamos limitados en t&#xE9;rminos del n&#xFA;mero de argumentos
que queremos utilizar al construir funciones derivadas de nuestra funci&#xF3;n
original que usa <em>curry</em>:</p>
<pre><code class=\\"language-js\\">  const greetGoodbye = curryIt(greeter)(&apos;Goodbye&apos;)(&apos;, &apos;)

  expect(greetGoodbye(&apos;.&apos;)(&apos;Joe&apos;)).toBe(&apos;Goodbye, Joe.&apos;)
})</code></pre>
<h2 id=\\"siendo-serios-sobre-curry\\">Siendo serios sobre <em>curry</em></h2>
<p>Nuestra peque&#xF1;a funci&#xF3;n <code>curryIt</code> no puede manejar todos los casos de borde,
como los par&#xE1;metros faltantes u opcionales, pero hace un trabajo razonable
siempre y cuando permanezcamos estrictos sobre la sintaxis para pasar
argumentos.</p>
<p>Algunas bibliotecas funcionales de JavaScript como <a href=\\"http://ramdajs.com/\\" target=\\"_blank\\">Ramda</a> tienen funciones de
<em>curry</em> m&#xE1;s flexibles que pueden dividir los par&#xE1;metros requeridos para una
funci&#xF3;n y permiten pasarlos individualmente o en grupos para crear variaciones
<em>curry</em> personalizadas. Si deseas aplicar <em>curry</em> extensivamente, este es
probablemente el camino a seguir.</p>
<p>Independientemente de c&#xF3;mo elijas a&#xF1;adir <em>curry</em> a tu programaci&#xF3;n, ya sea que
desee utilizar par&#xE9;ntesis anidados o prefieras incluir una funci&#xF3;n de transporte
m&#xE1;s robusta, llegar a una convenci&#xF3;n de nomenclatura coherente para sus
funciones <em>curry</em> ayudar&#xE1; a hacer tu c&#xF3;digo m&#xE1;s legible. Te recomiendo que cada
variaci&#xF3;n derivada de una funci&#xF3;n tenga un nombre que deje claro c&#xF3;mo se
comporta, y qu&#xE9; argumentos est&#xE1; esperando.</p>
<h2 id=\\"orden-de-los-argumentos\\">Orden de los argumentos</h2>
<p>Una cosa que es importante tener en cuenta al momento de implementar <em>curry</em> es
el orden de los argumentos. Usando el enfoque que hemos descrito, obviamente lo
que t&#xFA; deseas es que el argumento que es m&#xE1;s probable que sea reemplazado de
una variaci&#xF3;n a la siguiente sea el &#xFA;ltimo argumento pasado a la funci&#xF3;n
original.</p>
<p>Pensar con antelaci&#xF3;n sobre el orden de los argumentos har&#xE1; que sea m&#xE1;s f&#xE1;cil
dise&#xF1;ar un algoritmo para ser implementado con <em>curry</em>  y aplicarlo a tu
trabajo. Tener en cuenta el orden de tus argumentos en t&#xE9;rminos de menor a mayor
probabilidades de cambiar es un buen h&#xE1;bito al momento de dise&#xF1;ar funciones.</p>
<h2 id=\\"conclusi&#xF3;n\\">Conclusi&#xF3;n</h2>
<p><em>Curry</em> es una t&#xE9;cnica incre&#xED;blemente &#xFA;til en JavaScript funcional. Te permitir&#xE1;
generar una biblioteca de funciones peque&#xF1;as y f&#xE1;cilmente configuradas que se
comportan consistentemente, son r&#xE1;pidas de usar y que se pueden entender al leer
su c&#xF3;digo. Agregar <em>curry</em> a tu pr&#xE1;ctica de codificaci&#xF3;n alentar&#xE1; el uso de
funciones parcialmente aplicadas a trav&#xE9;s de tu c&#xF3;digo, evitando una gran
cantidad de repeticiones, y puede ayudarte a obtener mejores h&#xE1;bitos sobre c&#xF3;mo
nombrar y manejar los argumentos de la funci&#xF3;n.</p>
<h2 id=\\"referencias\\">Referencias</h2>
<ul>
<li><a href=\\"https://www.sitepoint.com/currying-in-functional-javascript/\\" target=\\"_blank\\">A Beginner&#x2019;s Guide to Currying in Functional JavaScript</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\\" target=\\"_blank\\">Function.prototype.bind()</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length\\" target=\\"_blank\\">Function.length</a></li>
<li><a href=\\"http://www.cs.nott.ac.uk/~pszgmh/faq.html#currying\\" target=\\"_blank\\">Frequently Asked Questions for comp.lang.functional</a></li>
<li><div class=\\"iframe-container\\"><iframe id=\\"ytplayer\\" type=\\"text/html\\" width=\\"640\\" height=\\"360\\" frameborder=\\"0\\" src=\\"https://www.youtube.com/embed/iZLP4qOwY8I?autoplay=0\\"></iframe></div>
por Mattias P Johansson</li>
</ul>
",
  "embeds": Array [
    Object {
      "href": "https://www.youtube.com/watch?v=iZLP4qOwY8I",
      "id": "iZLP4qOwY8I",
      "provider": "youtube",
      "type": "video",
    },
  ],
  "format": "self-paced",
  "title": "Aplicando _curry_ en JavaScript funcional",
  "type": "lectura",
}
`;

exports[`common common.tokensToHTML(tokens, links) should trim dangling <hr> 1`] = `
"<p>Blah blah Blah</p>
<p>Foo bar baz</p>
"
`;
