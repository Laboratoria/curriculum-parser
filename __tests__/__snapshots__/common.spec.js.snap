// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`common common.parseReadme(data, metaKeys) should ignore unknown meta data keys 1`] = `
Object {
  "body": "<h3 id=\\"resumen\\">Resumen</h3>
<p>Llegamos al final de la unidad ;-)</p>
<p>En la programación funcional, las programadoras tienden a evitar dos hábitos
comunes en otros lenguajes:</p>
<ul>
<li><em>Mutación:</em> Cambio de los datos <em>in-situ</em> en vez de retornar un valor.</li>
<li><em>Estado compartido:</em> Contexto extra que no se provee como argumento a la
función, por ejemplo, variables globales.</li>
</ul>
<p>Al no depender del estado ni de las mutaciones, el comportamiento de cada
función está contenido. Por lo tanto, es más sencillo realizar pruebas del
comportamiento de dichas funciones, entre otra serie de beneficios.</p>
<p>Una vez dicho todo esto, existen ocasiones donde el uso de funciones puras no es
posible, especialmente en funciones que emplean <em>side-effects</em> para llevar a
cabo su cometido, por ejemplo el uso de promesas en JavaScript. Pero este tema,
lo veremos en una siguiente lección.</p>
<h3 id=\\"respondamos-juntxs-las-preguntas-de-la-apertura\\">Respondamos juntxs las preguntas de la apertura</h3>
<ul>
<li>Cómo evitar que nuestras funciones tengan efectos colaterales?</li>
<li>Por qué es beneficioso evitar el estado compartido?</li>
<li>Cuáles son las ventajas que ofrecen las funciones puras, en particular a la
hora de hacer testing?</li>
<li>Cómo evitar la mutación de objetos y arreglos?</li>
<li>Qué tipos de datos son mutables e inmutables en JavaScript?</li>
<li>Cómo usar métodos de arreglos como <code>Array#concat</code>, <code>Array#slice</code>, <code>Array#map</code>,
<code>Array#filter</code>, ... para crear arreglos nuevos en vez de mutar (modificar)
valores existentes?</li>
<li>Cómo usar métodos de objetos (por ejemplo <code>Object.assign()</code>) para copiar
propiedades y así <em>clonar</em> objetos?</li>
<li>Cómo usar el <em>spread operator</em> (<code>...</code>) para copiar objetos y arreglos?</li>
</ul>
<h3 id=\\"auto-evaluación\\">Auto-evaluación</h3>
<p>Tus instructorxs te compartirán un link al cuestionario de <em>auto evaliación</em>.
Este cuestionario no es calificado.</p>
",
  "duration": "15min",
  "format": "guiado",
  "title": "Cierre",
  "type": "seminario",
}
`;

exports[`common common.parseReadme(data, metaKeys) should parse ok when all meta data is present 1`] = `
Object {
  "body": "<h3 id=\\"resumen\\">Resumen</h3>
<p>Llegamos al final de la unidad ;-)</p>
<p>En la programación funcional, las programadoras tienden a evitar dos hábitos
comunes en otros lenguajes:</p>
<ul>
<li><em>Mutación:</em> Cambio de los datos <em>in-situ</em> en vez de retornar un valor.</li>
<li><em>Estado compartido:</em> Contexto extra que no se provee como argumento a la
función, por ejemplo, variables globales.</li>
</ul>
<p>Al no depender del estado ni de las mutaciones, el comportamiento de cada
función está contenido. Por lo tanto, es más sencillo realizar pruebas del
comportamiento de dichas funciones, entre otra serie de beneficios.</p>
<p>Una vez dicho todo esto, existen ocasiones donde el uso de funciones puras no es
posible, especialmente en funciones que emplean <em>side-effects</em> para llevar a
cabo su cometido, por ejemplo el uso de promesas en JavaScript. Pero este tema,
lo veremos en una siguiente lección.</p>
<h3 id=\\"respondamos-juntxs-las-preguntas-de-la-apertura\\">Respondamos juntxs las preguntas de la apertura</h3>
<ul>
<li>Cómo evitar que nuestras funciones tengan efectos colaterales?</li>
<li>Por qué es beneficioso evitar el estado compartido?</li>
<li>Cuáles son las ventajas que ofrecen las funciones puras, en particular a la
hora de hacer testing?</li>
<li>Cómo evitar la mutación de objetos y arreglos?</li>
<li>Qué tipos de datos son mutables e inmutables en JavaScript?</li>
<li>Cómo usar métodos de arreglos como <code>Array#concat</code>, <code>Array#slice</code>, <code>Array#map</code>,
<code>Array#filter</code>, ... para crear arreglos nuevos en vez de mutar (modificar)
valores existentes?</li>
<li>Cómo usar métodos de objetos (por ejemplo <code>Object.assign()</code>) para copiar
propiedades y así <em>clonar</em> objetos?</li>
<li>Cómo usar el <em>spread operator</em> (<code>...</code>) para copiar objetos y arreglos?</li>
</ul>
<h3 id=\\"auto-evaluación\\">Auto-evaluación</h3>
<p>Tus instructorxs te compartirán un link al cuestionario de <em>auto evaliación</em>.
Este cuestionario no es calificado.</p>
",
  "duration": "15min",
  "format": "guiado",
  "title": "Cierre",
  "type": "seminario",
}
`;

exports[`common common.parseReadme(data, metaKeys) should warn when missing meta data 1`] = `
Object {
  "body": "<p>La técnica de definir funciones atadas a múltiples parámetros como una serie de
funciones anidadas que solo esperan un parámetro fue popularizada por el
matemático <a href=\\"https://en.wikipedia.org/wiki/Haskell_Curry\\" target=\\"_blank\\">Haskell Curry</a>, aunque inicialmente observada por <a href=\\"https://en.wikipedia.org/wiki/Gottlob_Frege\\" target=\\"_blank\\">Frege</a> en
1893, a dicha cadena de funciones anidadas se les llama funciones curry o
<em>curried functions</em>.</p>
<h2 id=\\"¿qué-es-currying\\">¿Qué es <em>currying</em>?</h2>
<p>En pocas palabras, <em>currying</em> es una técnica que traduce la evaluación de una
función que toma múltiples argumentos en una evaluación de una secuencia de
funciones, cada una de funciones de la secuencia espera un único argumento.
<em>Currying</em> está relacionado con el concepto de <a href=\\"https://en.wikipedia.org/wiki/Partial_application\\" target=\\"_blank\\">aplicación
parcial</a>, pero no es lo mismo.</p>
<p>El <em>currying</em> es elemental en la mayoría de los lenguajes de programación
funcional, por ejemplo Haskell o Scala. A pesar que JavaScript ofrece soporte
para algunas características funcionales, al menos en las versiones actuales, el
<em>currying</em> no es una de ellas. Sin embargo, podemos <em>emular</em> este patrón con las
características actuales del lenguaje.</p>
<p>Para darte una idea de cómo este concepto podría funcionar, vamos a crear
nuestra primera función <em>curry</em> en JavaScript, utilizando la sintaxis familiar
para construir la funcionalidad <em>currying</em> que queremos. Como ejemplo,
imaginemos una función que salude a alguien por su nombre. Todos sabemos cómo
crear una función simple de saludo que toma un nombre y un saludo, y registra el
saludo con el nombre:</p>
<pre><code class=\\"language-js\\">const greet = (greeting, name) =&gt; \`\${greeting}, \${name}\`

test('Should say Hello', () =&gt; {
  expect(greet('Hello', 'Heidi')).toBe('Hello, Heidi')
})
</code></pre>
<p>Esta función requiere que el nombre y el saludo se pasen como argumentos para
que funcione correctamente. Pero podríamos reescribir la función usando
<em>currying</em> anidado simple, de modo que la función básica sólo requiera un
saludo, y devuelve otra función que toma el nombre de la persona que queremos
saludar.</p>
<h2 id=\\"nuestro-primer-curry\\">Nuestro primer <em>curry</em></h2>
<pre><code class=\\"language-js\\">const greetCurried = greeting =&gt; name =&gt; \`\${greeting}, \${name}\`
</code></pre>
<p>Este pequeño ajuste a la forma en que escribimos la función anterior nos permite
crear una nueva función para cualquier tipo de saludo, y pasar a esa nueva
función el nombre de la persona que queremos saludar:</p>
<pre><code class=\\"language-js\\">test('Should allow to reuse functions', () =&gt; {
  const greetHello = greetCurried('Hello')

  expect(greetHello('Heidi')).toBe('Hello, Heidi')
  expect(greetHello('Eddie')).toBe('Hello, Eddie')
})
</code></pre>
<p>También podemos llamar a la función en modo <em>curry</em> original directamente,
simplemente pasando cada uno de los parámetros en un conjunto separado de
paréntesis, uno después del otro:</p>
<pre><code class=\\"language-js\\">test('Should work with all the parameters', () =&gt; {
  expect(greetCurried('Hi there')('Howard')).toBe('Hi there, Howard')
})
</code></pre>
<h2 id=\\"apliquemos-curry-a-todo\\">Apliquemos <em>curry</em> a todo</h2>
<p>Lo bueno es que ahora que hemos aprendido a modificar nuestra función
tradicional para usar este enfoque para manejar los argumentos, podemos hacerlo
con tantos argumentos como queramos:</p>
<pre><code class=\\"language-js\\">const greetDeeplyCurried = greeting =&gt;
  separator =&gt;
    emphasis =&gt;
      name =&gt;
        \`\${greeting}\${separator}\${name}\${emphasis}\`
</code></pre>
<p>Tenemos la misma flexibilidad con cuatro argumentos que con dos. No importa lo
lejos que vaya el anidamiento, podemos crear nuevas funciones personalizadas
para saludar a tantas personas como escojamos de tantas maneras como nos
convenga:</p>
<pre><code class=\\"language-js\\">test('Should allow nested calls', () =&gt; {
  const greetAwkwardly = greetDeeplyCurried('Hello')('...')('?')

  expect(greetAwkwardly('Heidi')).toBe('Hello...Heidi?')
  expect(greetAwkwardly('Eddie')).toBe('Hello...Eddie?')
})
</code></pre>
<p>Además, podemos pasar tantos parámetros como quisiéramos al crear variaciones
personalizadas de nuestra función <em>curry</em> original, creando nuevas funciones que
son capaces de tomar el número apropiado de parámetros adicionales, cada uno se
pasa por separado en su propio conjunto de paréntesis:</p>
<pre><code class=\\"language-js\\">test('Other variations', () =&gt; {
  const sayHello = greetDeeplyCurried('Hello')(', ')

  expect(sayHello('.')('Heidi')).toBe('Hello, Heidi.')
  expect(sayHello('.')('Eddie')).toBe('Hello, Eddie.')
</code></pre>
<p>Y se pueden definir variaciones subordinadas:</p>
<pre><code class=\\"language-js\\">  const askHello = sayHello('?')

  expect(askHello('Heidi')).toBe('Hello, Heidi?')
  expect(askHello('Eddie')).toBe('Hello, Eddie?')
})
</code></pre>
<h2 id=\\"aplicando-curry-a-funciones-tradicionales\\">Aplicando <em>curry</em> a funciones tradicionales</h2>
<p>Puedes ver lo poderoso que es este enfoque, especialmente si necesitas crear
muchas funciones personalizadas muy detalladas. El único problema es la
sintaxis, pues a medida que construyes estas funciones con <em>curry</em>, debes
mantener las funciones devueltas anidadas, y llamarlas con nuevas funciones que
requieran varios conjuntos de paréntesis, cada uno conteniendo su propio
argumento aislado. Se puede poner difícil y enredado.</p>
<p>Antes de abordar la implementación de nuestra función <em>curry</em>, consideremos por
ejemplo que para toda función <code>f(x, y)</code>, existe una función <code>f'</code> tal que
<code>f'(x)</code> es una función que puede ser aplicada a <code>y</code> que obtenga
<code>(f'(x))(y) = f(x, y)</code>.</p>
<p>La función <code>f'</code> del ejemplo anterior es llamada forma <em>curried</em> de la función.
Desde una perspectiva de programación funcional, <em>currying</em> puede ser descrita
por la función: <code>curry : ((a, b) -&gt; c) -&gt; (a -&gt; b -&gt; c)</code></p>
<p>Ahora bien, un enfoque es crear una <strong>función de orden superior</strong> (<em>Higher
Order Function</em> en inglés) que tome como argumento una función existente que
fue escrita sin todas las devoluciones anidadas (<em>uncurried form</em>). Nuestra
función de orden superior debe retornar otra función que espera un solo
argumento,...</p>
<pre><code class=\\"language-js\\">const curryIt = f =&gt; x =&gt; {
  // ...
}
</code></pre>
<p>Luego que se suministra dicho argumento se procede a verificar si el número de
argumentos esperados (<code>Function.length</code>) por la función <em>uncurried</em> es igual o
menor a 1, de ser así ejecuta dicha función, esta condición particular también
nos servirá como condición de parada en nuestra llamada recursiva.</p>
<pre><code class=\\"language-js\\">const curryIt = f =&gt; x =&gt; {
  if (f.length &lt;= 1) {
    f(x)
  } else {
    // ...
  }
}
</code></pre>
<p>En cambio, si el número de parámetros esperados es mayor a 1 debemos recurrir a
la recursión y aplicar de nuevo nuestra función de orden superior, en este
último caso pasaremos como argumento una nueva función equivalente, por medio
de <code>Function.prototype.bind()</code>, a la función <em>uncurried</em> excepto por su
parámetro inicial. Algo similar a los siguiente:</p>
<pre><code class=\\"language-js\\">// función uncurried
const greet = (greeting, name) =&gt; \`\${greeting}, \${name}\`
// función equivalente a excepción del argumento inicial
const greetWithGreeting = greet.bind(null, 'Hello') // [Function: bound greet]
greetWithGreeting('Heidi')
// =&gt; 'Hello, Heidi'
</code></pre>
<p>Sin mayor preámbulo veamos el resultado final de nuestra función <code>curryIt</code>:</p>
<pre><code class=\\"language-js\\">const curryIt = f =&gt; x =&gt; f.length &lt;= 1 ? f(x) : curryIt(f.bind(null, x))
</code></pre>
<p>Para usar esto, le pasamos una referencia a una función que toma cualquier
número de argumentos, junto con tantos de los argumentos como queremos
pre-poblar. Lo que recuperamos es una función que está a la espera de los
argumentos restantes:</p>
<pre><code class=\\"language-js\\">const greeter = (greeting, separator, emphasis, name) =&gt;
  \`\${greeting}\${separator}\${name}\${emphasis}\`

test('should return a curried equivalent of the provided function', () =&gt; {
  const greetHello = curryIt(greeter)('Hello')(', ')('.')

  expect(greetHello('Heidi')).toBe('Hello, Heidi.')
  expect(greetHello('Eddie')).toBe('Hello, Eddie.')
</code></pre>
<p>Y al igual que antes, no estamos limitados en términos del número de argumentos
que queremos utilizar al construir funciones derivadas de nuestra función
original que usa <em>curry</em>:</p>
<pre><code class=\\"language-js\\">  const greetGoodbye = curryIt(greeter)('Goodbye')(', ')

  expect(greetGoodbye('.')('Joe')).toBe('Goodbye, Joe.')
})
</code></pre>
<h2 id=\\"siendo-serios-sobre-curry\\">Siendo serios sobre <em>curry</em></h2>
<p>Nuestra pequeña función <code>curryIt</code> no puede manejar todos los casos de borde,
como los parámetros faltantes u opcionales, pero hace un trabajo razonable
siempre y cuando permanezcamos estrictos sobre la sintaxis para pasar
argumentos.</p>
<p>Algunas bibliotecas funcionales de JavaScript como <a href=\\"http://ramdajs.com/\\" target=\\"_blank\\">Ramda</a> tienen funciones de
<em>curry</em> más flexibles que pueden dividir los parámetros requeridos para una
función y permiten pasarlos individualmente o en grupos para crear variaciones
<em>curry</em> personalizadas. Si deseas aplicar <em>curry</em> extensivamente, este es
probablemente el camino a seguir.</p>
<p>Independientemente de cómo elijas añadir <em>curry</em> a tu programación, ya sea que
desee utilizar paréntesis anidados o prefieras incluir una función de transporte
más robusta, llegar a una convención de nomenclatura coherente para sus
funciones <em>curry</em> ayudará a hacer tu código más legible. Te recomiendo que cada
variación derivada de una función tenga un nombre que deje claro cómo se
comporta, y qué argumentos está esperando.</p>
<h2 id=\\"orden-de-los-argumentos\\">Orden de los argumentos</h2>
<p>Una cosa que es importante tener en cuenta al momento de implementar <em>curry</em> es
el orden de los argumentos. Usando el enfoque que hemos descrito, obviamente lo
que tú deseas es que el argumento que es más probable que sea reemplazado de
una variación a la siguiente sea el último argumento pasado a la función
original.</p>
<p>Pensar con antelación sobre el orden de los argumentos hará que sea más fácil
diseñar un algoritmo para ser implementado con <em>curry</em>  y aplicarlo a tu
trabajo. Tener en cuenta el orden de tus argumentos en términos de menor a mayor
probabilidades de cambiar es un buen hábito al momento de diseñar funciones.</p>
<h2 id=\\"conclusión\\">Conclusión</h2>
<p><em>Curry</em> es una técnica increíblemente útil en JavaScript funcional. Te permitirá
generar una biblioteca de funciones pequeñas y fácilmente configuradas que se
comportan consistentemente, son rápidas de usar y que se pueden entender al leer
su código. Agregar <em>curry</em> a tu práctica de codificación alentará el uso de
funciones parcialmente aplicadas a través de tu código, evitando una gran
cantidad de repeticiones, y puede ayudarte a obtener mejores hábitos sobre cómo
nombrar y manejar los argumentos de la función.</p>
<h2 id=\\"referencias\\">Referencias</h2>
<ul>
<li><a href=\\"https://www.sitepoint.com/currying-in-functional-javascript/\\" target=\\"_blank\\">A Beginner’s Guide to Currying in Functional JavaScript</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\\" target=\\"_blank\\">Function.prototype.bind()</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length\\" target=\\"_blank\\">Function.length</a></li>
<li><a href=\\"http://www.cs.nott.ac.uk/~pszgmh/faq.html#currying\\" target=\\"_blank\\">Frequently Asked Questions for comp.lang.functional</a></li>
<li><div class=\\"iframe-container\\"><iframe width=\\"640\\" height=\\"360\\" src=\\"https://www.youtube.com/embed/iZLP4qOwY8I?autoplay=0\\" frameborder=\\"0\\" gesture=\\"media\\" allow=\\"encrypted-media\\" allowfullscreen=\\"true\\"></iframe></div>
por Mattias P Johansson</li>
</ul>
",
  "embeds": Array [
    Object {
      "href": "https://www.youtube.com/watch?v=iZLP4qOwY8I",
      "id": "iZLP4qOwY8I",
      "provider": "youtube",
      "type": "video",
    },
  ],
  "format": "self-paced",
  "title": "Aplicando _curry_ en JavaScript funcional",
  "type": "lectura",
}
`;

exports[`common common.tokensToHTML(tokens, links) should trim dangling <hr> 1`] = `
"<p>Blah blah Blah</p>
<p>Foo bar baz</p>
"
`;

exports[`common common.tokensToHTML(tokens, links) should trim multiple dangling <hr> 1`] = `
"<p>Blah blah Blah</p>
<p>Foo bar baz</p>
"
`;

exports[`common common.tokensToHTML(tokens, links) should trim multiple preceding <hr> 1`] = `
"<p>Blah blah Blah</p>
<p>Foo bar baz</p>
"
`;

exports[`common common.tokensToHTML(tokens, links) should trim preceding <hr> 1`] = `
"<p>Blah blah Blah</p>
<p>Foo bar baz</p>
"
`;
