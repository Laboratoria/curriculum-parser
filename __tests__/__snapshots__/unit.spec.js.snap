// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`unit should parse a unit dir containing a part dir with a README.md 1`] = `
Object {
  "00-opening": Object {
    "body": "<h2 id=\\"¿por-qué-aprender-esto\\">¿Por qué aprender esto?</h2>
<p>Como indica el nombre del curso, vamos a hablar de <em>Paradigmas de programación</em>,
que son formas diferentes de pensar en cómo se organiza un programa.</p>
<p>Como desarrollador <strong>Full Stack JS</strong> es esencial entender los distintos
paradigmas de programación y cómo se traducen al mundo real en proyectos de
JavaScript.</p>
<p>Históricamente, el paradigma orientado a objetos (OOP) ha sido el predominante,
pero recientemente, y en particular en la comunidad de JavaScript, hay un
resurgir del paradigma funcional y sus bondades. <strong>JavaScript es un lenguaje de
corazón funcional</strong>, así que conocer el paradigma, y cómo se compara a la
programación orientada a objetos, no sólo te hará una mejor coder, si no que
podrás entender cómo se pueden enfrentar los mismos problemas con enfoques
distintos, e identificar y adaptarse a bases de código existentes.</p>
<p>En este curso nos concentraremos en los paradigmas más relevantes para
JavaScript y cómo se materializan en este contexto.</p>
<h2 id=\\"guía-de-preguntas-y-conceptos-clave\\">Guía de preguntas y conceptos clave</h2>
<p>Cuando empezamos a estudiar un tema nuevo, es útil tener una idea de los
conceptos más importantes de lo que vamos a aprender y de los temas centrales
que debemos prestar particular atención.</p>
<p>A continuación te presentamos una serie de preguntas que debes ser capaz de
responder al terminar esta unidad. Utiliza estas preguntas como guía para
orientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida
que avanzas para validar que estás avanzando en la dirección correcta. Que te
sirva como un \\"checklist\\" que vas marcando a medida que vas progresando.</p>
<ul>
<li>Qué son los <strong>paradigmas de programación</strong>?</li>
<li>Qué es el estilo <strong>imperativo</strong></li>
<li>Qué es el estilo <strong>declarativo</strong></li>
<li>Qué paradigmas encajan dentro del estilo <strong>imperativo</strong> y cuales en el
<strong>declarativo</strong></li>
<li>Qué es la <strong>programación por procedimientos</strong>?</li>
<li>Qué es la <strong>programación orientada a objetos</strong>?</li>
<li>Qué es la <strong>programación funcional</strong>?</li>
<li>Cómo se aplican los diferentes paradigmas al mundo de JavaScript?</li>
<li>Cómo se comparan los diferentes paradigmas (diferencias, similitudes, ...)?</li>
<li>Cómo programar en los diferentes estilos</li>
</ul>
",
    "duration": 5,
    "format": "self-paced",
    "title": "Apertura",
    "type": "read",
  },
  "01-overview": Object {
    "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/6frz31ykmi?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>Los <strong>Paradigmas de Programación</strong> (<em>Programming Paradigms</em>) son formas
diferentes de pensar en cómo se organiza un programa basado en una serie de
principios, los cuales resultan en estilos muy distintos y lenguajes muy
diversos.</p>
<p>Consideremos la siguiente función:</p>
<pre><code class=\\"language-js\\">function sum(array) {
  var total = 0;
  for (var i = 0; i &lt; array.length; i++) {
    total += array[i];
  }
  return total;
}
</code></pre>
<p>La función <code>sum(array)</code> recibe un array de números y retorna la suma de todos
los elementos del array. Para llevar a cabo la suma, usamos la variable <code>total</code>,
la cual vamos a ir actualizando (mutando) mientras vamos recorriendo el arreglo
con un bucle (<code>for</code> en este caso). Estas características son típicas del estilo
imperativo.</p>
<p>Ahora, podemos implementar exactamente la misma funcionalidad usando un enfoque
completamente distinto.</p>
<pre><code class=\\"language-js\\">function sum(array) {
  if (!array.length) {
    return 0;
  }
  return array[0] + sum(array.slice(1));
};
</code></pre>
<p>En esta segunda implementación, la función <code>sum(array)</code> sigue teniendo la misma
interfaz (recibe los mismos argumentos y retorna lo mismo), pero claramente
podemos ver que la lógica se expresa de una manera muy diferente. En la versión
recursiva hemos reemplazado el bucle <code>for</code> por recursión, y además podemos ver
que no hay asignación ni mutación de variables, el \\"cómputo\\" se hace por
aplicación de argumentos a funciones. Este tipo de características son propias
del paradigma funcional.</p>
<hr>
<p>PRO TIP:</p>
<p>Haciendo uso de ES2015 podemos refactorizar la versión funcional de <code>sum</code> de
esta manera:</p>
<pre><code class=\\"language-js\\">const sum = array =&gt; !array.length ? 0 : array[0] + sum(array.slice(1));
</code></pre>
<hr>
<p>Cuando hablamos de <strong>Paradigmas de Programación</strong> inevitablemente tenemos que
hablar de lenguajes de programación. Algunos lenguajes, como JavaScript, son
<em>multi-paradigma</em>, lo que quiere decir que nos permiten programar en diferentes
paradigmas, mientras que otros se enfocan específicamente en uno.</p>
<p><strong>JavaScript</strong> es un leguage <em>híbrido</em>, por decirlo de alguna forma, y contiene
elementos propios de lenguajes funcionales (por ejemplo funciones como objetos
de primera clase, lambdas, ...) pero no estamos limitados al paradigma
funcional. <strong>JavaScript nos permite programar de forma <em>funcional</em>, <em>orientado a
objetos</em>, <em>orientado a eventos</em>, <em>por procedimientos</em>, ...</strong></p>
<p>También veremos que los \\"paradigmas\\" son \\"estilos\\" de programación que no son
necesariamente exclusivos. De hecho, algunos son complementarios o evoluciones
de paradigmas más antiguos o con un nivel de abstracción más bajo. Así, la
programación procedural y orientada a objetos, por ejemplo, ambas son
imperativas, ya que comparten una raíz común.</p>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Blog posts:</p>
<ul>
<li><a href=\\"http://www.ybrikman.com/writing/2014/04/09/six-programming-paradigms-that-will/\\" target=\\"_blank\\">Six programming paradigms that will change how you think about coding</a>,
Yevgeniy Brikman, Apr 09 2014</li>
</ul>
<p>Videos:</p>
<ul>
<li><div class=\\"iframe-container\\"><iframe width=\\"640\\" height=\\"360\\" src=\\"https://www.youtube.com/embed/sqV3pL5x8PI?autoplay=0\\" frameborder=\\"0\\" gesture=\\"media\\" allow=\\"encrypted-media\\" allowfullscreen=\\"true\\"></iframe></div>,
<code>10:43</code>, <a href=\\"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\\" target=\\"_blank\\">Computerphile</a>,
30 Aug 2013</li>
<li><div class=\\"iframe-container\\"><iframe width=\\"640\\" height=\\"360\\" src=\\"https://www.youtube.com/embed/4A2mWqLUpzw?autoplay=0\\" frameborder=\\"0\\" gesture=\\"media\\" allow=\\"encrypted-media\\" allowfullscreen=\\"true\\"></iframe></div>,
<code>8:27</code>, <a href=\\"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\\" target=\\"_blank\\">Computerphile</a>,
Jun 28 2016</li>
<li><a href=\\"https://www.video2brain.com/mx/tutorial/que-es-un-paradigma-de-programacion\\" target=\\"_blank\\">Qué es un paradigma de programación</a>,
<code>5:15</code>, José Dimas Luján Castillo, <a href=\\"https://www.video2brain.com/\\" target=\\"_blank\\">video2brain</a>,
8 Mar 2017</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://en.wikipedia.org/wiki/Programming_paradigm\\" target=\\"_blank\\">Definición de Programming_paradigm en Wikipedia</a></li>
<li><a href=\\"https://en.wikipedia.org/wiki/Comparison_of_programming_paradigms\\" target=\\"_blank\\">Comparativa de paradigmas de programación en Wikipedia</a></li>
</ul>
",
    "duration": 5,
    "embeds": Array [
      Object {
        "href": "https://laboratoria.wistia.com/medias/6frz31ykmi?wvideo=6frz31ykmi",
        "id": "6frz31ykmi",
        "provider": "wistia",
        "type": "video",
      },
      Object {
        "href": "https://www.youtube.com/watch?v=sqV3pL5x8PI",
        "id": "sqV3pL5x8PI",
        "provider": "youtube",
        "type": "video",
      },
      Object {
        "href": "https://www.youtube.com/watch?v=4A2mWqLUpzw",
        "id": "4A2mWqLUpzw",
        "provider": "youtube",
        "type": "video",
      },
    ],
    "format": "self-paced",
    "title": "¿Qué son los paradigmas de programación?",
    "type": "read",
  },
  "02-history": Object {
    "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/an9covln5w?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>Para tener una idea general de los paradigmas y sus peculiaridades, es útil
repasar brevemente su historia.</p>
<p>El primer paradigma en aparecer, primera mitad de los años 50, es el
<strong>imperativo</strong>, que se caracteriza por un nivel bajo de abstracción. Por lo
tanto el código está enfocado en las instrucciones que la computadora debe
seguir, y no necesariamente en la semántica o lógica de la funcionalidad que
estamos implementando (el cómo nosotros pensamos en lo que hace el programa).</p>
<p>Veamos un ejemplo de <code>Assembly</code>, el primer lenguaje \\"moderno\\", que apareció en
el año 1949, y que sigue vivo a día de hoy, eso sí, para cosas muy específicas,
que nos son necesariamente lo que vemos los desarrolladores web, pero que sirve
para este ejemplo ;-)</p>
<pre><code class=\\"language-assembly_x86\\">section .text             ;section declaration

                          ;we must export the entry point to the ELF linker or
  global  _start          ;loader. They conventionally recognize _start as their
                          ;entry point. Use ld -e foo to override the default.

_start:

                          ;write our string to stdout

  mov     edx,len         ;third argument: message length
  mov     ecx,msg         ;second argument: pointer to message to write
  mov     ebx,1           ;first argument: file handle (stdout)
  mov     eax,4           ;system call number (sys_write)
  int     0x80            ;call kernel

                          ;and exit

  mov     ebx,0           ;first syscall argument: exit code
  mov     eax,1           ;system call number (sys_exit)
  int     0x80            ;call kernel

section .data             ;section declaration

msg db    \\"Hello, world!\\",0xa    ;our dear string
len equ   $ - msg                ;length of our dear string
</code></pre>
<p><a href=\\"http://www.tldp.org/HOWTO/Assembly-HOWTO/hello.html\\" target=\\"_blank\\">Fuente: Assembly-HOWTO</a></p>
<p>El snippet de arriba es un \\"hello world\\" escrito en <code>Assembly</code> (una versión
moderna, pero muy parecido a lo que hubieras visto en los años 50). Lo único que
hace este programa es imprimir el string <code>Hello, world!</code>. El equivalente a todo
el código de arriba en JavaScript sería:</p>
<pre><code class=\\"language-js\\">console.log('Hello, world!');
</code></pre>
<p>En nuestro caso, JavaScript tiene un nivel de abstracción mucho más alto. Con lo
cual, no tenemos que preocuparnos de muchos detalles que JavaScript ya abstrae
para nosotros, como manejo de memoria, instrucciones del procesador, etc. Esto
nos permite expresar de forma más \\"humana\\" la intención de nuestro programa, y
con mucho menos código.</p>
<p>Regresamos a los años 50. Según la programación va evolucionando, y los
programas creciendo, vemos cómo van a ir surgiendo diferentes formas de
\\"abstraer\\", \\"organizar\\" y \\"reusar\\" el código. A finales de los años 50 vemos
como aparecen <strong>Fortran II</strong> y <strong>Lisp</strong>, introduciendo la programación
<strong>procedural</strong> y <strong>funcional</strong>. Con ambos enfoques pasamos a nuevos nieveles de
abstracción y mejora en el reuso de código.</p>
<p>En los años 70 y 80 se da el boom de la programación orientada a objetos,
primero con <strong>Smalltalk</strong> y después <strong>C++</strong>.</p>
<p><strong>JavaScript</strong> nace en 1995, el mismo año que <strong>Java</strong>, <strong>Ruby</strong> y <strong>PHP</strong>. La
década de los 90 se caracteriza por los lenguajes multi-paradigma. En ese
contexto JavaScript destaca por su dinamismo y su naturaleza funcional. De hecho
a nivel conceptual, JavaScript está fuertemente inspirado por <strong>Scheme</strong>, que es
un lenguaje funcional, y los prototipos de <strong>Self</strong>, aunque por necesidades del
mercado, la sintáxis se parece más a la familia de lenguajes de <strong>C</strong> y
<strong>Java</strong>, que son imperativos. Por esta razón, JavaScript se considera muchas
veces <a href=\\"http://javascript.crockford.com/javascript.html\\" target=\\"_blank\\">el lenguaje más
incomprendido</a>, y quizás
confuso.</p>
<p>Como referencia, abajo podemos ver una tabla con algunos de los lenguajes más
significativos a nivel de cambios de paradigma, y el conexto en el que aparece
JavaScript.</p>
<table>
<thead>
<tr>
<th>Año</th>
<th>Lenguaje</th>
<th>Paradigma</th>
</tr>
</thead>
<tbody><tr>
<td>1949</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Assembly_language\\" target=\\"_blank\\">Assembly</a></td>
<td>imperativo</td>
</tr>
<tr>
<td>1957</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Fortran\\" target=\\"_blank\\">Fortran</a></td>
<td>imperativo</td>
</tr>
<tr>
<td>1958</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Fortran#FORTRAN_II\\" target=\\"_blank\\">Fortran II</a></td>
<td>imperativo, procedural</td>
</tr>
<tr>
<td>1958</td>
<td><a href=\\"https://goo.gl/ZbUXeg\\" target=\\"_blank\\">Lisp</a></td>
<td>funcional</td>
</tr>
<tr>
<td>1965</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Simula\\" target=\\"_blank\\">Simula</a></td>
<td>orientado a objetos</td>
</tr>
<tr>
<td>1972</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Smalltalk\\" target=\\"_blank\\">Smalltalk</a></td>
<td>orientado a objetos</td>
</tr>
<tr>
<td>1972</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Prolog\\" target=\\"_blank\\">Prolog</a></td>
<td>lógico</td>
</tr>
<tr>
<td>1972</td>
<td><a href=\\"https://goo.gl/4bnEHY\\" target=\\"_blank\\">C</a></td>
<td>imperativo, procedural, estructurado</td>
</tr>
<tr>
<td>1975</td>
<td><a href=\\"https://goo.gl/x2WMht\\" target=\\"_blank\\">Scheme</a></td>
<td>funcional</td>
</tr>
<tr>
<td>1983</td>
<td><a href=\\"https://en.wikipedia.org/wiki/C%2B%2B\\" target=\\"_blank\\">C++</a></td>
<td>imperativo, procedural, estructurado, orientado a objetos</td>
</tr>
<tr>
<td>1987</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Perl\\" target=\\"_blank\\">Perl</a></td>
<td>imperativo, procedural, funcional, orientado a objetos, orientado a eventos</td>
</tr>
<tr>
<td>1991</td>
<td><a href=\\"https://goo.gl/bJ9Wcg\\" target=\\"_blank\\">Python</a></td>
<td>imperativo, procedural, funcional, orientado a objetos</td>
</tr>
<tr>
<td>1995</td>
<td><a href=\\"https://goo.gl/PhfLjJ\\" target=\\"_blank\\">Ruby</a></td>
<td>imperativo, funcional, orientado a objetos</td>
</tr>
<tr>
<td>1995</td>
<td><a href=\\"https://goo.gl/aWjoSR\\" target=\\"_blank\\">Java</a></td>
<td>imperativo, orientado a objetos</td>
</tr>
<tr>
<td>1995</td>
<td><a href=\\"https://en.wikipedia.org/wiki/PHP\\" target=\\"_blank\\">PHP</a></td>
<td>imperativo, procedural, orientado a objetos</td>
</tr>
<tr>
<td>1995</td>
<td><a href=\\"https://en.wikipedia.org/wiki/JavaScript\\" target=\\"_blank\\">JavaScript</a></td>
<td>imperativo, funcional, orientado a objetos, orientado a eventos</td>
</tr>
</tbody></table>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://en.wikipedia.org/wiki/History_of_programming_languages\\" target=\\"_blank\\">History of programming languages</a></li>
</ul>
",
    "duration": 5,
    "embeds": Array [
      Object {
        "href": "https://laboratoria.wistia.com/medias/an9covln5w?wvideo=an9covln5w",
        "id": "an9covln5w",
        "provider": "wistia",
        "type": "video",
      },
    ],
    "format": "self-paced",
    "title": "Historia",
    "type": "read",
  },
  "03-declarative-vs-imperative": Object {
    "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/ty5mr7p77t?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>Hemos mencionado que los primeros lenguajes de programación eran imperativos, y
que se centraban en el \\"cómo\\" más que en el \\"qué\\". Como contrapartida, el estilo
declarativo se caracteriza por lo contrario, enfocarse más en \\"qué\\" queremos
hacer, desde el punto de vista de un ser humano, en vez de cómo lo debe ejecutar
la computadora. Por ende, cuanto más declarativo, más alejado del hardware.</p>
<p>Algunos paradigmas son más imperativos y otros más declarativos. Por ejemplo,
la programación orientada a procedimientos, o la programación orientada objetos,
van a tener un caracter imperativo, mientras que la programación funcional tiene
un caracter mucho más declarativo.</p>
<p>Imáginemos que tenemos la siguiente data en un array de objetos:</p>
<pre><code class=\\"language-js\\">var array = [
  {id: 'uno', name: 'el primero'},
  {id: 'dos', name: 'el segundo'},
  {name: 'no tengo id'}
];
</code></pre>
<p>A partir de esta data, ahora nos piden extraer los <code>id</code> de cada un de los
objetos y amacenarlos en un nuevo arreglo (<code>ids</code>). Si nos planteamos el
problema desde un enfoque imperativo, podríamos implementar una solución así:</p>
<pre><code class=\\"language-js\\">const ids = [];

for (var i = 0; i &lt; array.length; i++) {
  if (array[i].id) {
    ids.push(array[i].id);
  }
}

console.log(ids); // ['uno', 'dos']
</code></pre>
<p>En el código anterior, probablemente puedas identificar claramente el estilo
imperativo. Las variables como \\"contadores\\" y \\"acumuladores\\", son típicos del
estilo imperativo. En este estilo el principal mecanismo de cómputo se lleva a
cabo a través de la asignación de valores en variables. Veremos así uso de
variables globales y mutación de los valores asignados a variables a través del
tiempo.</p>
<p>JavaScript nos ofrece utilidades para afrontar este tipo problemas desde el
enfoque funcional. Así, los arrays (gracias a <code>Array.prototype</code>) tienen una
serie de métodos para manipular su data a través de \\"higher order functions\\",
que en este caso son funciones que aceptan otra función como argumento, como por
ejemplo <code>Array.prototype.filter</code> o <code>Array.prototype.map</code>. Veamos cómo podemos
usar estas herramientas para implementar la misma lógica:</p>
<pre><code class=\\"language-js\\">const ids = array
  .filter(item =&gt; typeof item.id === 'string')
  .map(item =&gt; item.id);

console.log(ids); // ['uno', 'dos']
</code></pre>
<p>En esta nueva versión hacemos lo siguiente:</p>
<ol>
<li>Usamos <code>Array#filter</code> para crear un nuevo arreglo sólo con aquellos elementos
que tengan un <code>id</code> que sea un string (<code>typeof item.id === 'string'</code>).</li>
<li>Usamos <code>Array#map</code> para transformar cada elemento del arreglo y crear un
nuevo arreglo con los resultados.</li>
</ol>
<p>De esta forma los detalles de la iteración quedan escondidos detrás de
<code>Array#filter</code> y <code>Array#map</code>, haciendo nuestro código más declarativo.</p>
<p>También podemos ver cómo \\"encadenamos\\" (method chaining) las invocaciones de
<code>filter</code> y <code>map</code> ya que ambas retornan un array, que a su vez tiene todos los
métodos de <code>Array.prototype</code>.</p>
<p>El estilo declarativo depende de que el lenguaje (o librerías) nos ofrezcan este
tipo de herramientas o abstracciones con las que poder expresar nuestra lógica
sin preocuparnos tanto sobre los detalles de implementación.</p>
<p>Para terminar esta sección, cabe mencionar que HTML es un lenguaje declarativo!
Muchos se quejarían diciendo que HTML no es un lenguaje de programación, sino un
lenguaje de marcado (<em>markup language</em>). Pero podemos considerear a HTML como un
lenguaje declarativo muy restringido, no de uso general, donde sólo podemos
crear un árbol de nodos a partir de una estructura de etiquetas (<em>tags</em>) con una
sintáxis y semántica predefinida. Es declarativo en el sentido de que no le
estamos diciendo a la computadora cómo convertir nuestro código en
instrucciones, sino que describimos de formal declarativa lo que queremos que
ocurra (el compilador o intérprete se encarga del resto).</p>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Videos:</p>
<ul>
<li><div class=\\"iframe-container\\"><iframe width=\\"640\\" height=\\"360\\" src=\\"https://www.youtube.com/embed/4A2mWqLUpzw?autoplay=0\\" frameborder=\\"0\\" gesture=\\"media\\" allow=\\"encrypted-media\\" allowfullscreen=\\"true\\"></iframe></div>,
<code>8:27</code>, <a href=\\"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\\" target=\\"_blank\\">Computerphile</a>,
Jun 28 2016</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://en.wikipedia.org/wiki/Imperative_programming\\" target=\\"_blank\\">Imperative programming</a></li>
<li><a href=\\"https://en.wikipedia.org/wiki/Declarative_programming\\" target=\\"_blank\\">Declarative programming</a></li>
</ul>
",
    "duration": 15,
    "embeds": Array [
      Object {
        "href": "https://laboratoria.wistia.com/medias/ty5mr7p77t?wvideo=ty5mr7p77t",
        "id": "ty5mr7p77t",
        "provider": "wistia",
        "type": "video",
      },
      Object {
        "href": "https://www.youtube.com/watch?v=4A2mWqLUpzw",
        "id": "4A2mWqLUpzw",
        "provider": "youtube",
        "type": "video",
      },
    ],
    "format": "self-paced",
    "title": "Declarativo vs Imperativo",
    "type": "read",
  },
  "04-imperative-exercise": Object {
    "duration": 5,
    "exercises": Object {
      "01-print-primes": Object {
        "body": "<p>La programación imperativa tiene un nivel de abstracción bajo, lo que quiere
decir que se enfoca en describir, desde el punto de vista de la computadora,
cómo hacer lo que queremos. Nuestro código expresa de forma explícita el control
de flujo, usando bucles, declara variables para llevar la cuenta, ...</p>
<p>En el mundo real, en un lenguaje como JavaScript, vamos a encontrar
características de este paradigma, pero siempre en el contexto de otro paradigma
con un nivel de abtracción más alto y un mecanismo de reuso de código (cómo la
programación orientada a objetos o la prgramación funcional).</p>
<h2 id=\\"tarea\\">Tarea</h2>
<p>El <em>boilerplate</em> (la plantilla sobre la que hacer el ejercicio) contiene un
programa sin terminar. Este programa debe <strong>imprimir en la consola todos los
números primos menores que <code>20</code></strong>.</p>
<p>El <em>boilerplate</em> impementa sólo parte de la lógica. Por el momento imprime todos
los números enteros del <code>2</code> al <code>19</code>. Ahora tienes que añadir la lógica para
comprobar si un número es primo o no, y así sólo imprimir los primos.</p>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li>Debes implementar un bucle <code>for</code> anidado dentro del <code>for</code> ya existente.</li>
</ul>
<h2 id=\\"pistas\\">Pistas</h2>
<ul>
<li>Si un número es divisible por cualquier entero mayor que <code>1</code> que no sea el
número mismo, sabemos que NO es primo.</li>
<li>Dentro del bucle <code>for</code> principal, para ver si un número es primo, vamos a
tratar de demostrar que NO es primo, y si no podemos probar que no es primo,
entonces podemos asumir que sí es primo.</li>
<li>El operador <code>%</code> nos da el residuo de una división.</li>
<li>Una vez que hemos probado que un número no es primo ya no necesitamos
continuar dividiéndolo.</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://goo.gl/zn7cTu\\" target=\\"_blank\\">Arithmetic Operators: Remainder - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for\\" target=\\"_blank\\">Statements: for - MDN</a></li>
</ul>
",
        "env": "js",
        "files": Object {
          "Ym9pbGVycGxhdGU=": Object {
            "cHJpbnRQcmltZXMuanM=": "function printPrimes() {
  // Iteramos desde 2 (el primer número primo) hasta 19 (menor que 20)
  for (var i = 2; i < 20; i++) {
    var isPrime = true;

    // Ahora debemos iterar desde \`2\` hasta \`i / 2\` usando una variable \`j\` como
    // contador.
    //
    // Para cada \`j\` comprueba si la división \`i / j\` deja un residuo.
    //
    // NOTA: No necesitamos probar números más allá de \`i / 2\` porque el
    // resultado de la división \`i / j\` siempre sería una fracción entre 2 y 1,
    // siempre dejando residuo.

    // TU CÓDIGO AQUÍ

    if (isPrime) {
      console.log(i);
    }
  }
}

module.exports = printPrimes;
",
          },
          "c29sdXRpb24=": Object {
            "cHJpbnRQcmltZXMuanM=": "function printPrimes() {
  for (var i = 2; i < 20; i++) {
    var isPrime = true;
    for (var j = 2; j <= (i / 2); j++) {
      if (i % j === 0) {
        isPrime = false;
        break;
      }
    }
    if (isPrime) {
      console.log(i);
    }
  }
}

module.exports = printPrimes;
",
          },
          "dGVzdA==": Object {
            "cHJpbnRQcmltZXMuc3BlYy5qcw==": "'use strict';


const Assert = require('chai').assert;
const Sinon = require('sinon');
const Submission = require('../solution/printPrimes');


describe('printPrimes()', () => {

  const stub = Sinon.stub(console, 'log');
  Submission();
  stub.restore();

  it('debería exportar una función', () => {
    Assert.equal(typeof Submission, 'function');
  });

  it('debería invocar console.log 8 veces', () => {
    Assert.equal(stub.callCount, 8);
  });

  [[2], [3], [5], [7], [11], [13], [17], [19]].forEach((args, idx) => {
    it(\`invocación \${idx + 1} a console.log debería recibir \\"\${args[0]}\\" como único argumento\`, () => {
      Assert.deepEqual(args, stub.getCall(idx).args);
    });
  });

});
",
          },
        },
        "title": "Imprime los número enteros menores que 20",
      },
    },
    "format": "self-paced",
    "title": "Ejercicio imperativo",
    "type": "practice",
  },
  "05-procedural": Object {
    "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/el19ibmhpj?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>La programación por procedimientos (<em>procedural programming</em>) pertenece a la
rama del estilo <em>imperativo</em>. Antes mencionamos que a finales de los años 50
Fortran II introduce la programación por procedimientos, y de esa forma
empezamos a \\"organizar\\", \\"abstraer\\" y \\"reusar\\" nuestro código.</p>
<p>Cuando programamos orientados a procedimientos, lo cual puede ser un enfoque
válido para ciertos programas o scripts, nos concentramos en agrupar código
en procedimientos o funciones, e invocar estos procedimientos con diferentes
argumentos o parámetros. En este sentido es parecido a la programación
funcional, pero con la diferencia de que nos mantenemos en la rama imperativa,
describiendo acciones como pasos secuenciales, que podrían tener efectos
secundarios y donde el output no está necesariamente deterinado por los
argumentos de entrada. Mientras que la programación funcional es más abstracta,
se basa en funciones puras sin efectos secundarios, evitar el estado compartido,
y otros principios específicos de la programación funcional.</p>
<p>Refactoricemos el ejemplo anterior donde sacábamos la propiedad <code>id</code> de una
lista de objetos. Empecemos por envolver el código en una función:</p>
<pre><code class=\\"language-js\\">function getIds(inputArray) {
  const ids = [];

  for (var i = 0; i &lt; inputArray.length; i++) {
    if (inputArray[i].id) {
      ids.push(inputArray[i].id);
    }
  }

  return ids;
}

console.log(getIds(array)); // ['uno', 'dos']
</code></pre>
<p>Este cambio parece menor, pero añade una capa de abstracción que nos da un
montón de flexibilidad. Ahora nuestro código está <em>encapsulado</em> dentro de su
propio <em>scope</em> y podemos reusar la lógica para otros arrays (podemos invocar la
función cuantas veces queramos).</p>
<p>Pero vayamos un paso más allá. Ahora que estamos ordenando nuestro código usando
funciones, aprovechemos a abstraer y mejorar la comprobación que hacíamos para
saber si un objeto tiene una propiedad <code>id</code>.</p>
<pre><code class=\\"language-js\\">function hasId(obj) {
  return obj &amp;&amp; typeof obj.id === 'string';
}

function getIds(inputArray) {
  const ids = [];

  for (var i = 0; i &lt; inputArray.length; i++) {
    if (hasId(inputArray[i])) {
      ids.push(inputArray[i].id);
    }
  }

  return ids;
}

console.log(getIds(array)); // ['uno', 'dos']
console.log(hasId()); // false
console.log(hasId({name: 'foo'})); // false
console.log(hasId({id: 'uno'})); // true
</code></pre>
<p>En esta nueva versión hemos partido el código en dos funciones, y al hacerlo
hemos tenido que dar nombres a estas funciones. Estos nombres representan de
alguna forma esa capa de abstracción. Ahora podemos hablar de <code>hasId()</code>
cuando queremos referirnos a ese pedacito de lógica. Así, poco a poco vamos
creando una semántica que nos permite alejarnos de los detalles de
implementación.</p>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://en.wikipedia.org/wiki/Procedural_programming\\" target=\\"_blank\\">Procedural programming</a></li>
</ul>
",
    "duration": 6,
    "embeds": Array [
      Object {
        "href": "https://laboratoria.wistia.com/medias/el19ibmhpj?wvideo=el19ibmhpj",
        "id": "el19ibmhpj",
        "provider": "wistia",
        "type": "video",
      },
    ],
    "format": "self-paced",
    "title": "Programación por procedimientos",
    "type": "read",
  },
  "06-modules": Object {
    "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/ph5zkst0fv?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>Una de las consecuencias de estos cambios es el concepto de \\"modularidad\\". Esto
va a permitir que empecemos a escribir programas estructurados en módulos
independientes, que son más fáciles de entender, testear, mantener, ...</p>
<p>En JavaScript existen varios sistemas de módulos, principalmente <strong>AMD</strong>,
<strong>Common JS</strong> y <strong>ES2015/ES6</strong>. Para este ejemplo vamos a concentrarnos en
<strong>Common JS</strong>, que es el que usa <strong>Node.js</strong>, y que también podemos usar en el
navegador gracias a los <em>bundlers</em>. En nuestro ejemplo, ahora que nuestro código
vive dentro de una función, podríamos <em>exportar</em> la función, lo que nos
permitiría usar esta función desde otros scripts u otros programas. Esto es
esencial para casi cuaquier programa o script hoy en día, con consecuencias que
damos por sentado como poder organizar nuestro código en archivos y carpetas
diferentes o tener dependecias de módulos externos.</p>
<p>Para exportar nuestra función <code>getIds</code> usando Common JS en Node.js, podemos
simplemente asignar nuestra función a <code>module.exports</code>.</p>
<pre><code class=\\"language-js\\">// al final del script
module.exports = getIds;
</code></pre>
<p>El objeto <code>module</code> es una variable local a cada script en Common JS. Si
asignamos algo a <code>module.exports</code>, éste será el valor que recibiremos cuando
requiramos nuestro \\"módulo\\". Por ejemplo, imaginemos que salvamos el script en
el archivo <code>src/getIds.js</code>, y ahora lo queremos usar desde otro script afuera de
<code>src/</code>:</p>
<pre><code class=\\"language-js\\">const getIds = require('./src/getIds');
// \`getIds\` tiene el valor que hemos exportado a través de \`module.exports\`
// en el script \`src/getIds.js\`
</code></pre>
<p>Common JS también nos ofrece la opción de exportar los valores que queramos
como propiedades del objeto <code>exports</code> (que es un alias de <code>module.exports</code>). Así
en vez de exportar sólo un valor (la función <code>getids</code>), podemos exporar varios
valores.</p>
<pre><code class=\\"language-js\\">exports.getIds = getIds;
exports.hasId = hasId;
</code></pre>
<p>Ahora cuando requerimos nuestro módulo desde otro script lo que recibimos es
un objeto (el objeto <code>exports</code>), que tiene dos propiedades, <code>getIds</code> y <code>hasId</code>.</p>
<pre><code class=\\"language-js\\">const myModule = require('./src/myModule');
// myModule.getIds()
// myModule.hasId()
</code></pre>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Blog posts:</p>
<ul>
<li><a href=\\"http://2ality.com/2014/09/es6-modules-final.html\\" target=\\"_blank\\">ECMAScript 6 modules: the final syntax</a>,
Axel Rauschmayer, 07 Sep 2014</li>
<li><a href=\\"https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc\\" target=\\"_blank\\">JavaScript Modules: A Beginner’s Guide</a>,
Preethi Kasireddy (FreeCodeCamp), Jan 22 2016</li>
</ul>
",
    "duration": 6,
    "embeds": Array [
      Object {
        "href": "https://laboratoria.wistia.com/medias/ph5zkst0fv?wvideo=ph5zkst0fv",
        "id": "ph5zkst0fv",
        "provider": "wistia",
        "type": "video",
      },
    ],
    "format": "self-paced",
    "title": "Modularidad",
    "type": "read",
  },
  "07-procedural-exercise": Object {
    "duration": 10,
    "exercises": Object {
      "01-get-primes": Object {
        "body": "<p>La programación <em>procedural</em> (por procedimientos) introduce el concepto de
procedimientos o funciones que nos permiten agrupar instrucciones, y así reusar
bloques de código e invocarlos con diferentes valores.</p>
<p>Según va creciendo un programa, vamos a tener la necesidad de organizar nuestro
código en pedacitos comprensibles, además de abstraer repetición. La
programación por procedimientos representa un primer paso de abstracción, lo que
nos obliga a tener que dar nombres a estos procedimientos, encapsularlos, y
definir sus interfaces (input/output).</p>
<h2 id=\\"tarea\\">Tarea</h2>
<p>Refactoriza el código que vimos en el ejercicio anterior en dos funciones:</p>
<ul>
<li><code>getPrimes(start, end)</code></li>
<li><code>isPrime(num)</code></li>
</ul>
<p>Ya hemos envuelto el código en una función con el nombre <code>getPrimes</code>.</p>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li>La función <code>getPrimes()</code> recibe dos argumentos: <code>start</code> y <code>end</code>, que nos deben
permitir especificar el rango de números primos que nos interesa.</li>
<li>La función <code>getPrimes()</code> debe retornar un <code>array</code> con los números primos en
vez de imprimirlos en la consola. Para ello usa una variable donde ir gurdando
los números primos que vayamos encontrando y al final de la función devuelve
(retorna) ese array.</li>
<li>En el bucle de <code>getPrimes()</code>, tendrás que sustituir el valor inicial de <code>i</code>
por <code>start</code> y la condición por <code>i &lt; end</code>.</li>
<li>Dentro del bucle de <code>getPrimes()</code> ya no necesitamos la variable <code>isPrime</code>,
ahora debes invocar a la función <code>isPrime()</code> para determinar si el número en
cuestión es primo.</li>
<li>El bucle que en el ejercicio anterior usamos para comprobar si un número es
primo, ahora debe quedar dentro de <code>isPrime()</code>, la cual sólo ha de recibir un
argumento (el número a comprobar) y retornar un booleano (<code>true</code> o <code>false</code>).</li>
<li>Asegúrate de que tu script exporta las funciones <code>getPrimes()</code> e <code>isPrime()</code>.</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions\\" target=\\"_blank\\">Functions - MDN</a></li>
<li><a href=\\"https://nodejs.org/api/modules.html#modules_the_module_object\\" target=\\"_blank\\">The module object - Node.js Docs</a></li>
</ul>
",
        "env": "js",
        "files": Object {
          "Ym9pbGVycGxhdGU=": Object {
            "Z2V0UHJpbWVzLmpz": "function isPrime(num) {
  //...
}

function getPrimes(start, end) {
  for (var i = 2; i < 20; i++) {
    var isPrime = true;

    //...

    if (isPrime) {
      console.log(i);
    }
  }
}
",
          },
          "c29sdXRpb24=": Object {
            "Z2V0UHJpbWVzLmpz": "function isPrime(num) {
  for (var i = 2; i <= (num / 2); i++) {
    if (num % i == 0) {
      return false;
    }
  }
  return true;
}

function getPrimes(start, end) {
  var primes = [];
  for (var i = start; i < end; i++) {
    if (isPrime(i)) {
      primes.push(i);
    }
  }
  return primes;
}

exports.getPrimes = getPrimes;
exports.isPrime = isPrime;
",
          },
          "dGVzdA==": Object {
            "Z2V0UHJpbWVzLnNwZWMuanM=": "'use strict';


const Assert = require('chai').assert;
const Submission = require('../solution/getPrimes');


describe('getPrimes(start, end)', () => {

  it('debería exportar función \`getPrimes\`', () => {
    Assert.equal(typeof Submission.getPrimes, 'function');
  });

  it('debería retornar los número primos menores de 20', () => {
    Assert.deepEqual(Submission.getPrimes(2, 20), [2, 3, 5, 7, 11, 13, 17, 19]);
  });

  it('debería retornar los número primos entre 50 y 100', () => {
    Assert.deepEqual(Submission.getPrimes(50, 100), [53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
  });

});


describe('isPrime(num)', () => {

  it('debería exportar función \`isPrime\`', () => {
    Assert.equal(typeof Submission.isPrime, 'function');
  });

  it('debería retornar true para 2, 3, 5, 13, 89', () => {
    [2, 3, 5, 13, 89].forEach(n => Assert.deepEqual(Submission.isPrime(n), true));
  });

  it('debería retornar false para ', () => {
    [4, 10, 99, 411].forEach(n => Assert.deepEqual(Submission.isPrime(n), false));
  });

  it('debería retornar los número primos entre 50 y 100', () => {
    Assert.deepEqual(Submission.getPrimes(50, 100), [53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
  });

});
",
          },
        },
        "title": "getPrimes()",
      },
    },
    "format": "self-paced",
    "title": "Ejercicio por procedimientos",
    "type": "practice",
  },
  "08-oop": Object {
    "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/8id6wdxrdn?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>La <strong>Programación Orientada a Objetos</strong> (<em>Object Oriented Programming</em> - OOP)
representa un cambio de paradigma bastante grande con respecto al paradigma por
procedimientos que acabamos de ver. Cuando programamos por procedimientos nos
concentramos en funciones, que representan acciones, y así nuestra semántica
está orientada a acciones antes que a estructuras de datos.</p>
<p>En la programación orientada a objetos le damos la vuelta a la tortilla, y en
vez de pensar en acciones nos enfocamos en definir los \\"tipos\\" de datos primero,
y después decidimos que interacciones van a tener. En OOP diseñamos objetos, que
van a tener una data (un estado) y una serie de operaciones que pueden realizar.</p>
<p>A la hora de construir aplicaciones nos vemos obligados a pensar en cómo
\\"modelar\\" o representar en código cosas del mundo real o conceptos útiles para
un ser humano (un usuario, un documento, ...) y la programación orientada a
objetos propone crear tipos de objetos para representar estas cosas.</p>
<p>Imaginemos que tenemos que escribir una aplicación de \\"notas\\" donde el usuario
puede crear diferentes tipos de \\"notas\\", marcarlas como completadas, ... Si
vamos a seguir el estilo orientado a objetos, normalmente empezaríamos por
modelar el \\"tipo de objeto\\" que con el que vamos a representar una \\"nota\\".
Podríamos empezar con algo así:</p>
<pre><code class=\\"language-js\\">function Note(text) {
  this.text = text || '';
  this.createdAt = new Date();
  this.completed = false;
}
</code></pre>
<p>Hemos declarado una función (<code>Note</code>) que hace uso de una <em>pseudo variable</em>
llamada <code>this</code>. La presencia de <code>this</code>, junto con la convención de usar la
primera letra en mayúscula, nos indican que esta función está escrita
para ser invocada con el <em>keyword</em> <code>new</code>. Este tipo de función es lo que
conocemos como un <em>constructor</em>. Los constructores son funciones cuyo propósito
es crear un objeto, inicializarlo y ofrecernos una manera de especificar el
prototipo que tendrán los objetos creados con este constructor. Dicho de otra
manera, menos correcta pero más común, los constructores son lo más parecido a
clases en JavaScript (por lo menos hasta ES6).</p>
<p>JavaScript es un lenguaje dinámicamente tipado (<em>dynamically typed</em>), pero a
diferencia de la mayoría de lenguajes de su generación, usa herencia prototipal
en vez de clases, lo cual suele confundir a muchos programadores con experiencia
en otros lenguajes orientados a objetos.</p>
<p>Cuando invocamos un constructor precedido de <code>new</code>, la pseudo-variable <code>this</code> es
una referencia al nuevo objeto creado al invocar el constructor. Creemos un
objeto para ver que significa todo esto:</p>
<pre><code class=\\"language-js\\">const note = new Note('comprar arroz');
console.log(note);
</code></pre>
<p>En la consola deberías de ver algo así:</p>
<pre><code class=\\"language-text\\">Note {
  text: 'comprar arroz',
  createdAt: 2017-06-14T22:39:51.987Z,
  completed: false }
</code></pre>
<p>Podemos ver que <code>note</code> es un objeto con tres propiedades (<code>text</code>, <code>createdAt</code> y
<code>completed</code>). Estas tres propiedades están declaradas directamente sobre la
instancia.</p>
<p>Cuando usamos constructores, es importante acordarnos de usar <code>new</code> a la hora de
invocarlos, si no, el constructor retornará <code>undefined</code>.</p>
<pre><code class=\\"language-js\\">const note = Note('comprar arroz');
console.log(note); // undefined
</code></pre>
<p>Hemos dicho que una de las características fundamentales de OOP es que empezamos
por definir los tipos de datos (ya sea con clases, constructores, prototipos,
...), lo cual nos permite inspeccionar los objetos creados para saber si son
una instacia de un constructor (con el operador <code>instanceof</code>) o comprobar si un
objeto está en la cadena de prototipos de otro objeto
(<code>Object.prototype.isPrototypeOf</code>).</p>
<pre><code class=\\"language-js\\">console.log(note instanceof Note); // true
console.log(Note.prototype.isPrototypeOf(note)); // true
</code></pre>
<p>Ahora que ya hemos definido un constructor que inicializa una serie de
propiedades, podemos usar el prototipo del constructor (<code>Note.prototype</code>) para
añadir funcionalidad. Todo lo que le añadamos a <code>Note.prototype</code> será parte del
prototipo de los objetos creados por <code>new Note()</code>. Añadamos un método al
prototipo de <code>Note</code>:</p>
<pre><code class=\\"language-js\\">Note.prototype.toString = function () {
  let str = '[' + (this.completed ? 'X' : ' ') + ']';
  str += ' | ' + this.createdAt.toDateString();
  str += ' | ' + this.text;
  return str;
};
</code></pre>
<p>Hemos añadido el método <code>Note.prototype.toString</code>, que simplemente retorna una
representación de nuestro objeto como string. Ahora todos los objetos que
creemos con <code>new Note()</code> deberían de \\"heredar\\" un método <code>toString</code>. Si hacemos
<code>console.log(note)</code> veremos las tres propiedades que seteamos en el constructor,
pero qué pasó con el método <code>toString</code> que le habíamos  añadimo al prototipo de
<code>Note</code>?</p>
<p>Inspeccionemos un poco...</p>
<pre><code class=\\"language-js\\">console.log(note.prototype); // undefined
console.log(note.__proto__); // Note { toString: [Function] }
console.log(note.toString); // [Function]
</code></pre>
<p>El objeto <code>note</code> sí tiene el método <code>toString</code>, pero no directamente sobre la
instancia, si no que está en su prototipo. Cuando tratamos de acceder a una
propiedad que no existe en un objeto, JavaScript va a buscar a ver si hay una
propiedad con ese nombre en el prototipo del objeto, si la encuentra usará esa,
si no buscará en el prototipo del prototipo, y así irá recorriendo lo que
conocemos como la cadena de prototipos (prototype chain).</p>
<p>En la programación orientada a objetos el principal mecanismo de reuso de código
es la \\"herencia\\", donde un objeto \\"hereda\\" una serie de propiedades y métodos
de otro objeto o clase (en herencia prototipal heredamos directamente de un
objeto en vez de una clase).</p>
<p>En la próxima unidad de este curso exploraremos los detalles de cómo implementar
jerarquías de herencia usando prototipos. Por el momento nos quedamos con estos
conceptos.</p>
<p>Ahora que hemos visto qué es la programación orientada a objetos en el contexto
de JavaScript, concluyamos con una lista de características que definen a OOP de
forma más general, por el propio Alan Kay, creador del término OOP y Smalltalk:</p>
<blockquote>
<p>Traducido al español:</p>
<ul>
<li>Todo es un objeto</li>
<li>Los objetos se comunican enviando y recibiendo mensajes (en términos de objetos)</li>
<li>Los objetos deben tener su propia memoria (en términos de objetos)</li>
<li>Todo objeto es una instancia de una clase (que debe ser un objeto)</li>
<li>La clase tiene el comportamiento compartido para las instancias (como objetos
en un programa)</li>
<li>Para evaluar un programa, se pasa el control al primer objeto y el resto se
trata como su mensaje.</li>
</ul>
<p>Original en inglés:</p>
<ul>
<li>Everything Is An Object</li>
<li>Objects communicate by sending and receiving messages (in terms of objects).</li>
<li>Objects have their own memory (in terms of objects).</li>
<li>Every object is an instance of a class (which must be an object).</li>
<li>The class holds the shared behavior for its instances (in the form of objects
in a program list)</li>
<li>To eval a program list, control is passed to the first object and the
remainder is treated as its message.</li>
</ul>
<p>Fuente <a href=\\"http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented\\" target=\\"_blank\\">Alan Kays Definition Of Object Oriented</a></p>
</blockquote>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Blog posts:</p>
<ul>
<li><a href=\\"https://css-tricks.com/understanding-javascript-constructors/\\" target=\\"_blank\\">Understanding JavaScript Constructors</a>,
Faraz Kelhini, CSS Tricks, Sep 24 2015</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented\\" target=\\"_blank\\">Alan Kays Definition Of Object Oriented</a></li>
<li><a href=\\"https://en.wikipedia.org/wiki/Object-oriented_programming\\" target=\\"_blank\\">Object-oriented programming</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\\" target=\\"_blank\\">MDN - instanceof</a></li>
</ul>
",
    "duration": 15,
    "embeds": Array [
      Object {
        "href": "https://laboratoria.wistia.com/medias/8id6wdxrdn?wvideo=8id6wdxrdn",
        "id": "8id6wdxrdn",
        "provider": "wistia",
        "type": "video",
      },
    ],
    "format": "self-paced",
    "title": "OOP",
    "type": "read",
  },
  "09-oop-exercise": Object {
    "duration": 10,
    "exercises": Object {
      "01-notes": Object {
        "body": "<p>En la programación orientada a objetos (OOP), nos concentramos en describir
objetos, que tienen una data (un estado) y una serie de operaciones que pueden
realizar.</p>
<p>Imaginemos que estamos construyendo una aplicación de \\"notas\\", donde el usuario
puede añadir notas con un texto. Antes de empezar a implementar tratamos de
imaginarnos los objetos que participan de este proceso. Lo primero que se nos
viene a la mente es que vamos a necesitar objetos de tipo \\"nota\\".</p>
<h2 id=\\"tarea\\">Tarea</h2>
<p>El boilerplate contiene dos constructores (<code>Note</code> y <code>Notes</code>). El primero
(<code>Note</code>) ya está implemetado. Ahora nos piden implementar los métodos
<code>Notes.prototype.add</code> y <code>Notes.prototype.toString</code>.</p>
<h2 id=\\"ejemplo\\">Ejemplo</h2>
<p>Una vez implementado el ejercicio, alguien que importe tu módulo debería de
poder hacer lo siguiente:</p>
<pre><code class=\\"language-js\\">const note1 = new Note('hola');
const note2 = new Note('mundo');
const notes = new Notes();

notes.add(note1);
notes.add(note2);

console.log(notes.toString());

// [ ] | Mon Jun 12 2017 | mundo
// [ ] | Mon Jun 12 2017 | hola

note1.completed = true;

console.log(notes.toString());

// [ ] | Mon Jun 12 2017 | mundo
// [X] | Mon Jun 12 2017 | hola
</code></pre>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li><code>Notes.prototype.add</code> debe botar error (throw) si el argumento (<code>note</code>) no es
una instancia de <code>Note</code>.</li>
<li><code>Notes.prototype.add</code> debe añadir nuevas notas al principio de <code>this.data</code>, no
al final.</li>
<li>La implementación de <code>Notes.prototype.toString</code> debe iterar sobre las notas e
invocar <code>toString</code> en cada nota y así ir concatenando el resultado. El string
que retornes debe contener una línea para cada nota (ver ejemplo).</li>
<li>El método <code>Notes.prototype.toString</code> debe listar las notas ordenadas por fecha
de creación descendente, la última añadida debe aparecer primero.</li>
<li>No olvides exportar los constructores <code>Note</code> y <code>Notes</code>.</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\\" target=\\"_blank\\">Operators: instanceof - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift\\" target=\\"_blank\\">Array#unshift - MDN</a></li>
<li><a href=\\"https://css-tricks.com/understanding-javascript-constructors/\\" target=\\"_blank\\">Understanding JavaScript Constructors - CSS Tricks</a></li>
</ul>
",
        "env": "js",
        "files": Object {
          "Ym9pbGVycGxhdGU=": Object {
            "bm90ZXMuanM=": "function Note(text) {
  this.text = text || '';
  this.createdAt = new Date();
  this.completed = false;
}

// Convierte note en un string con este formato:
// [X] | Mon Jun 12 2017 | mundo
Note.prototype.toString = function () {
  let str = '[' + (this.completed ? 'X' : ' ') + ']';
  str += ' | ' + this.createdAt.toDateString();
  str += ' | ' + this.text;
  return str;
};


function Notes() {
  this.data = [];
}

Notes.prototype.add = function (note) {
  //...
};

Notes.prototype.toString = function () {
  //...
};
",
          },
          "c29sdXRpb24=": Object {
            "bm90ZXMuanM=": "function Note(text) {
  this.text = text || '';
  this.createdAt = new Date();
  this.completed = false;
}

Note.prototype.toString = function () {
  let str = '[' + (this.completed ? 'X' : ' ') + ']';
  str += ' | ' + this.createdAt.toDateString();
  str += ' | ' + this.text;
  return str;
};


function Notes() {
  this.data = [];
}

Notes.prototype.add = function (note) {
  if (!(note instanceof Note)) {
    throw new Error('Wrong type!');
  }

  this.data.unshift(note);
};

Notes.prototype.toString = function () {
  let str = '';
  for (let i = 0; i < this.data.length; i++) {
    if (i > 0) {
      str += '\\\\n';
    }
    str += this.data[i].toString();
  }
  return str;
};


exports.Note = Note;
exports.Notes = Notes;
",
          },
          "dGVzdA==": Object {
            "bm90ZXMuc3BlYy5qcw==": "'use strict';


const Assert = require('chai').assert;
const Submission = require('../solution/notes');
const Note = Submission.Note;
const Notes = Submission.Notes;


describe('Note', () => {

  it('debería exportar función \`Note\`', () => {
    Assert.equal(typeof Note, 'function');
  });

  it('debería crear un nuevo objeto cuando invocamos new Note()', () => {
    const note = new Note('renovar dni');
    Assert.equal(note.text, 'renovar dni');
    Assert.ok(note.createdAt instanceof Date);
    Assert.equal(note.completed, false);
  });

  it('debería retornar undefined cuando invocamos Note() sin \\"new\\"', () => {
    Assert.equal(Note('renovar dni'), undefined);
  });

});


describe('Note#toString', () => {

  it('debería convertir objeto a string', () => {
    const note = new Note('foo');
    const date = (new Date()).toDateString();
    Assert.equal(note.toString(), '[ ] | ' + date + ' | foo');
    note.completed = true;
    Assert.equal(note.toString(), '[X] | ' + date + ' | foo');
  });

});


describe('Notes (oop)', () => {

  it('debería exportar función \`Notes\`', () => {
    Assert.equal(typeof Notes, 'function');
  });

});


describe('Notes#add', () => {

  it('debería botar error cuando argumento no es instancia de Note', () => {
    [
      undefined, null, true, false, 0, 1, 3.14, '', 'foo', [], [1, 2], {},
      {foo: 'bar'}, new Date(), function () {}
    ].forEach((val) => {

      const notes = new Notes();
      Assert.throws(_ => notes.add(val), Error);
    });
  });


  it('debería permitir añadir instancias de Note', () => {
    const notes = new Notes();
    Assert.doesNotThrow(_ => notes.add(new Note('one')));
  });

});


describe('Notes#toString', () => {

  it('debería retornar un string vacío cuando no hay notas', () => {
    const notes = new Notes();
    Assert.equal(notes.toString(), '');
  });


  it('debería ordenar lista por fecha de creación descendente', () => {
    const notes = new Notes();
    const note1 = new Note('one');
    const date = (new Date()).toDateString();

    notes.add(note1);
    notes.add(new Note('two'));

    Assert.equal(notes.toString(), [
      '[ ] | ' + date + ' | two',
      '[ ] | ' + date + ' | one'
    ].join('\\\\n'));

    note1.completed = true;

    Assert.equal(notes.toString(), [
      '[ ] | ' + date + ' | two',
      '[X] | ' + date + ' | one'
    ].join('\\\\n'));
  });

});
",
          },
        },
        "title": "Notes (OOP)",
      },
    },
    "format": "self-paced",
    "title": "Ejercicio OOP",
    "type": "practice",
  },
  "10-fp": Object {
    "body": "<p>Finalmente llegamos al paradigma funcional (<em>Functional Programming</em>), y digo
finalmente porque es probable que sientas curiosidad por conocer un poco más
sobre este paradigma tan incomprendido, pero tan de moda en el mundo de
JavaScript.</p>
<p>A diferencia del paradigma procedural y el orientado a objetos, la programación
funcional pertenece a la rama de los paradigmas <em>declarativos</em>. Esto quiere
decir que el \\"estilo\\" en el que programamos va a estar mucho más enfocado en qué
queremos hacer y no tanto en los detalles de cómo la computadora lo ejecuta.</p>
<p>Cuando hablamos del estilo imperativo dijimos que nos enfocábamos en asignar
valores a variables, mutar esas variables, e iterar usando bucles. La
programación funcional se caracteriza por exactamente lo opuesto. <strong>En FP el
principal mecanismo de cómputo es la aplicación de argumentos a funciones</strong>.
Como consecuencia, evitamos la asignación de varialbles, mutación, delegamos el
control de flujo, ... De hecho, podemos resumir los principios de la
programación funcional en los siguientes:</p>
<ul>
<li><strong>Higher order functions</strong> (funciones como argumentos y/o valores de retorno)</li>
<li><strong>Funciones puras</strong> (sin efectos secundarios y siempre retorna lo mismo para
los mismos argumentos)</li>
<li><strong>Composición</strong> de funciones</li>
<li><strong>Inmutabilidad</strong> (no \\"mutar\\" valores asignados)</li>
<li><strong>Evitar el \\"estado\\" compartido</strong> (no usar referencias fuera del scope de la
función)</li>
<li>Uso de <strong>recursión</strong> como alternativa a la iteración.</li>
</ul>
<p>Veamos estos conceptos en acción:</p>
<pre><code class=\\"language-js\\">// pasando una función anónima como un argumento
setTimeout(function () {
  //...
}, 100);


// recibiendo una función como un argumento
function map(arr, fn) {
  const results = [];
  for (let i = 0; i &lt; arr.length; i++) {
    results.push(fn(arr[i]));
  }
  return results;
}

// Ahora reemplazando iteración con recursividad
function recursiveMap(arr, fn) {
  if (!arr.length) {
    return [];
  }
  return [fn(arr[0])].concat(recursiveMap(arr.slice(1), fn));
}
</code></pre>
<p>La última función (<code>recursiveMap</code>) es un buen ejemplo de FP porque muestra como
podemos recibir una función como argumento, reemplzar iteración por recursión,
evitar asignación y mutación. Además no accede a ninguna referencia fuera de su
scope (sólo usa variables locales) y no tiene ningún efecto secundario: se
limita a producir un valor de retorno a partir de su input (argumentos) sin
afectar nada fuera de su <em>scope</em>.</p>
<p>Para comparar con el ejemplo que hicimos de OOP, ahora vamos a crear una función
que cree objetos, algo parecido a un constructor, pero muy distinto a la vez.
Los constructores son un tipo de función especial que se invoca con <code>new</code>, usa
<code>this</code> internamente y define un prototipo. La función que vamos a implementar
ahora se va a limitar a crear un objeto y retornarlo, nada de <code>new</code>, <code>this</code> o
<code>prototype</code>.</p>
<pre><code class=\\"language-js\\">const createRobot = function (name) {
  return {
    name: name,
    active: false
  };
};
</code></pre>
<p>ES2015 introduce \\"arrow functions\\" (funciones flecha), que es una implementación
de funciones muy parecida al keyword <code>function</code>, pero que no implica <code>new</code>,
<code>this</code> ni <code>prototype</code>.</p>
<pre><code class=\\"language-js\\">const createRobot = (name) =&gt; {
  return {
    name: name,
    active: false
  };
};
</code></pre>
<hr>
<p>PRO TIP:</p>
<p>Con un poquito más de azúcar sintáctica cortesía de ES2015:</p>
<pre><code class=\\"language-js\\">const createRobot = name =&gt; ({
  name,
  active: false
});
</code></pre>
<p>Cuando el cuerpo de la función es sólo una expresión (un objeto literal en
nuestro caso), las \\"arrow functions\\" nos permiten hacer <em>retorno implícito</em>, lo
que significa que podemos obviar los <code>{}</code> que determinan el \\"bloque\\" de la
función y el keyword <code>return</code>. El resultado de evaluar la expresión será el
valor de retorno. En este ejemplo hemos envuelto la expresión (el objeto
literal) en paréntesis <code>()</code> para evitar que los <code>{}</code> se confundan con el cuerpo
de la función. En este caso los curly braces son parte del objeto!</p>
<hr>
<p>En FP, en vez de pensar en \\"tipos\\", normalmente nos centramos en
transformaciones. Es decir, una función recibe un input (argumentos) y de alguna
forma los \\"transforma\\" en otra cosa. Por ejemplo, en la función anterior,
podemos decir que la función <code>createRobot</code> transforma un <code>string</code> (su input) en
un objeto (su valor de retorno). De esta forma cada función está completamente
aislada del mundo exterior y se concentra en hacer sólo una cosa.</p>
<p>Un buen ejemplo para visualzar el concepto de transformación es el método
<code>Array#map</code> en JavaScript (muy parecido al map que acabamos de implementar).
<code>Array.prototype.map</code> recibe un argumento, una función que será invocada para
cada elemento del array, y retorna un nuevo arreglo con los resultados de cada
invocación a la función que recibe <code>Array#map</code> como argumento.</p>
<pre><code class=\\"language-js\\">const array = ['1', '02', '33', '3.14', '028'];

const double = num =&gt; num + num;

console.log(array.map(double));
// [ '11', '0202', '3333', '3.143.14', '028028' ]

console.log(array.map(parseFloat));
// [ 1, 2, 33, 3.14, 28 ]

console.log(array.map(parseFloat).map(double));
// [ 2, 4, 66, 6.28, 56 ]

const arrayToDouble = array =&gt; array.map(parseFloat).map(double);

console.log(arrayToDouble(array));
// [ 2, 4, 66, 6.28, 56 ]
</code></pre>
<p>Como vemos en estos ejemplos, podemos encadenar invocaciones a <code>Array#map</code> para
ir \\"transformando\\" los elementos de un arreglo, ya que cada invocación retorna
un array.</p>
<h2 id=\\"qué-ventajas-ofrece\\">Qué ventajas ofrece?</h2>
<ul>
<li>Cómo hemos visto en el ejemplo de arriba, el código funcional tiende a ser más
conciso y expresivo.</li>
<li>Más predecible. Más adelante veremos que como resultado de los principios del
paradigma (uso de funciones puras, inmutabilidad, evitar estado compartido y
efectos secundarios, ...) nuestro código será más fácil de predecir, aislar y
probar.</li>
<li>Se presta a la paralelización y la computación distribuida.</li>
<li>Se presta a la asincrónia.</li>
<li>JavaScript, como lenguaje, tiene una naturaleza más funcional que imperativa.</li>
</ul>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Blog posts:</p>
<ul>
<li><a href=\\"https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257\\" target=\\"_blank\\">Why Learn Functional Programming in JavaScript? (Composing Software)</a>,
Eric Elliott en Medium, Feb 20 2017</li>
<li><a href=\\"https://bethallchurch.github.io/JavaScript-and-Functional-Programming/\\" target=\\"_blank\\">JavaScript and Functional Programming</a>,
Beth Allchurch, 29 of June, 2016</li>
<li><a href=\\"https://codewords.recurse.com/issues/one/an-introduction-to-functional-programming\\" target=\\"_blank\\">An introduction to functional programming</a>,
Mary Rose Cook</li>
<li><a href=\\"https://medium.com/laboratoria-how-to/introducci%C3%B3n-a-la-programaci%C3%B3n-funcional-en-javascript-parte-1-e0b1d0b2142e\\" target=\\"_blank\\">Introducción a programación funcional en JavaScript — Parte 1</a>,
Lupo Montero en Medium, Feb 15 2017</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\\" target=\\"_blank\\">MDN - Arrow functions</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\\" target=\\"_blank\\">MDN - Array.prototype.map</a></li>
</ul>
",
    "duration": 10,
    "format": "self-paced",
    "title": "FP",
    "type": "read",
  },
  "11-fp-exercise": Object {
    "duration": 10,
    "exercises": Object {
      "01-notes": Object {
        "body": "<h2 id=\\"tarea\\">Tarea</h2>
<p>Implementa tres funciones con las siguientes \\"firmas\\":</p>
<h3 id=\\"createnotetext\\"><code>createNote(text)</code></h3>
<p>Esta función debe crear un objeto literal con tres propiedades (ver retorno).</p>
<h4 id=\\"argumentos\\">Argumentos</h4>
<ul>
<li><code>text</code>: un string con el texto de la nota</li>
</ul>
<h4 id=\\"retorno\\">Retorno</h4>
<p>Un objeto con 3 propiedades:</p>
<ul>
<li><code>text</code>: el texto de la nota.</li>
<li><code>createdAt</code>: objeto tipo <code>Date</code> creado cuando se invoca <code>createNote</code>.</li>
<li><code>completed</code>: un booleano con valor <code>false</code> por defecto.</li>
</ul>
<h3 id=\\"createnotesarray\\"><code>createNotes(array)</code></h3>
<p>Crea un arreglo de objetos a partir de un arreglo de strings. Cada objeto en el
nuevo arreglo será creado usando <code>createNote</code>.</p>
<h4 id=\\"argumentos-1\\">Argumentos</h4>
<ul>
<li><code>array</code>: Un array de strings con los textos de las notas.</li>
</ul>
<h4 id=\\"retorno-1\\">Retorno</h4>
<p>Un arreglo de objetos donde cada objeto tiene la estructura esperada de nota.</p>
<h3 id=\\"notestostringnotes\\"><code>notesToString(notes)</code></h3>
<p>Convierte un arreglo de notas (objetos con la estructura que hemos visto) en un
string. Para ello debe invocar <code>noteToString</code> para cada elemento en el array.</p>
<h4 id=\\"argumentos-2\\">Argumentos</h4>
<ul>
<li><code>notes</code>: Un arreglo de objetos (notas).</li>
</ul>
<h4 id=\\"retorno-2\\">Retorno</h4>
<p>Un string donde tenemos una línea por cada nota.</p>
<h2 id=\\"ejemplo\\">Ejemplo</h2>
<pre><code class=\\"language-js\\">const notes = createNotes(['hola', 'mundo']);

console.log(notes);

// [ { text: 'hola',
//    createdAt: 2017-06-15T17:40:56.093Z,
//    completed: false },
//  { text: 'mundo',
//    createdAt: 2017-06-15T17:40:56.093Z,
//    completed: false } ]

console.log(notesToString(notes));

// [ ] | Mon Jun 12 2017 | mundo
// [ ] | Mon Jun 12 2017 | hola

notes[0].completed = true;

console.log(notesToString(notes));

// [ ] | Mon Jun 12 2017 | mundo
// [X] | Mon Jun 12 2017 | hola
</code></pre>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li>Tu módulo debe exportar cuatro funciones: <code>createNote</code>, <code>noteToString</code>,
<code>createNotes</code> y <code>notesToString</code>.</li>
<li>Tus funciones deben de ser \\"puras\\" (no side effects).</li>
<li>Evita usar asignación dentro del cuerpo de las funciones.</li>
<li>Usa <code>Array#map</code> para implementar <code>createNotes</code> y <code>notesToString</code>.</li>
<li>Todas las funciones deben ser \\"arrow functions\\"</li>
</ul>
<h2 id=\\"bonus-points\\">Bonus points</h2>
<ul>
<li>Evita usar el \\"keyword\\" <code>return</code> cuando puedas usar retorno implícito.</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\\" target=\\"_blank\\">Arrow functions - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\\" target=\\"_blank\\">Array#map - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join\\" target=\\"_blank\\">Array#join - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\\" target=\\"_blank\\">Date - MDN</a></li>
</ul>
",
        "env": "js",
        "files": Object {
          "Ym9pbGVycGxhdGU=": Object {
            "bm90ZXMuanM=": "const createNote = text => {}; // debes implementar esta función ;-)

const noteToString = note => [
  '[' + (note.completed ? 'X' : ' ') + ']',
  ' | ' + note.createdAt.toDateString(),
  ' | ' + note.text
].join('');

const createNotes = array => {}; // debes implementar esta función ;-)

const notesToString = notes => {}; // debes implementar esta función ;-)
",
          },
          "c29sdXRpb24=": Object {
            "bm90ZXMuanM=": "const createNote = text => ({
  text,
  createdAt: new Date(),
  completed: false
});

const noteToString = note => [
  '[' + (note.completed ? 'X' : ' ') + ']',
  ' | ' + note.createdAt.toDateString(),
  ' | ' + note.text
].join('');

const createNotes = array => array.map(createNote);

const notesToString = notes => notes.map(noteToString).join('\\\\n');

exports.createNote = createNote;
exports.noteToString = noteToString;
exports.createNotes = createNotes;
exports.notesToString = notesToString;
",
          },
          "dGVzdA==": Object {
            "bm90ZXMuc3BlYy5qcw==": "'use strict';


const Assert = require('chai').assert;
const Submission = require('../solution/notes');
const { createNote, noteToString, createNotes, notesToString } = Submission;


describe('createNote()', () => {

  it('debería exportar función \`createNote\`', () => {
    Assert.equal(typeof createNote, 'function');
  });

  it('debería crear un objeto con los campos esperados', () => {
    const note = createNote('renovar dni');
    Assert.equal(note.text, 'renovar dni');
    Assert.ok(note.createdAt instanceof Date);
    Assert.equal(note.completed, false);
    Assert.equal(note.__proto__, Object.prototype);
  });

});

describe('noteToString()', () => {

  it('debería exportar función \`noteToString\`', () => {
    Assert.equal(typeof noteToString, 'function');
  });

  it('debería convertir objeto a string', () => {
    const note = createNote('foo');
    const date = (new Date()).toDateString();
    Assert.equal(noteToString(note), '[ ] | ' + date + ' | foo');
    note.completed = true;
    Assert.equal(noteToString(note), '[X] | ' + date + ' | foo');
  });

});

describe('createNotes()', () => {

  it('debería exportar función \`createNotes\`', () => {
    Assert.equal(typeof createNotes, 'function');
  });

});

describe('notesToString()', () => {

  it('debería exportar función \`notesToString\`', () => {
    Assert.equal(typeof notesToString, 'function');
  });

  it('debería retornar un string vacío cuando no hay notas', () => {
    const notes = createNotes([]);
    Assert.equal(notesToString(notes), '');
  });


  it('debería ordenar lista por fecha de creación descendente', () => {
    const notes = createNotes(['one']);
    const date = (new Date()).toDateString();

    notes.unshift(createNote('two'));

    Assert.equal(notesToString(notes), [
      '[ ] | ' + date + ' | two',
      '[ ] | ' + date + ' | one'
    ].join('\\\\n'));

    notes[1].completed = true;

    Assert.equal(notesToString(notes), [
      '[ ] | ' + date + ' | two',
      '[X] | ' + date + ' | one'
    ].join('\\\\n'));
  });

});
",
          },
        },
        "title": "Notes (FP)",
      },
    },
    "format": "self-paced",
    "title": "Ejercicio FP",
    "type": "practice",
  },
  "13-closing": Object {
    "body": "<h2 id=\\"resumen\\">Resumen</h2>
<p>Los <strong>Paradigmas de Programación</strong> (<em>Programming Paradigms</em>) son formas
diferentes de pensar en cómo se organiza un programa basado en una serie de
principios, los cuales resultan en estilos muy distintos y lenguajes muy
diversos.</p>
<p>Algunos paradigmas son más <strong>imperativos</strong> y otros más <strong>declarativos</strong>. Por
ejemplo, la programación orientada a procedimientos, o la programación orientada
objetos, van a tener un caracter imperativo, mientras que la programación
funcional tiene un caracter mucho más declarativo.</p>
<p>La <strong>programación por procedimientos</strong> (<em>procedural programming</em>) pertenece a la
rama del estilo <em>imperativo</em>. Cuando programamos orientados a procedimientos nos
concentramos en agrupar código en procedimientos o funciones.</p>
<p>En la <strong>programación orientada a objetos</strong> , vez de pensar en acciones nos
enfocamos en definir los \\"tipos\\" de datos primero, y después decidimos que
interacciones van a tener. En OOP diseñamos objetos, que van a tener una data
(un estado) y una serie de operaciones que pueden realizar.</p>
<p>En la <strong>programación orientada a objetos</strong> el principal mecanismo de reuso de
código es la <strong>herencia</strong>, donde un objeto \\"hereda\\" una serie de propiedades y
métodos de otro objeto o clase (en <em>herencia prototipal</em> heredamos directamente
de un objeto en vez de una clase).</p>
<p>La <strong>programación funcional</strong> pertenece a la rama de los paradigmas
<em>declarativos</em>. Esto quiere decir que el \\"estilo\\" en el que programamos va a
estar mucho más enfocado en <em>qué queremos hacer</em> y no tanto en los detalles de
<em>cómo la computadora lo ejecuta</em>.</p>
<p>En FP el principal mecanismo de cómputo es la aplicación de argumentos a
funciones. Como consecuencia, evitamos la asignación de varialbles, mutación y
delegamos el control de flujo.</p>
<p>Principios de la programación funcional:</p>
<ul>
<li><strong>Higher order functions</strong> (funciones como argumentos y/o valores de retorno)</li>
<li><strong>Funciones puras</strong> (sin efectos secundarios y siempre retorna lo mismo para
los mismos argumentos)</li>
<li><strong>Composición</strong> de funciones</li>
<li><strong>Inmutabilidad</strong> (no \\"mutar\\" valores asignados)</li>
<li><strong>Evitar el \\"estado\\" compartido</strong> (no usar referencias fuera del scope de la
función)</li>
<li>Uso de <strong>recursión</strong> como alternativa a la iteración.</li>
</ul>
<h2 id=\\"respondamos-juntxs-las-preguntas-de-la-apertura\\">Respondamos juntxs las preguntas de la apertura</h2>
<ul>
<li>Qué son los <strong>paradigmas de programación</strong>?</li>
<li>Qué es el estilo <strong>imperativo</strong></li>
<li>Qué es el estilo <strong>declarativo</strong></li>
<li>Qué paradigmas encajan dentro del estilo <strong>imperativo</strong> y cuales en el
<strong>declarativo</strong></li>
<li>Qué es la <strong>programación por procedimientos</strong>?</li>
<li>Qué es la <strong>programación orientada a objetos</strong>?</li>
<li>Qué es la <strong>programación funcional</strong>?</li>
<li>Cómo se aplican los diferentes paradigmas al mundo de JavaScript?</li>
<li>Cómo se comparan los diferentes paradigmas (diferencias, similitudes, ...)?</li>
<li>Cómo programar en los diferentes estilos</li>
</ul>
",
    "duration": 5,
    "format": "self-paced",
    "title": "Cierre",
    "type": "read",
  },
}
`;
