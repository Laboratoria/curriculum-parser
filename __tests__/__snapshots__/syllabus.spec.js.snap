// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`syllabus should parse syllabus from subdirectories 1`] = `
Object {
  "01-paradigms": Object {
    "00-opening": Object {
      "body": "<h2 id=\\"¿por-qué-aprender-esto\\">¿Por qué aprender esto?</h2>
<p>Como indica el nombre del curso, vamos a hablar de <em>Paradigmas de programación</em>,
que son formas diferentes de pensar en cómo se organiza un programa.</p>
<p>Como desarrollador <strong>Full Stack JS</strong> es esencial entender los distintos
paradigmas de programación y cómo se traducen al mundo real en proyectos de
JavaScript.</p>
<p>Históricamente, el paradigma orientado a objetos (OOP) ha sido el predominante,
pero recientemente, y en particular en la comunidad de JavaScript, hay un
resurgir del paradigma funcional y sus bondades. <strong>JavaScript es un lenguaje de
corazón funcional</strong>, así que conocer el paradigma, y cómo se compara a la
programación orientada a objetos, no sólo te hará una mejor coder, si no que
podrás entender cómo se pueden enfrentar los mismos problemas con enfoques
distintos, e identificar y adaptarse a bases de código existentes.</p>
<p>En este curso nos concentraremos en los paradigmas más relevantes para
JavaScript y cómo se materializan en este contexto.</p>
<h2 id=\\"guía-de-preguntas-y-conceptos-clave\\">Guía de preguntas y conceptos clave</h2>
<p>Cuando empezamos a estudiar un tema nuevo, es útil tener una idea de los
conceptos más importantes de lo que vamos a aprender y de los temas centrales
que debemos prestar particular atención.</p>
<p>A continuación te presentamos una serie de preguntas que debes ser capaz de
responder al terminar esta unidad. Utiliza estas preguntas como guía para
orientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida
que avanzas para validar que estás avanzando en la dirección correcta. Que te
sirva como un \\"checklist\\" que vas marcando a medida que vas progresando.</p>
<ul>
<li>Qué son los <strong>paradigmas de programación</strong>?</li>
<li>Qué es el estilo <strong>imperativo</strong></li>
<li>Qué es el estilo <strong>declarativo</strong></li>
<li>Qué paradigmas encajan dentro del estilo <strong>imperativo</strong> y cuales en el
<strong>declarativo</strong></li>
<li>Qué es la <strong>programación por procedimientos</strong>?</li>
<li>Qué es la <strong>programación orientada a objetos</strong>?</li>
<li>Qué es la <strong>programación funcional</strong>?</li>
<li>Cómo se aplican los diferentes paradigmas al mundo de JavaScript?</li>
<li>Cómo se comparan los diferentes paradigmas (diferencias, similitudes, ...)?</li>
<li>Cómo programar en los diferentes estilos</li>
</ul>
",
      "duration": 5,
      "format": "self-paced",
      "title": "Apertura",
      "type": "read",
    },
    "01-overview": Object {
      "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/6frz31ykmi?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>Los <strong>Paradigmas de Programación</strong> (<em>Programming Paradigms</em>) son formas
diferentes de pensar en cómo se organiza un programa basado en una serie de
principios, los cuales resultan en estilos muy distintos y lenguajes muy
diversos.</p>
<p>Consideremos la siguiente función:</p>
<pre><code class=\\"language-js\\">function sum(array) {
  var total = 0;
  for (var i = 0; i &lt; array.length; i++) {
    total += array[i];
  }
  return total;
}
</code></pre>
<p>La función <code>sum(array)</code> recibe un array de números y retorna la suma de todos
los elementos del array. Para llevar a cabo la suma, usamos la variable <code>total</code>,
la cual vamos a ir actualizando (mutando) mientras vamos recorriendo el arreglo
con un bucle (<code>for</code> en este caso). Estas características son típicas del estilo
imperativo.</p>
<p>Ahora, podemos implementar exactamente la misma funcionalidad usando un enfoque
completamente distinto.</p>
<pre><code class=\\"language-js\\">function sum(array) {
  if (!array.length) {
    return 0;
  }
  return array[0] + sum(array.slice(1));
};
</code></pre>
<p>En esta segunda implementación, la función <code>sum(array)</code> sigue teniendo la misma
interfaz (recibe los mismos argumentos y retorna lo mismo), pero claramente
podemos ver que la lógica se expresa de una manera muy diferente. En la versión
recursiva hemos reemplazado el bucle <code>for</code> por recursión, y además podemos ver
que no hay asignación ni mutación de variables, el \\"cómputo\\" se hace por
aplicación de argumentos a funciones. Este tipo de características son propias
del paradigma funcional.</p>
<hr>
<p>PRO TIP:</p>
<p>Haciendo uso de ES2015 podemos refactorizar la versión funcional de <code>sum</code> de
esta manera:</p>
<pre><code class=\\"language-js\\">const sum = array =&gt; !array.length ? 0 : array[0] + sum(array.slice(1));
</code></pre>
<hr>
<p>Cuando hablamos de <strong>Paradigmas de Programación</strong> inevitablemente tenemos que
hablar de lenguajes de programación. Algunos lenguajes, como JavaScript, son
<em>multi-paradigma</em>, lo que quiere decir que nos permiten programar en diferentes
paradigmas, mientras que otros se enfocan específicamente en uno.</p>
<p><strong>JavaScript</strong> es un leguage <em>híbrido</em>, por decirlo de alguna forma, y contiene
elementos propios de lenguajes funcionales (por ejemplo funciones como objetos
de primera clase, lambdas, ...) pero no estamos limitados al paradigma
funcional. <strong>JavaScript nos permite programar de forma <em>funcional</em>, <em>orientado a
objetos</em>, <em>orientado a eventos</em>, <em>por procedimientos</em>, ...</strong></p>
<p>También veremos que los \\"paradigmas\\" son \\"estilos\\" de programación que no son
necesariamente exclusivos. De hecho, algunos son complementarios o evoluciones
de paradigmas más antiguos o con un nivel de abstracción más bajo. Así, la
programación procedural y orientada a objetos, por ejemplo, ambas son
imperativas, ya que comparten una raíz común.</p>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Blog posts:</p>
<ul>
<li><a href=\\"http://www.ybrikman.com/writing/2014/04/09/six-programming-paradigms-that-will/\\" target=\\"_blank\\">Six programming paradigms that will change how you think about coding</a>,
Yevgeniy Brikman, Apr 09 2014</li>
</ul>
<p>Videos:</p>
<ul>
<li><div class=\\"iframe-container\\"><iframe width=\\"640\\" height=\\"360\\" src=\\"https://www.youtube.com/embed/sqV3pL5x8PI?autoplay=0\\" frameborder=\\"0\\" gesture=\\"media\\" allow=\\"encrypted-media\\" allowfullscreen=\\"true\\"></iframe></div>,
<code>10:43</code>, <a href=\\"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\\" target=\\"_blank\\">Computerphile</a>,
30 Aug 2013</li>
<li><div class=\\"iframe-container\\"><iframe width=\\"640\\" height=\\"360\\" src=\\"https://www.youtube.com/embed/4A2mWqLUpzw?autoplay=0\\" frameborder=\\"0\\" gesture=\\"media\\" allow=\\"encrypted-media\\" allowfullscreen=\\"true\\"></iframe></div>,
<code>8:27</code>, <a href=\\"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\\" target=\\"_blank\\">Computerphile</a>,
Jun 28 2016</li>
<li><a href=\\"https://www.video2brain.com/mx/tutorial/que-es-un-paradigma-de-programacion\\" target=\\"_blank\\">Qué es un paradigma de programación</a>,
<code>5:15</code>, José Dimas Luján Castillo, <a href=\\"https://www.video2brain.com/\\" target=\\"_blank\\">video2brain</a>,
8 Mar 2017</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://en.wikipedia.org/wiki/Programming_paradigm\\" target=\\"_blank\\">Definición de Programming_paradigm en Wikipedia</a></li>
<li><a href=\\"https://en.wikipedia.org/wiki/Comparison_of_programming_paradigms\\" target=\\"_blank\\">Comparativa de paradigmas de programación en Wikipedia</a></li>
</ul>
",
      "duration": 5,
      "embeds": Array [
        Object {
          "href": "https://laboratoria.wistia.com/medias/6frz31ykmi?wvideo=6frz31ykmi",
          "id": "6frz31ykmi",
          "provider": "wistia",
          "type": "video",
        },
        Object {
          "href": "https://www.youtube.com/watch?v=sqV3pL5x8PI",
          "id": "sqV3pL5x8PI",
          "provider": "youtube",
          "type": "video",
        },
        Object {
          "href": "https://www.youtube.com/watch?v=4A2mWqLUpzw",
          "id": "4A2mWqLUpzw",
          "provider": "youtube",
          "type": "video",
        },
      ],
      "format": "self-paced",
      "title": "¿Qué son los paradigmas de programación?",
      "type": "read",
    },
    "02-history": Object {
      "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/an9covln5w?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>Para tener una idea general de los paradigmas y sus peculiaridades, es útil
repasar brevemente su historia.</p>
<p>El primer paradigma en aparecer, primera mitad de los años 50, es el
<strong>imperativo</strong>, que se caracteriza por un nivel bajo de abstracción. Por lo
tanto el código está enfocado en las instrucciones que la computadora debe
seguir, y no necesariamente en la semántica o lógica de la funcionalidad que
estamos implementando (el cómo nosotros pensamos en lo que hace el programa).</p>
<p>Veamos un ejemplo de <code>Assembly</code>, el primer lenguaje \\"moderno\\", que apareció en
el año 1949, y que sigue vivo a día de hoy, eso sí, para cosas muy específicas,
que nos son necesariamente lo que vemos los desarrolladores web, pero que sirve
para este ejemplo ;-)</p>
<pre><code class=\\"language-assembly_x86\\">section .text             ;section declaration

                          ;we must export the entry point to the ELF linker or
  global  _start          ;loader. They conventionally recognize _start as their
                          ;entry point. Use ld -e foo to override the default.

_start:

                          ;write our string to stdout

  mov     edx,len         ;third argument: message length
  mov     ecx,msg         ;second argument: pointer to message to write
  mov     ebx,1           ;first argument: file handle (stdout)
  mov     eax,4           ;system call number (sys_write)
  int     0x80            ;call kernel

                          ;and exit

  mov     ebx,0           ;first syscall argument: exit code
  mov     eax,1           ;system call number (sys_exit)
  int     0x80            ;call kernel

section .data             ;section declaration

msg db    \\"Hello, world!\\",0xa    ;our dear string
len equ   $ - msg                ;length of our dear string
</code></pre>
<p><a href=\\"http://www.tldp.org/HOWTO/Assembly-HOWTO/hello.html\\" target=\\"_blank\\">Fuente: Assembly-HOWTO</a></p>
<p>El snippet de arriba es un \\"hello world\\" escrito en <code>Assembly</code> (una versión
moderna, pero muy parecido a lo que hubieras visto en los años 50). Lo único que
hace este programa es imprimir el string <code>Hello, world!</code>. El equivalente a todo
el código de arriba en JavaScript sería:</p>
<pre><code class=\\"language-js\\">console.log('Hello, world!');
</code></pre>
<p>En nuestro caso, JavaScript tiene un nivel de abstracción mucho más alto. Con lo
cual, no tenemos que preocuparnos de muchos detalles que JavaScript ya abstrae
para nosotros, como manejo de memoria, instrucciones del procesador, etc. Esto
nos permite expresar de forma más \\"humana\\" la intención de nuestro programa, y
con mucho menos código.</p>
<p>Regresamos a los años 50. Según la programación va evolucionando, y los
programas creciendo, vemos cómo van a ir surgiendo diferentes formas de
\\"abstraer\\", \\"organizar\\" y \\"reusar\\" el código. A finales de los años 50 vemos
como aparecen <strong>Fortran II</strong> y <strong>Lisp</strong>, introduciendo la programación
<strong>procedural</strong> y <strong>funcional</strong>. Con ambos enfoques pasamos a nuevos nieveles de
abstracción y mejora en el reuso de código.</p>
<p>En los años 70 y 80 se da el boom de la programación orientada a objetos,
primero con <strong>Smalltalk</strong> y después <strong>C++</strong>.</p>
<p><strong>JavaScript</strong> nace en 1995, el mismo año que <strong>Java</strong>, <strong>Ruby</strong> y <strong>PHP</strong>. La
década de los 90 se caracteriza por los lenguajes multi-paradigma. En ese
contexto JavaScript destaca por su dinamismo y su naturaleza funcional. De hecho
a nivel conceptual, JavaScript está fuertemente inspirado por <strong>Scheme</strong>, que es
un lenguaje funcional, y los prototipos de <strong>Self</strong>, aunque por necesidades del
mercado, la sintáxis se parece más a la familia de lenguajes de <strong>C</strong> y
<strong>Java</strong>, que son imperativos. Por esta razón, JavaScript se considera muchas
veces <a href=\\"http://javascript.crockford.com/javascript.html\\" target=\\"_blank\\">el lenguaje más
incomprendido</a>, y quizás
confuso.</p>
<p>Como referencia, abajo podemos ver una tabla con algunos de los lenguajes más
significativos a nivel de cambios de paradigma, y el conexto en el que aparece
JavaScript.</p>
<table>
<thead>
<tr>
<th>Año</th>
<th>Lenguaje</th>
<th>Paradigma</th>
</tr>
</thead>
<tbody><tr>
<td>1949</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Assembly_language\\" target=\\"_blank\\">Assembly</a></td>
<td>imperativo</td>
</tr>
<tr>
<td>1957</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Fortran\\" target=\\"_blank\\">Fortran</a></td>
<td>imperativo</td>
</tr>
<tr>
<td>1958</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Fortran#FORTRAN_II\\" target=\\"_blank\\">Fortran II</a></td>
<td>imperativo, procedural</td>
</tr>
<tr>
<td>1958</td>
<td><a href=\\"https://goo.gl/ZbUXeg\\" target=\\"_blank\\">Lisp</a></td>
<td>funcional</td>
</tr>
<tr>
<td>1965</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Simula\\" target=\\"_blank\\">Simula</a></td>
<td>orientado a objetos</td>
</tr>
<tr>
<td>1972</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Smalltalk\\" target=\\"_blank\\">Smalltalk</a></td>
<td>orientado a objetos</td>
</tr>
<tr>
<td>1972</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Prolog\\" target=\\"_blank\\">Prolog</a></td>
<td>lógico</td>
</tr>
<tr>
<td>1972</td>
<td><a href=\\"https://goo.gl/4bnEHY\\" target=\\"_blank\\">C</a></td>
<td>imperativo, procedural, estructurado</td>
</tr>
<tr>
<td>1975</td>
<td><a href=\\"https://goo.gl/x2WMht\\" target=\\"_blank\\">Scheme</a></td>
<td>funcional</td>
</tr>
<tr>
<td>1983</td>
<td><a href=\\"https://en.wikipedia.org/wiki/C%2B%2B\\" target=\\"_blank\\">C++</a></td>
<td>imperativo, procedural, estructurado, orientado a objetos</td>
</tr>
<tr>
<td>1987</td>
<td><a href=\\"https://en.wikipedia.org/wiki/Perl\\" target=\\"_blank\\">Perl</a></td>
<td>imperativo, procedural, funcional, orientado a objetos, orientado a eventos</td>
</tr>
<tr>
<td>1991</td>
<td><a href=\\"https://goo.gl/bJ9Wcg\\" target=\\"_blank\\">Python</a></td>
<td>imperativo, procedural, funcional, orientado a objetos</td>
</tr>
<tr>
<td>1995</td>
<td><a href=\\"https://goo.gl/PhfLjJ\\" target=\\"_blank\\">Ruby</a></td>
<td>imperativo, funcional, orientado a objetos</td>
</tr>
<tr>
<td>1995</td>
<td><a href=\\"https://goo.gl/aWjoSR\\" target=\\"_blank\\">Java</a></td>
<td>imperativo, orientado a objetos</td>
</tr>
<tr>
<td>1995</td>
<td><a href=\\"https://en.wikipedia.org/wiki/PHP\\" target=\\"_blank\\">PHP</a></td>
<td>imperativo, procedural, orientado a objetos</td>
</tr>
<tr>
<td>1995</td>
<td><a href=\\"https://en.wikipedia.org/wiki/JavaScript\\" target=\\"_blank\\">JavaScript</a></td>
<td>imperativo, funcional, orientado a objetos, orientado a eventos</td>
</tr>
</tbody></table>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://en.wikipedia.org/wiki/History_of_programming_languages\\" target=\\"_blank\\">History of programming languages</a></li>
</ul>
",
      "duration": 5,
      "embeds": Array [
        Object {
          "href": "https://laboratoria.wistia.com/medias/an9covln5w?wvideo=an9covln5w",
          "id": "an9covln5w",
          "provider": "wistia",
          "type": "video",
        },
      ],
      "format": "self-paced",
      "title": "Historia",
      "type": "read",
    },
    "03-declarative-vs-imperative": Object {
      "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/ty5mr7p77t?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>Hemos mencionado que los primeros lenguajes de programación eran imperativos, y
que se centraban en el \\"cómo\\" más que en el \\"qué\\". Como contrapartida, el estilo
declarativo se caracteriza por lo contrario, enfocarse más en \\"qué\\" queremos
hacer, desde el punto de vista de un ser humano, en vez de cómo lo debe ejecutar
la computadora. Por ende, cuanto más declarativo, más alejado del hardware.</p>
<p>Algunos paradigmas son más imperativos y otros más declarativos. Por ejemplo,
la programación orientada a procedimientos, o la programación orientada objetos,
van a tener un caracter imperativo, mientras que la programación funcional tiene
un caracter mucho más declarativo.</p>
<p>Imáginemos que tenemos la siguiente data en un array de objetos:</p>
<pre><code class=\\"language-js\\">var array = [
  {id: 'uno', name: 'el primero'},
  {id: 'dos', name: 'el segundo'},
  {name: 'no tengo id'}
];
</code></pre>
<p>A partir de esta data, ahora nos piden extraer los <code>id</code> de cada un de los
objetos y amacenarlos en un nuevo arreglo (<code>ids</code>). Si nos planteamos el
problema desde un enfoque imperativo, podríamos implementar una solución así:</p>
<pre><code class=\\"language-js\\">const ids = [];

for (var i = 0; i &lt; array.length; i++) {
  if (array[i].id) {
    ids.push(array[i].id);
  }
}

console.log(ids); // ['uno', 'dos']
</code></pre>
<p>En el código anterior, probablemente puedas identificar claramente el estilo
imperativo. Las variables como \\"contadores\\" y \\"acumuladores\\", son típicos del
estilo imperativo. En este estilo el principal mecanismo de cómputo se lleva a
cabo a través de la asignación de valores en variables. Veremos así uso de
variables globales y mutación de los valores asignados a variables a través del
tiempo.</p>
<p>JavaScript nos ofrece utilidades para afrontar este tipo problemas desde el
enfoque funcional. Así, los arrays (gracias a <code>Array.prototype</code>) tienen una
serie de métodos para manipular su data a través de \\"higher order functions\\",
que en este caso son funciones que aceptan otra función como argumento, como por
ejemplo <code>Array.prototype.filter</code> o <code>Array.prototype.map</code>. Veamos cómo podemos
usar estas herramientas para implementar la misma lógica:</p>
<pre><code class=\\"language-js\\">const ids = array
  .filter(item =&gt; typeof item.id === 'string')
  .map(item =&gt; item.id);

console.log(ids); // ['uno', 'dos']
</code></pre>
<p>En esta nueva versión hacemos lo siguiente:</p>
<ol>
<li>Usamos <code>Array#filter</code> para crear un nuevo arreglo sólo con aquellos elementos
que tengan un <code>id</code> que sea un string (<code>typeof item.id === 'string'</code>).</li>
<li>Usamos <code>Array#map</code> para transformar cada elemento del arreglo y crear un
nuevo arreglo con los resultados.</li>
</ol>
<p>De esta forma los detalles de la iteración quedan escondidos detrás de
<code>Array#filter</code> y <code>Array#map</code>, haciendo nuestro código más declarativo.</p>
<p>También podemos ver cómo \\"encadenamos\\" (method chaining) las invocaciones de
<code>filter</code> y <code>map</code> ya que ambas retornan un array, que a su vez tiene todos los
métodos de <code>Array.prototype</code>.</p>
<p>El estilo declarativo depende de que el lenguaje (o librerías) nos ofrezcan este
tipo de herramientas o abstracciones con las que poder expresar nuestra lógica
sin preocuparnos tanto sobre los detalles de implementación.</p>
<p>Para terminar esta sección, cabe mencionar que HTML es un lenguaje declarativo!
Muchos se quejarían diciendo que HTML no es un lenguaje de programación, sino un
lenguaje de marcado (<em>markup language</em>). Pero podemos considerear a HTML como un
lenguaje declarativo muy restringido, no de uso general, donde sólo podemos
crear un árbol de nodos a partir de una estructura de etiquetas (<em>tags</em>) con una
sintáxis y semántica predefinida. Es declarativo en el sentido de que no le
estamos diciendo a la computadora cómo convertir nuestro código en
instrucciones, sino que describimos de formal declarativa lo que queremos que
ocurra (el compilador o intérprete se encarga del resto).</p>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Videos:</p>
<ul>
<li><div class=\\"iframe-container\\"><iframe width=\\"640\\" height=\\"360\\" src=\\"https://www.youtube.com/embed/4A2mWqLUpzw?autoplay=0\\" frameborder=\\"0\\" gesture=\\"media\\" allow=\\"encrypted-media\\" allowfullscreen=\\"true\\"></iframe></div>,
<code>8:27</code>, <a href=\\"https://www.youtube.com/channel/UC9-y-6csu5WGm29I7JiwpnA\\" target=\\"_blank\\">Computerphile</a>,
Jun 28 2016</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://en.wikipedia.org/wiki/Imperative_programming\\" target=\\"_blank\\">Imperative programming</a></li>
<li><a href=\\"https://en.wikipedia.org/wiki/Declarative_programming\\" target=\\"_blank\\">Declarative programming</a></li>
</ul>
",
      "duration": 15,
      "embeds": Array [
        Object {
          "href": "https://laboratoria.wistia.com/medias/ty5mr7p77t?wvideo=ty5mr7p77t",
          "id": "ty5mr7p77t",
          "provider": "wistia",
          "type": "video",
        },
        Object {
          "href": "https://www.youtube.com/watch?v=4A2mWqLUpzw",
          "id": "4A2mWqLUpzw",
          "provider": "youtube",
          "type": "video",
        },
      ],
      "format": "self-paced",
      "title": "Declarativo vs Imperativo",
      "type": "read",
    },
    "04-imperative-exercise": Object {
      "duration": 5,
      "exercises": Object {
        "01-print-primes": Object {
          "body": "<p>La programación imperativa tiene un nivel de abstracción bajo, lo que quiere
decir que se enfoca en describir, desde el punto de vista de la computadora,
cómo hacer lo que queremos. Nuestro código expresa de forma explícita el control
de flujo, usando bucles, declara variables para llevar la cuenta, ...</p>
<p>En el mundo real, en un lenguaje como JavaScript, vamos a encontrar
características de este paradigma, pero siempre en el contexto de otro paradigma
con un nivel de abtracción más alto y un mecanismo de reuso de código (cómo la
programación orientada a objetos o la prgramación funcional).</p>
<h2 id=\\"tarea\\">Tarea</h2>
<p>El <em>boilerplate</em> (la plantilla sobre la que hacer el ejercicio) contiene un
programa sin terminar. Este programa debe <strong>imprimir en la consola todos los
números primos menores que <code>20</code></strong>.</p>
<p>El <em>boilerplate</em> impementa sólo parte de la lógica. Por el momento imprime todos
los números enteros del <code>2</code> al <code>19</code>. Ahora tienes que añadir la lógica para
comprobar si un número es primo o no, y así sólo imprimir los primos.</p>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li>Debes implementar un bucle <code>for</code> anidado dentro del <code>for</code> ya existente.</li>
</ul>
<h2 id=\\"pistas\\">Pistas</h2>
<ul>
<li>Si un número es divisible por cualquier entero mayor que <code>1</code> que no sea el
número mismo, sabemos que NO es primo.</li>
<li>Dentro del bucle <code>for</code> principal, para ver si un número es primo, vamos a
tratar de demostrar que NO es primo, y si no podemos probar que no es primo,
entonces podemos asumir que sí es primo.</li>
<li>El operador <code>%</code> nos da el residuo de una división.</li>
<li>Una vez que hemos probado que un número no es primo ya no necesitamos
continuar dividiéndolo.</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://goo.gl/zn7cTu\\" target=\\"_blank\\">Arithmetic Operators: Remainder - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for\\" target=\\"_blank\\">Statements: for - MDN</a></li>
</ul>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "cHJpbnRQcmltZXMuanM=": "function printPrimes() {
  // Iteramos desde 2 (el primer número primo) hasta 19 (menor que 20)
  for (var i = 2; i < 20; i++) {
    var isPrime = true;

    // Ahora debemos iterar desde \`2\` hasta \`i / 2\` usando una variable \`j\` como
    // contador.
    //
    // Para cada \`j\` comprueba si la división \`i / j\` deja un residuo.
    //
    // NOTA: No necesitamos probar números más allá de \`i / 2\` porque el
    // resultado de la división \`i / j\` siempre sería una fracción entre 2 y 1,
    // siempre dejando residuo.

    // TU CÓDIGO AQUÍ

    if (isPrime) {
      console.log(i);
    }
  }
}

module.exports = printPrimes;
",
            },
            "c29sdXRpb24=": Object {
              "cHJpbnRQcmltZXMuanM=": "function printPrimes() {
  for (var i = 2; i < 20; i++) {
    var isPrime = true;
    for (var j = 2; j <= (i / 2); j++) {
      if (i % j === 0) {
        isPrime = false;
        break;
      }
    }
    if (isPrime) {
      console.log(i);
    }
  }
}

module.exports = printPrimes;
",
            },
            "dGVzdA==": Object {
              "cHJpbnRQcmltZXMuc3BlYy5qcw==": "'use strict';


const Assert = require('chai').assert;
const Sinon = require('sinon');
const Submission = require('../solution/printPrimes');


describe('printPrimes()', () => {

  const stub = Sinon.stub(console, 'log');
  Submission();
  stub.restore();

  it('debería exportar una función', () => {
    Assert.equal(typeof Submission, 'function');
  });

  it('debería invocar console.log 8 veces', () => {
    Assert.equal(stub.callCount, 8);
  });

  [[2], [3], [5], [7], [11], [13], [17], [19]].forEach((args, idx) => {
    it(\`invocación \${idx + 1} a console.log debería recibir \\"\${args[0]}\\" como único argumento\`, () => {
      Assert.deepEqual(args, stub.getCall(idx).args);
    });
  });

});
",
            },
          },
          "title": "Imprime los número enteros menores que 20",
        },
      },
      "format": "self-paced",
      "title": "Ejercicio imperativo",
      "type": "practice",
    },
    "05-procedural": Object {
      "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/el19ibmhpj?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>La programación por procedimientos (<em>procedural programming</em>) pertenece a la
rama del estilo <em>imperativo</em>. Antes mencionamos que a finales de los años 50
Fortran II introduce la programación por procedimientos, y de esa forma
empezamos a \\"organizar\\", \\"abstraer\\" y \\"reusar\\" nuestro código.</p>
<p>Cuando programamos orientados a procedimientos, lo cual puede ser un enfoque
válido para ciertos programas o scripts, nos concentramos en agrupar código
en procedimientos o funciones, e invocar estos procedimientos con diferentes
argumentos o parámetros. En este sentido es parecido a la programación
funcional, pero con la diferencia de que nos mantenemos en la rama imperativa,
describiendo acciones como pasos secuenciales, que podrían tener efectos
secundarios y donde el output no está necesariamente deterinado por los
argumentos de entrada. Mientras que la programación funcional es más abstracta,
se basa en funciones puras sin efectos secundarios, evitar el estado compartido,
y otros principios específicos de la programación funcional.</p>
<p>Refactoricemos el ejemplo anterior donde sacábamos la propiedad <code>id</code> de una
lista de objetos. Empecemos por envolver el código en una función:</p>
<pre><code class=\\"language-js\\">function getIds(inputArray) {
  const ids = [];

  for (var i = 0; i &lt; inputArray.length; i++) {
    if (inputArray[i].id) {
      ids.push(inputArray[i].id);
    }
  }

  return ids;
}

console.log(getIds(array)); // ['uno', 'dos']
</code></pre>
<p>Este cambio parece menor, pero añade una capa de abstracción que nos da un
montón de flexibilidad. Ahora nuestro código está <em>encapsulado</em> dentro de su
propio <em>scope</em> y podemos reusar la lógica para otros arrays (podemos invocar la
función cuantas veces queramos).</p>
<p>Pero vayamos un paso más allá. Ahora que estamos ordenando nuestro código usando
funciones, aprovechemos a abstraer y mejorar la comprobación que hacíamos para
saber si un objeto tiene una propiedad <code>id</code>.</p>
<pre><code class=\\"language-js\\">function hasId(obj) {
  return obj &amp;&amp; typeof obj.id === 'string';
}

function getIds(inputArray) {
  const ids = [];

  for (var i = 0; i &lt; inputArray.length; i++) {
    if (hasId(inputArray[i])) {
      ids.push(inputArray[i].id);
    }
  }

  return ids;
}

console.log(getIds(array)); // ['uno', 'dos']
console.log(hasId()); // false
console.log(hasId({name: 'foo'})); // false
console.log(hasId({id: 'uno'})); // true
</code></pre>
<p>En esta nueva versión hemos partido el código en dos funciones, y al hacerlo
hemos tenido que dar nombres a estas funciones. Estos nombres representan de
alguna forma esa capa de abstracción. Ahora podemos hablar de <code>hasId()</code>
cuando queremos referirnos a ese pedacito de lógica. Así, poco a poco vamos
creando una semántica que nos permite alejarnos de los detalles de
implementación.</p>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://en.wikipedia.org/wiki/Procedural_programming\\" target=\\"_blank\\">Procedural programming</a></li>
</ul>
",
      "duration": 6,
      "embeds": Array [
        Object {
          "href": "https://laboratoria.wistia.com/medias/el19ibmhpj?wvideo=el19ibmhpj",
          "id": "el19ibmhpj",
          "provider": "wistia",
          "type": "video",
        },
      ],
      "format": "self-paced",
      "title": "Programación por procedimientos",
      "type": "read",
    },
    "06-modules": Object {
      "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/ph5zkst0fv?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>Una de las consecuencias de estos cambios es el concepto de \\"modularidad\\". Esto
va a permitir que empecemos a escribir programas estructurados en módulos
independientes, que son más fáciles de entender, testear, mantener, ...</p>
<p>En JavaScript existen varios sistemas de módulos, principalmente <strong>AMD</strong>,
<strong>Common JS</strong> y <strong>ES2015/ES6</strong>. Para este ejemplo vamos a concentrarnos en
<strong>Common JS</strong>, que es el que usa <strong>Node.js</strong>, y que también podemos usar en el
navegador gracias a los <em>bundlers</em>. En nuestro ejemplo, ahora que nuestro código
vive dentro de una función, podríamos <em>exportar</em> la función, lo que nos
permitiría usar esta función desde otros scripts u otros programas. Esto es
esencial para casi cuaquier programa o script hoy en día, con consecuencias que
damos por sentado como poder organizar nuestro código en archivos y carpetas
diferentes o tener dependecias de módulos externos.</p>
<p>Para exportar nuestra función <code>getIds</code> usando Common JS en Node.js, podemos
simplemente asignar nuestra función a <code>module.exports</code>.</p>
<pre><code class=\\"language-js\\">// al final del script
module.exports = getIds;
</code></pre>
<p>El objeto <code>module</code> es una variable local a cada script en Common JS. Si
asignamos algo a <code>module.exports</code>, éste será el valor que recibiremos cuando
requiramos nuestro \\"módulo\\". Por ejemplo, imaginemos que salvamos el script en
el archivo <code>src/getIds.js</code>, y ahora lo queremos usar desde otro script afuera de
<code>src/</code>:</p>
<pre><code class=\\"language-js\\">const getIds = require('./src/getIds');
// \`getIds\` tiene el valor que hemos exportado a través de \`module.exports\`
// en el script \`src/getIds.js\`
</code></pre>
<p>Common JS también nos ofrece la opción de exportar los valores que queramos
como propiedades del objeto <code>exports</code> (que es un alias de <code>module.exports</code>). Así
en vez de exportar sólo un valor (la función <code>getids</code>), podemos exporar varios
valores.</p>
<pre><code class=\\"language-js\\">exports.getIds = getIds;
exports.hasId = hasId;
</code></pre>
<p>Ahora cuando requerimos nuestro módulo desde otro script lo que recibimos es
un objeto (el objeto <code>exports</code>), que tiene dos propiedades, <code>getIds</code> y <code>hasId</code>.</p>
<pre><code class=\\"language-js\\">const myModule = require('./src/myModule');
// myModule.getIds()
// myModule.hasId()
</code></pre>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Blog posts:</p>
<ul>
<li><a href=\\"http://2ality.com/2014/09/es6-modules-final.html\\" target=\\"_blank\\">ECMAScript 6 modules: the final syntax</a>,
Axel Rauschmayer, 07 Sep 2014</li>
<li><a href=\\"https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc\\" target=\\"_blank\\">JavaScript Modules: A Beginner’s Guide</a>,
Preethi Kasireddy (FreeCodeCamp), Jan 22 2016</li>
</ul>
",
      "duration": 6,
      "embeds": Array [
        Object {
          "href": "https://laboratoria.wistia.com/medias/ph5zkst0fv?wvideo=ph5zkst0fv",
          "id": "ph5zkst0fv",
          "provider": "wistia",
          "type": "video",
        },
      ],
      "format": "self-paced",
      "title": "Modularidad",
      "type": "read",
    },
    "07-procedural-exercise": Object {
      "duration": 10,
      "exercises": Object {
        "01-get-primes": Object {
          "body": "<p>La programación <em>procedural</em> (por procedimientos) introduce el concepto de
procedimientos o funciones que nos permiten agrupar instrucciones, y así reusar
bloques de código e invocarlos con diferentes valores.</p>
<p>Según va creciendo un programa, vamos a tener la necesidad de organizar nuestro
código en pedacitos comprensibles, además de abstraer repetición. La
programación por procedimientos representa un primer paso de abstracción, lo que
nos obliga a tener que dar nombres a estos procedimientos, encapsularlos, y
definir sus interfaces (input/output).</p>
<h2 id=\\"tarea\\">Tarea</h2>
<p>Refactoriza el código que vimos en el ejercicio anterior en dos funciones:</p>
<ul>
<li><code>getPrimes(start, end)</code></li>
<li><code>isPrime(num)</code></li>
</ul>
<p>Ya hemos envuelto el código en una función con el nombre <code>getPrimes</code>.</p>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li>La función <code>getPrimes()</code> recibe dos argumentos: <code>start</code> y <code>end</code>, que nos deben
permitir especificar el rango de números primos que nos interesa.</li>
<li>La función <code>getPrimes()</code> debe retornar un <code>array</code> con los números primos en
vez de imprimirlos en la consola. Para ello usa una variable donde ir gurdando
los números primos que vayamos encontrando y al final de la función devuelve
(retorna) ese array.</li>
<li>En el bucle de <code>getPrimes()</code>, tendrás que sustituir el valor inicial de <code>i</code>
por <code>start</code> y la condición por <code>i &lt; end</code>.</li>
<li>Dentro del bucle de <code>getPrimes()</code> ya no necesitamos la variable <code>isPrime</code>,
ahora debes invocar a la función <code>isPrime()</code> para determinar si el número en
cuestión es primo.</li>
<li>El bucle que en el ejercicio anterior usamos para comprobar si un número es
primo, ahora debe quedar dentro de <code>isPrime()</code>, la cual sólo ha de recibir un
argumento (el número a comprobar) y retornar un booleano (<code>true</code> o <code>false</code>).</li>
<li>Asegúrate de que tu script exporta las funciones <code>getPrimes()</code> e <code>isPrime()</code>.</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions\\" target=\\"_blank\\">Functions - MDN</a></li>
<li><a href=\\"https://nodejs.org/api/modules.html#modules_the_module_object\\" target=\\"_blank\\">The module object - Node.js Docs</a></li>
</ul>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "Z2V0UHJpbWVzLmpz": "function isPrime(num) {
  //...
}

function getPrimes(start, end) {
  for (var i = 2; i < 20; i++) {
    var isPrime = true;

    //...

    if (isPrime) {
      console.log(i);
    }
  }
}
",
            },
            "c29sdXRpb24=": Object {
              "Z2V0UHJpbWVzLmpz": "function isPrime(num) {
  for (var i = 2; i <= (num / 2); i++) {
    if (num % i == 0) {
      return false;
    }
  }
  return true;
}

function getPrimes(start, end) {
  var primes = [];
  for (var i = start; i < end; i++) {
    if (isPrime(i)) {
      primes.push(i);
    }
  }
  return primes;
}

exports.getPrimes = getPrimes;
exports.isPrime = isPrime;
",
            },
            "dGVzdA==": Object {
              "Z2V0UHJpbWVzLnNwZWMuanM=": "'use strict';


const Assert = require('chai').assert;
const Submission = require('../solution/getPrimes');


describe('getPrimes(start, end)', () => {

  it('debería exportar función \`getPrimes\`', () => {
    Assert.equal(typeof Submission.getPrimes, 'function');
  });

  it('debería retornar los número primos menores de 20', () => {
    Assert.deepEqual(Submission.getPrimes(2, 20), [2, 3, 5, 7, 11, 13, 17, 19]);
  });

  it('debería retornar los número primos entre 50 y 100', () => {
    Assert.deepEqual(Submission.getPrimes(50, 100), [53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
  });

});


describe('isPrime(num)', () => {

  it('debería exportar función \`isPrime\`', () => {
    Assert.equal(typeof Submission.isPrime, 'function');
  });

  it('debería retornar true para 2, 3, 5, 13, 89', () => {
    [2, 3, 5, 13, 89].forEach(n => Assert.deepEqual(Submission.isPrime(n), true));
  });

  it('debería retornar false para ', () => {
    [4, 10, 99, 411].forEach(n => Assert.deepEqual(Submission.isPrime(n), false));
  });

  it('debería retornar los número primos entre 50 y 100', () => {
    Assert.deepEqual(Submission.getPrimes(50, 100), [53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
  });

});
",
            },
          },
          "title": "getPrimes()",
        },
      },
      "format": "self-paced",
      "title": "Ejercicio por procedimientos",
      "type": "practice",
    },
    "08-oop": Object {
      "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/8id6wdxrdn?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>La <strong>Programación Orientada a Objetos</strong> (<em>Object Oriented Programming</em> - OOP)
representa un cambio de paradigma bastante grande con respecto al paradigma por
procedimientos que acabamos de ver. Cuando programamos por procedimientos nos
concentramos en funciones, que representan acciones, y así nuestra semántica
está orientada a acciones antes que a estructuras de datos.</p>
<p>En la programación orientada a objetos le damos la vuelta a la tortilla, y en
vez de pensar en acciones nos enfocamos en definir los \\"tipos\\" de datos primero,
y después decidimos que interacciones van a tener. En OOP diseñamos objetos, que
van a tener una data (un estado) y una serie de operaciones que pueden realizar.</p>
<p>A la hora de construir aplicaciones nos vemos obligados a pensar en cómo
\\"modelar\\" o representar en código cosas del mundo real o conceptos útiles para
un ser humano (un usuario, un documento, ...) y la programación orientada a
objetos propone crear tipos de objetos para representar estas cosas.</p>
<p>Imaginemos que tenemos que escribir una aplicación de \\"notas\\" donde el usuario
puede crear diferentes tipos de \\"notas\\", marcarlas como completadas, ... Si
vamos a seguir el estilo orientado a objetos, normalmente empezaríamos por
modelar el \\"tipo de objeto\\" que con el que vamos a representar una \\"nota\\".
Podríamos empezar con algo así:</p>
<pre><code class=\\"language-js\\">function Note(text) {
  this.text = text || '';
  this.createdAt = new Date();
  this.completed = false;
}
</code></pre>
<p>Hemos declarado una función (<code>Note</code>) que hace uso de una <em>pseudo variable</em>
llamada <code>this</code>. La presencia de <code>this</code>, junto con la convención de usar la
primera letra en mayúscula, nos indican que esta función está escrita
para ser invocada con el <em>keyword</em> <code>new</code>. Este tipo de función es lo que
conocemos como un <em>constructor</em>. Los constructores son funciones cuyo propósito
es crear un objeto, inicializarlo y ofrecernos una manera de especificar el
prototipo que tendrán los objetos creados con este constructor. Dicho de otra
manera, menos correcta pero más común, los constructores son lo más parecido a
clases en JavaScript (por lo menos hasta ES6).</p>
<p>JavaScript es un lenguaje dinámicamente tipado (<em>dynamically typed</em>), pero a
diferencia de la mayoría de lenguajes de su generación, usa herencia prototipal
en vez de clases, lo cual suele confundir a muchos programadores con experiencia
en otros lenguajes orientados a objetos.</p>
<p>Cuando invocamos un constructor precedido de <code>new</code>, la pseudo-variable <code>this</code> es
una referencia al nuevo objeto creado al invocar el constructor. Creemos un
objeto para ver que significa todo esto:</p>
<pre><code class=\\"language-js\\">const note = new Note('comprar arroz');
console.log(note);
</code></pre>
<p>En la consola deberías de ver algo así:</p>
<pre><code class=\\"language-text\\">Note {
  text: 'comprar arroz',
  createdAt: 2017-06-14T22:39:51.987Z,
  completed: false }
</code></pre>
<p>Podemos ver que <code>note</code> es un objeto con tres propiedades (<code>text</code>, <code>createdAt</code> y
<code>completed</code>). Estas tres propiedades están declaradas directamente sobre la
instancia.</p>
<p>Cuando usamos constructores, es importante acordarnos de usar <code>new</code> a la hora de
invocarlos, si no, el constructor retornará <code>undefined</code>.</p>
<pre><code class=\\"language-js\\">const note = Note('comprar arroz');
console.log(note); // undefined
</code></pre>
<p>Hemos dicho que una de las características fundamentales de OOP es que empezamos
por definir los tipos de datos (ya sea con clases, constructores, prototipos,
...), lo cual nos permite inspeccionar los objetos creados para saber si son
una instacia de un constructor (con el operador <code>instanceof</code>) o comprobar si un
objeto está en la cadena de prototipos de otro objeto
(<code>Object.prototype.isPrototypeOf</code>).</p>
<pre><code class=\\"language-js\\">console.log(note instanceof Note); // true
console.log(Note.prototype.isPrototypeOf(note)); // true
</code></pre>
<p>Ahora que ya hemos definido un constructor que inicializa una serie de
propiedades, podemos usar el prototipo del constructor (<code>Note.prototype</code>) para
añadir funcionalidad. Todo lo que le añadamos a <code>Note.prototype</code> será parte del
prototipo de los objetos creados por <code>new Note()</code>. Añadamos un método al
prototipo de <code>Note</code>:</p>
<pre><code class=\\"language-js\\">Note.prototype.toString = function () {
  let str = '[' + (this.completed ? 'X' : ' ') + ']';
  str += ' | ' + this.createdAt.toDateString();
  str += ' | ' + this.text;
  return str;
};
</code></pre>
<p>Hemos añadido el método <code>Note.prototype.toString</code>, que simplemente retorna una
representación de nuestro objeto como string. Ahora todos los objetos que
creemos con <code>new Note()</code> deberían de \\"heredar\\" un método <code>toString</code>. Si hacemos
<code>console.log(note)</code> veremos las tres propiedades que seteamos en el constructor,
pero qué pasó con el método <code>toString</code> que le habíamos  añadimo al prototipo de
<code>Note</code>?</p>
<p>Inspeccionemos un poco...</p>
<pre><code class=\\"language-js\\">console.log(note.prototype); // undefined
console.log(note.__proto__); // Note { toString: [Function] }
console.log(note.toString); // [Function]
</code></pre>
<p>El objeto <code>note</code> sí tiene el método <code>toString</code>, pero no directamente sobre la
instancia, si no que está en su prototipo. Cuando tratamos de acceder a una
propiedad que no existe en un objeto, JavaScript va a buscar a ver si hay una
propiedad con ese nombre en el prototipo del objeto, si la encuentra usará esa,
si no buscará en el prototipo del prototipo, y así irá recorriendo lo que
conocemos como la cadena de prototipos (prototype chain).</p>
<p>En la programación orientada a objetos el principal mecanismo de reuso de código
es la \\"herencia\\", donde un objeto \\"hereda\\" una serie de propiedades y métodos
de otro objeto o clase (en herencia prototipal heredamos directamente de un
objeto en vez de una clase).</p>
<p>En la próxima unidad de este curso exploraremos los detalles de cómo implementar
jerarquías de herencia usando prototipos. Por el momento nos quedamos con estos
conceptos.</p>
<p>Ahora que hemos visto qué es la programación orientada a objetos en el contexto
de JavaScript, concluyamos con una lista de características que definen a OOP de
forma más general, por el propio Alan Kay, creador del término OOP y Smalltalk:</p>
<blockquote>
<p>Traducido al español:</p>
<ul>
<li>Todo es un objeto</li>
<li>Los objetos se comunican enviando y recibiendo mensajes (en términos de objetos)</li>
<li>Los objetos deben tener su propia memoria (en términos de objetos)</li>
<li>Todo objeto es una instancia de una clase (que debe ser un objeto)</li>
<li>La clase tiene el comportamiento compartido para las instancias (como objetos
en un programa)</li>
<li>Para evaluar un programa, se pasa el control al primer objeto y el resto se
trata como su mensaje.</li>
</ul>
<p>Original en inglés:</p>
<ul>
<li>Everything Is An Object</li>
<li>Objects communicate by sending and receiving messages (in terms of objects).</li>
<li>Objects have their own memory (in terms of objects).</li>
<li>Every object is an instance of a class (which must be an object).</li>
<li>The class holds the shared behavior for its instances (in the form of objects
in a program list)</li>
<li>To eval a program list, control is passed to the first object and the
remainder is treated as its message.</li>
</ul>
<p>Fuente <a href=\\"http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented\\" target=\\"_blank\\">Alan Kays Definition Of Object Oriented</a></p>
</blockquote>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Blog posts:</p>
<ul>
<li><a href=\\"https://css-tricks.com/understanding-javascript-constructors/\\" target=\\"_blank\\">Understanding JavaScript Constructors</a>,
Faraz Kelhini, CSS Tricks, Sep 24 2015</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"http://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented\\" target=\\"_blank\\">Alan Kays Definition Of Object Oriented</a></li>
<li><a href=\\"https://en.wikipedia.org/wiki/Object-oriented_programming\\" target=\\"_blank\\">Object-oriented programming</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\\" target=\\"_blank\\">MDN - instanceof</a></li>
</ul>
",
      "duration": 15,
      "embeds": Array [
        Object {
          "href": "https://laboratoria.wistia.com/medias/8id6wdxrdn?wvideo=8id6wdxrdn",
          "id": "8id6wdxrdn",
          "provider": "wistia",
          "type": "video",
        },
      ],
      "format": "self-paced",
      "title": "OOP",
      "type": "read",
    },
    "09-oop-exercise": Object {
      "duration": 10,
      "exercises": Object {
        "01-notes": Object {
          "body": "<p>En la programación orientada a objetos (OOP), nos concentramos en describir
objetos, que tienen una data (un estado) y una serie de operaciones que pueden
realizar.</p>
<p>Imaginemos que estamos construyendo una aplicación de \\"notas\\", donde el usuario
puede añadir notas con un texto. Antes de empezar a implementar tratamos de
imaginarnos los objetos que participan de este proceso. Lo primero que se nos
viene a la mente es que vamos a necesitar objetos de tipo \\"nota\\".</p>
<h2 id=\\"tarea\\">Tarea</h2>
<p>El boilerplate contiene dos constructores (<code>Note</code> y <code>Notes</code>). El primero
(<code>Note</code>) ya está implemetado. Ahora nos piden implementar los métodos
<code>Notes.prototype.add</code> y <code>Notes.prototype.toString</code>.</p>
<h2 id=\\"ejemplo\\">Ejemplo</h2>
<p>Una vez implementado el ejercicio, alguien que importe tu módulo debería de
poder hacer lo siguiente:</p>
<pre><code class=\\"language-js\\">const note1 = new Note('hola');
const note2 = new Note('mundo');
const notes = new Notes();

notes.add(note1);
notes.add(note2);

console.log(notes.toString());

// [ ] | Mon Jun 12 2017 | mundo
// [ ] | Mon Jun 12 2017 | hola

note1.completed = true;

console.log(notes.toString());

// [ ] | Mon Jun 12 2017 | mundo
// [X] | Mon Jun 12 2017 | hola
</code></pre>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li><code>Notes.prototype.add</code> debe botar error (throw) si el argumento (<code>note</code>) no es
una instancia de <code>Note</code>.</li>
<li><code>Notes.prototype.add</code> debe añadir nuevas notas al principio de <code>this.data</code>, no
al final.</li>
<li>La implementación de <code>Notes.prototype.toString</code> debe iterar sobre las notas e
invocar <code>toString</code> en cada nota y así ir concatenando el resultado. El string
que retornes debe contener una línea para cada nota (ver ejemplo).</li>
<li>El método <code>Notes.prototype.toString</code> debe listar las notas ordenadas por fecha
de creación descendente, la última añadida debe aparecer primero.</li>
<li>No olvides exportar los constructores <code>Note</code> y <code>Notes</code>.</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\\" target=\\"_blank\\">Operators: instanceof - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift\\" target=\\"_blank\\">Array#unshift - MDN</a></li>
<li><a href=\\"https://css-tricks.com/understanding-javascript-constructors/\\" target=\\"_blank\\">Understanding JavaScript Constructors - CSS Tricks</a></li>
</ul>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "bm90ZXMuanM=": "function Note(text) {
  this.text = text || '';
  this.createdAt = new Date();
  this.completed = false;
}

// Convierte note en un string con este formato:
// [X] | Mon Jun 12 2017 | mundo
Note.prototype.toString = function () {
  let str = '[' + (this.completed ? 'X' : ' ') + ']';
  str += ' | ' + this.createdAt.toDateString();
  str += ' | ' + this.text;
  return str;
};


function Notes() {
  this.data = [];
}

Notes.prototype.add = function (note) {
  //...
};

Notes.prototype.toString = function () {
  //...
};
",
            },
            "c29sdXRpb24=": Object {
              "bm90ZXMuanM=": "function Note(text) {
  this.text = text || '';
  this.createdAt = new Date();
  this.completed = false;
}

Note.prototype.toString = function () {
  let str = '[' + (this.completed ? 'X' : ' ') + ']';
  str += ' | ' + this.createdAt.toDateString();
  str += ' | ' + this.text;
  return str;
};


function Notes() {
  this.data = [];
}

Notes.prototype.add = function (note) {
  if (!(note instanceof Note)) {
    throw new Error('Wrong type!');
  }

  this.data.unshift(note);
};

Notes.prototype.toString = function () {
  let str = '';
  for (let i = 0; i < this.data.length; i++) {
    if (i > 0) {
      str += '\\\\n';
    }
    str += this.data[i].toString();
  }
  return str;
};


exports.Note = Note;
exports.Notes = Notes;
",
            },
            "dGVzdA==": Object {
              "bm90ZXMuc3BlYy5qcw==": "'use strict';


const Assert = require('chai').assert;
const Submission = require('../solution/notes');
const Note = Submission.Note;
const Notes = Submission.Notes;


describe('Note', () => {

  it('debería exportar función \`Note\`', () => {
    Assert.equal(typeof Note, 'function');
  });

  it('debería crear un nuevo objeto cuando invocamos new Note()', () => {
    const note = new Note('renovar dni');
    Assert.equal(note.text, 'renovar dni');
    Assert.ok(note.createdAt instanceof Date);
    Assert.equal(note.completed, false);
  });

  it('debería retornar undefined cuando invocamos Note() sin \\"new\\"', () => {
    Assert.equal(Note('renovar dni'), undefined);
  });

});


describe('Note#toString', () => {

  it('debería convertir objeto a string', () => {
    const note = new Note('foo');
    const date = (new Date()).toDateString();
    Assert.equal(note.toString(), '[ ] | ' + date + ' | foo');
    note.completed = true;
    Assert.equal(note.toString(), '[X] | ' + date + ' | foo');
  });

});


describe('Notes (oop)', () => {

  it('debería exportar función \`Notes\`', () => {
    Assert.equal(typeof Notes, 'function');
  });

});


describe('Notes#add', () => {

  it('debería botar error cuando argumento no es instancia de Note', () => {
    [
      undefined, null, true, false, 0, 1, 3.14, '', 'foo', [], [1, 2], {},
      {foo: 'bar'}, new Date(), function () {}
    ].forEach((val) => {

      const notes = new Notes();
      Assert.throws(_ => notes.add(val), Error);
    });
  });


  it('debería permitir añadir instancias de Note', () => {
    const notes = new Notes();
    Assert.doesNotThrow(_ => notes.add(new Note('one')));
  });

});


describe('Notes#toString', () => {

  it('debería retornar un string vacío cuando no hay notas', () => {
    const notes = new Notes();
    Assert.equal(notes.toString(), '');
  });


  it('debería ordenar lista por fecha de creación descendente', () => {
    const notes = new Notes();
    const note1 = new Note('one');
    const date = (new Date()).toDateString();

    notes.add(note1);
    notes.add(new Note('two'));

    Assert.equal(notes.toString(), [
      '[ ] | ' + date + ' | two',
      '[ ] | ' + date + ' | one'
    ].join('\\\\n'));

    note1.completed = true;

    Assert.equal(notes.toString(), [
      '[ ] | ' + date + ' | two',
      '[X] | ' + date + ' | one'
    ].join('\\\\n'));
  });

});
",
            },
          },
          "title": "Notes (OOP)",
        },
      },
      "format": "self-paced",
      "title": "Ejercicio OOP",
      "type": "practice",
    },
    "10-fp": Object {
      "body": "<p>Finalmente llegamos al paradigma funcional (<em>Functional Programming</em>), y digo
finalmente porque es probable que sientas curiosidad por conocer un poco más
sobre este paradigma tan incomprendido, pero tan de moda en el mundo de
JavaScript.</p>
<p>A diferencia del paradigma procedural y el orientado a objetos, la programación
funcional pertenece a la rama de los paradigmas <em>declarativos</em>. Esto quiere
decir que el \\"estilo\\" en el que programamos va a estar mucho más enfocado en qué
queremos hacer y no tanto en los detalles de cómo la computadora lo ejecuta.</p>
<p>Cuando hablamos del estilo imperativo dijimos que nos enfocábamos en asignar
valores a variables, mutar esas variables, e iterar usando bucles. La
programación funcional se caracteriza por exactamente lo opuesto. <strong>En FP el
principal mecanismo de cómputo es la aplicación de argumentos a funciones</strong>.
Como consecuencia, evitamos la asignación de varialbles, mutación, delegamos el
control de flujo, ... De hecho, podemos resumir los principios de la
programación funcional en los siguientes:</p>
<ul>
<li><strong>Higher order functions</strong> (funciones como argumentos y/o valores de retorno)</li>
<li><strong>Funciones puras</strong> (sin efectos secundarios y siempre retorna lo mismo para
los mismos argumentos)</li>
<li><strong>Composición</strong> de funciones</li>
<li><strong>Inmutabilidad</strong> (no \\"mutar\\" valores asignados)</li>
<li><strong>Evitar el \\"estado\\" compartido</strong> (no usar referencias fuera del scope de la
función)</li>
<li>Uso de <strong>recursión</strong> como alternativa a la iteración.</li>
</ul>
<p>Veamos estos conceptos en acción:</p>
<pre><code class=\\"language-js\\">// pasando una función anónima como un argumento
setTimeout(function () {
  //...
}, 100);


// recibiendo una función como un argumento
function map(arr, fn) {
  const results = [];
  for (let i = 0; i &lt; arr.length; i++) {
    results.push(fn(arr[i]));
  }
  return results;
}

// Ahora reemplazando iteración con recursividad
function recursiveMap(arr, fn) {
  if (!arr.length) {
    return [];
  }
  return [fn(arr[0])].concat(recursiveMap(arr.slice(1), fn));
}
</code></pre>
<p>La última función (<code>recursiveMap</code>) es un buen ejemplo de FP porque muestra como
podemos recibir una función como argumento, reemplzar iteración por recursión,
evitar asignación y mutación. Además no accede a ninguna referencia fuera de su
scope (sólo usa variables locales) y no tiene ningún efecto secundario: se
limita a producir un valor de retorno a partir de su input (argumentos) sin
afectar nada fuera de su <em>scope</em>.</p>
<p>Para comparar con el ejemplo que hicimos de OOP, ahora vamos a crear una función
que cree objetos, algo parecido a un constructor, pero muy distinto a la vez.
Los constructores son un tipo de función especial que se invoca con <code>new</code>, usa
<code>this</code> internamente y define un prototipo. La función que vamos a implementar
ahora se va a limitar a crear un objeto y retornarlo, nada de <code>new</code>, <code>this</code> o
<code>prototype</code>.</p>
<pre><code class=\\"language-js\\">const createRobot = function (name) {
  return {
    name: name,
    active: false
  };
};
</code></pre>
<p>ES2015 introduce \\"arrow functions\\" (funciones flecha), que es una implementación
de funciones muy parecida al keyword <code>function</code>, pero que no implica <code>new</code>,
<code>this</code> ni <code>prototype</code>.</p>
<pre><code class=\\"language-js\\">const createRobot = (name) =&gt; {
  return {
    name: name,
    active: false
  };
};
</code></pre>
<hr>
<p>PRO TIP:</p>
<p>Con un poquito más de azúcar sintáctica cortesía de ES2015:</p>
<pre><code class=\\"language-js\\">const createRobot = name =&gt; ({
  name,
  active: false
});
</code></pre>
<p>Cuando el cuerpo de la función es sólo una expresión (un objeto literal en
nuestro caso), las \\"arrow functions\\" nos permiten hacer <em>retorno implícito</em>, lo
que significa que podemos obviar los <code>{}</code> que determinan el \\"bloque\\" de la
función y el keyword <code>return</code>. El resultado de evaluar la expresión será el
valor de retorno. En este ejemplo hemos envuelto la expresión (el objeto
literal) en paréntesis <code>()</code> para evitar que los <code>{}</code> se confundan con el cuerpo
de la función. En este caso los curly braces son parte del objeto!</p>
<hr>
<p>En FP, en vez de pensar en \\"tipos\\", normalmente nos centramos en
transformaciones. Es decir, una función recibe un input (argumentos) y de alguna
forma los \\"transforma\\" en otra cosa. Por ejemplo, en la función anterior,
podemos decir que la función <code>createRobot</code> transforma un <code>string</code> (su input) en
un objeto (su valor de retorno). De esta forma cada función está completamente
aislada del mundo exterior y se concentra en hacer sólo una cosa.</p>
<p>Un buen ejemplo para visualzar el concepto de transformación es el método
<code>Array#map</code> en JavaScript (muy parecido al map que acabamos de implementar).
<code>Array.prototype.map</code> recibe un argumento, una función que será invocada para
cada elemento del array, y retorna un nuevo arreglo con los resultados de cada
invocación a la función que recibe <code>Array#map</code> como argumento.</p>
<pre><code class=\\"language-js\\">const array = ['1', '02', '33', '3.14', '028'];

const double = num =&gt; num + num;

console.log(array.map(double));
// [ '11', '0202', '3333', '3.143.14', '028028' ]

console.log(array.map(parseFloat));
// [ 1, 2, 33, 3.14, 28 ]

console.log(array.map(parseFloat).map(double));
// [ 2, 4, 66, 6.28, 56 ]

const arrayToDouble = array =&gt; array.map(parseFloat).map(double);

console.log(arrayToDouble(array));
// [ 2, 4, 66, 6.28, 56 ]
</code></pre>
<p>Como vemos en estos ejemplos, podemos encadenar invocaciones a <code>Array#map</code> para
ir \\"transformando\\" los elementos de un arreglo, ya que cada invocación retorna
un array.</p>
<h2 id=\\"qué-ventajas-ofrece\\">Qué ventajas ofrece?</h2>
<ul>
<li>Cómo hemos visto en el ejemplo de arriba, el código funcional tiende a ser más
conciso y expresivo.</li>
<li>Más predecible. Más adelante veremos que como resultado de los principios del
paradigma (uso de funciones puras, inmutabilidad, evitar estado compartido y
efectos secundarios, ...) nuestro código será más fácil de predecir, aislar y
probar.</li>
<li>Se presta a la paralelización y la computación distribuida.</li>
<li>Se presta a la asincrónia.</li>
<li>JavaScript, como lenguaje, tiene una naturaleza más funcional que imperativa.</li>
</ul>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Blog posts:</p>
<ul>
<li><a href=\\"https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257\\" target=\\"_blank\\">Why Learn Functional Programming in JavaScript? (Composing Software)</a>,
Eric Elliott en Medium, Feb 20 2017</li>
<li><a href=\\"https://bethallchurch.github.io/JavaScript-and-Functional-Programming/\\" target=\\"_blank\\">JavaScript and Functional Programming</a>,
Beth Allchurch, 29 of June, 2016</li>
<li><a href=\\"https://codewords.recurse.com/issues/one/an-introduction-to-functional-programming\\" target=\\"_blank\\">An introduction to functional programming</a>,
Mary Rose Cook</li>
<li><a href=\\"https://medium.com/laboratoria-how-to/introducci%C3%B3n-a-la-programaci%C3%B3n-funcional-en-javascript-parte-1-e0b1d0b2142e\\" target=\\"_blank\\">Introducción a programación funcional en JavaScript — Parte 1</a>,
Lupo Montero en Medium, Feb 15 2017</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\\" target=\\"_blank\\">MDN - Arrow functions</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\\" target=\\"_blank\\">MDN - Array.prototype.map</a></li>
</ul>
",
      "duration": 10,
      "format": "self-paced",
      "title": "FP",
      "type": "read",
    },
    "11-fp-exercise": Object {
      "duration": 10,
      "exercises": Object {
        "01-notes": Object {
          "body": "<h2 id=\\"tarea\\">Tarea</h2>
<p>Implementa tres funciones con las siguientes \\"firmas\\":</p>
<h3 id=\\"createnotetext\\"><code>createNote(text)</code></h3>
<p>Esta función debe crear un objeto literal con tres propiedades (ver retorno).</p>
<h4 id=\\"argumentos\\">Argumentos</h4>
<ul>
<li><code>text</code>: un string con el texto de la nota</li>
</ul>
<h4 id=\\"retorno\\">Retorno</h4>
<p>Un objeto con 3 propiedades:</p>
<ul>
<li><code>text</code>: el texto de la nota.</li>
<li><code>createdAt</code>: objeto tipo <code>Date</code> creado cuando se invoca <code>createNote</code>.</li>
<li><code>completed</code>: un booleano con valor <code>false</code> por defecto.</li>
</ul>
<h3 id=\\"createnotesarray\\"><code>createNotes(array)</code></h3>
<p>Crea un arreglo de objetos a partir de un arreglo de strings. Cada objeto en el
nuevo arreglo será creado usando <code>createNote</code>.</p>
<h4 id=\\"argumentos-1\\">Argumentos</h4>
<ul>
<li><code>array</code>: Un array de strings con los textos de las notas.</li>
</ul>
<h4 id=\\"retorno-1\\">Retorno</h4>
<p>Un arreglo de objetos donde cada objeto tiene la estructura esperada de nota.</p>
<h3 id=\\"notestostringnotes\\"><code>notesToString(notes)</code></h3>
<p>Convierte un arreglo de notas (objetos con la estructura que hemos visto) en un
string. Para ello debe invocar <code>noteToString</code> para cada elemento en el array.</p>
<h4 id=\\"argumentos-2\\">Argumentos</h4>
<ul>
<li><code>notes</code>: Un arreglo de objetos (notas).</li>
</ul>
<h4 id=\\"retorno-2\\">Retorno</h4>
<p>Un string donde tenemos una línea por cada nota.</p>
<h2 id=\\"ejemplo\\">Ejemplo</h2>
<pre><code class=\\"language-js\\">const notes = createNotes(['hola', 'mundo']);

console.log(notes);

// [ { text: 'hola',
//    createdAt: 2017-06-15T17:40:56.093Z,
//    completed: false },
//  { text: 'mundo',
//    createdAt: 2017-06-15T17:40:56.093Z,
//    completed: false } ]

console.log(notesToString(notes));

// [ ] | Mon Jun 12 2017 | mundo
// [ ] | Mon Jun 12 2017 | hola

notes[0].completed = true;

console.log(notesToString(notes));

// [ ] | Mon Jun 12 2017 | mundo
// [X] | Mon Jun 12 2017 | hola
</code></pre>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li>Tu módulo debe exportar cuatro funciones: <code>createNote</code>, <code>noteToString</code>,
<code>createNotes</code> y <code>notesToString</code>.</li>
<li>Tus funciones deben de ser \\"puras\\" (no side effects).</li>
<li>Evita usar asignación dentro del cuerpo de las funciones.</li>
<li>Usa <code>Array#map</code> para implementar <code>createNotes</code> y <code>notesToString</code>.</li>
<li>Todas las funciones deben ser \\"arrow functions\\"</li>
</ul>
<h2 id=\\"bonus-points\\">Bonus points</h2>
<ul>
<li>Evita usar el \\"keyword\\" <code>return</code> cuando puedas usar retorno implícito.</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\\" target=\\"_blank\\">Arrow functions - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\\" target=\\"_blank\\">Array#map - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join\\" target=\\"_blank\\">Array#join - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\\" target=\\"_blank\\">Date - MDN</a></li>
</ul>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "bm90ZXMuanM=": "const createNote = text => {}; // debes implementar esta función ;-)

const noteToString = note => [
  '[' + (note.completed ? 'X' : ' ') + ']',
  ' | ' + note.createdAt.toDateString(),
  ' | ' + note.text
].join('');

const createNotes = array => {}; // debes implementar esta función ;-)

const notesToString = notes => {}; // debes implementar esta función ;-)
",
            },
            "c29sdXRpb24=": Object {
              "bm90ZXMuanM=": "const createNote = text => ({
  text,
  createdAt: new Date(),
  completed: false
});

const noteToString = note => [
  '[' + (note.completed ? 'X' : ' ') + ']',
  ' | ' + note.createdAt.toDateString(),
  ' | ' + note.text
].join('');

const createNotes = array => array.map(createNote);

const notesToString = notes => notes.map(noteToString).join('\\\\n');

exports.createNote = createNote;
exports.noteToString = noteToString;
exports.createNotes = createNotes;
exports.notesToString = notesToString;
",
            },
            "dGVzdA==": Object {
              "bm90ZXMuc3BlYy5qcw==": "'use strict';


const Assert = require('chai').assert;
const Submission = require('../solution/notes');
const { createNote, noteToString, createNotes, notesToString } = Submission;


describe('createNote()', () => {

  it('debería exportar función \`createNote\`', () => {
    Assert.equal(typeof createNote, 'function');
  });

  it('debería crear un objeto con los campos esperados', () => {
    const note = createNote('renovar dni');
    Assert.equal(note.text, 'renovar dni');
    Assert.ok(note.createdAt instanceof Date);
    Assert.equal(note.completed, false);
    Assert.equal(note.__proto__, Object.prototype);
  });

});

describe('noteToString()', () => {

  it('debería exportar función \`noteToString\`', () => {
    Assert.equal(typeof noteToString, 'function');
  });

  it('debería convertir objeto a string', () => {
    const note = createNote('foo');
    const date = (new Date()).toDateString();
    Assert.equal(noteToString(note), '[ ] | ' + date + ' | foo');
    note.completed = true;
    Assert.equal(noteToString(note), '[X] | ' + date + ' | foo');
  });

});

describe('createNotes()', () => {

  it('debería exportar función \`createNotes\`', () => {
    Assert.equal(typeof createNotes, 'function');
  });

});

describe('notesToString()', () => {

  it('debería exportar función \`notesToString\`', () => {
    Assert.equal(typeof notesToString, 'function');
  });

  it('debería retornar un string vacío cuando no hay notas', () => {
    const notes = createNotes([]);
    Assert.equal(notesToString(notes), '');
  });


  it('debería ordenar lista por fecha de creación descendente', () => {
    const notes = createNotes(['one']);
    const date = (new Date()).toDateString();

    notes.unshift(createNote('two'));

    Assert.equal(notesToString(notes), [
      '[ ] | ' + date + ' | two',
      '[ ] | ' + date + ' | one'
    ].join('\\\\n'));

    notes[1].completed = true;

    Assert.equal(notesToString(notes), [
      '[ ] | ' + date + ' | two',
      '[X] | ' + date + ' | one'
    ].join('\\\\n'));
  });

});
",
            },
          },
          "title": "Notes (FP)",
        },
      },
      "format": "self-paced",
      "title": "Ejercicio FP",
      "type": "practice",
    },
    "13-closing": Object {
      "body": "<h2 id=\\"resumen\\">Resumen</h2>
<p>Los <strong>Paradigmas de Programación</strong> (<em>Programming Paradigms</em>) son formas
diferentes de pensar en cómo se organiza un programa basado en una serie de
principios, los cuales resultan en estilos muy distintos y lenguajes muy
diversos.</p>
<p>Algunos paradigmas son más <strong>imperativos</strong> y otros más <strong>declarativos</strong>. Por
ejemplo, la programación orientada a procedimientos, o la programación orientada
objetos, van a tener un caracter imperativo, mientras que la programación
funcional tiene un caracter mucho más declarativo.</p>
<p>La <strong>programación por procedimientos</strong> (<em>procedural programming</em>) pertenece a la
rama del estilo <em>imperativo</em>. Cuando programamos orientados a procedimientos nos
concentramos en agrupar código en procedimientos o funciones.</p>
<p>En la <strong>programación orientada a objetos</strong> , vez de pensar en acciones nos
enfocamos en definir los \\"tipos\\" de datos primero, y después decidimos que
interacciones van a tener. En OOP diseñamos objetos, que van a tener una data
(un estado) y una serie de operaciones que pueden realizar.</p>
<p>En la <strong>programación orientada a objetos</strong> el principal mecanismo de reuso de
código es la <strong>herencia</strong>, donde un objeto \\"hereda\\" una serie de propiedades y
métodos de otro objeto o clase (en <em>herencia prototipal</em> heredamos directamente
de un objeto en vez de una clase).</p>
<p>La <strong>programación funcional</strong> pertenece a la rama de los paradigmas
<em>declarativos</em>. Esto quiere decir que el \\"estilo\\" en el que programamos va a
estar mucho más enfocado en <em>qué queremos hacer</em> y no tanto en los detalles de
<em>cómo la computadora lo ejecuta</em>.</p>
<p>En FP el principal mecanismo de cómputo es la aplicación de argumentos a
funciones. Como consecuencia, evitamos la asignación de varialbles, mutación y
delegamos el control de flujo.</p>
<p>Principios de la programación funcional:</p>
<ul>
<li><strong>Higher order functions</strong> (funciones como argumentos y/o valores de retorno)</li>
<li><strong>Funciones puras</strong> (sin efectos secundarios y siempre retorna lo mismo para
los mismos argumentos)</li>
<li><strong>Composición</strong> de funciones</li>
<li><strong>Inmutabilidad</strong> (no \\"mutar\\" valores asignados)</li>
<li><strong>Evitar el \\"estado\\" compartido</strong> (no usar referencias fuera del scope de la
función)</li>
<li>Uso de <strong>recursión</strong> como alternativa a la iteración.</li>
</ul>
<h2 id=\\"respondamos-juntxs-las-preguntas-de-la-apertura\\">Respondamos juntxs las preguntas de la apertura</h2>
<ul>
<li>Qué son los <strong>paradigmas de programación</strong>?</li>
<li>Qué es el estilo <strong>imperativo</strong></li>
<li>Qué es el estilo <strong>declarativo</strong></li>
<li>Qué paradigmas encajan dentro del estilo <strong>imperativo</strong> y cuales en el
<strong>declarativo</strong></li>
<li>Qué es la <strong>programación por procedimientos</strong>?</li>
<li>Qué es la <strong>programación orientada a objetos</strong>?</li>
<li>Qué es la <strong>programación funcional</strong>?</li>
<li>Cómo se aplican los diferentes paradigmas al mundo de JavaScript?</li>
<li>Cómo se comparan los diferentes paradigmas (diferencias, similitudes, ...)?</li>
<li>Cómo programar en los diferentes estilos</li>
</ul>
",
      "duration": 5,
      "format": "self-paced",
      "title": "Cierre",
      "type": "read",
    },
  },
  "03-proto": Object {
    "00-opening": Object {
      "body": "<h2 id=\\"¿por-qué-aprender-esto\\">¿Por qué aprender esto?</h2>
<p>La <strong>programación orientada a objetos</strong> (OOP) es un paradigma muy común y
potente. Como desarolladora de JavaScript es fundamental entender el paradigma,
las implicaciones a nivel de diseño y su implementación.</p>
<p>Entender bien la <strong>herencia prototipal</strong> en JavaScript es de especial
importancia ya que el modelo de herencia es muy distinto a la mayoría de
lenguajes orientados a objetos, donde casi siempre creamos objetos a partir de
clases, mientras que en JavaScript heredamos directamente de otros objetos a
través de cadenas de prototipos.</p>
<p>La herencia es el principal mecanismo de reuso de código en OOP. En esta unidad
vamos a ver cómo implementar herencia prototipal en JavaScript así como las
peculiaridades del paradigma al aplicarlo en el contexto del lenguaje.</p>
<h2 id=\\"guía-de-preguntas-y-conceptos-clave\\">Guía de preguntas y conceptos clave</h2>
<p>Cuando empezamos a estudiar un tema nuevo, es útil tener una idea de los
conceptos más importantes de lo que vamos a aprender y de los temas centrales
que debemos prestar particular atención.</p>
<p>A continuación te presentamos una serie de preguntas que debes ser capaz de
responder al terminar esta unidad. Utiliza estas preguntas como guía para
orientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida
que avanzas para validar que estás avanzando en la dirección correcta. Que te
sirva como un \\"checklist\\" que vas marcando a medida que vas progresando.</p>
<ul>
<li>Qué valor toma <code>this</code> cuando no puede ser inferido por el contexto?</li>
<li>Qué hace el método <code>bind</code> que tienen todas las funciones?</li>
<li>Cómo infiere JavaScript el valor de <code>this</code> dentro de una función?</li>
<li>Qué es un <strong>constructor</strong>?</li>
<li>Cómo usar <code>new</code> para crear instancias de un constructor?</li>
<li>Cómo usar <code>instanceof</code> para determinar si un objeto fue creado con un
constructor específico?</li>
<li>Cómo usar <code>Object.prototype.isPrototypeOf</code> para determinar si un objeto está
la cadena de prototipos de otro objeto?</li>
<li>Cómo añadir propiedades al prototipo de un constructor usando <code>Function.prototype</code>?</li>
<li>Cómo usar <code>Object.create</code> para crear objetos con un prototipo específico?</li>
<li>Cómo implementar <strong>herencia prototipal</strong>?</li>
</ul>
",
      "duration": 5,
      "format": "self-paced",
      "title": "Apertura",
      "type": "read",
    },
    "01-this-and-bind": Object {
      "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/wuv699tbbx?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>Entender el concepto de <code>this</code> es fundamental para entender el modelo de
objetos de JavaScript.</p>
<p><code>this</code> es una pseudo-variable que existe dentro de las funciones. <code>this</code>
(\\"esto\\") no significa nada por sí mismo, sino que depende del \\"contexto\\". El
valor de <code>this</code> debe ser \\"inferido\\" del contexto donde aparece, y por eso puede
ser motivo de confusión.</p>
<pre><code class=\\"language-js\\">function talk() {
  console.log(this.sound); // qué valor tiene \`this\`?
}
</code></pre>
<p>Si invocamos la función <code>talk</code> veremos que imprime <code>undefined</code>. Pero qué es
<code>this</code>? Inspeccionemos un poco...</p>
<pre><code class=\\"language-js\\">function talk() {
  console.log(this); // el objeto global!!
}

talk();
</code></pre>
<p>Cuando ejecutámos nustro código ahora veremos algo así:</p>
<pre><code class=\\"language-text\\">{ console: [Getter],
  DTRACE_NET_SERVER_CONNECTION: [Function],
  DTRACE_NET_STREAM_END: [Function],
  DTRACE_HTTP_SERVER_REQUEST: [Function],
  DTRACE_HTTP_SERVER_RESPONSE: [Function],
  DTRACE_HTTP_CLIENT_REQUEST: [Function],
  DTRACE_HTTP_CLIENT_RESPONSE: [Function],
  global: [Circular],
  process:
   process {
     title: 'node',
     version: 'v8.1.2',
     moduleLoadList:
      [ 'Binding contextify',
      ...
</code></pre>
<p>Qué es todo esto? De dónde salió? Cuando no se puede inferir el valor de <code>this</code>,
éste toma el valor del objeto global; <code>process</code> en Node.js o <code>window</code> en el
navegador.</p>
<p>En la lección anterior vimos cómo <code>this</code> tomaba un valor especial en caso de los
constructores. En ese contexto <code>this</code> hace referencia al nuevo objeto que crea
el constructor.</p>
<p>Pero hay otra manera más explícita de asignarle un valor a <code>this</code>:
<code>Function#bind</code>. Todas las funciones en JavaScript son objetos que heredan de
<code>Function.prototype</code>, y así heredan el método <code>bind()</code>, que nos permite crear
una copia de la función, pero con <code>this</code>, el \\"contexto\\", asignado
explícitamente a un valor.</p>
<p>\\"Bind\\" literalmente significa \\"ligar\\", \\"unir a\\" o \\"vincular con\\". Veamos un
ejemplo:</p>
<pre><code class=\\"language-js\\">const cat = { sound: 'meeow!' };
const boundToCat = talk.bind(cat);
boundToCat(); // meeow!
</code></pre>
<p>En este ejemplo <code>boundToCat</code> es una copia de <code>talk</code>, pero con su pseudo-variable
<code>this</code> asignada a <code>cat</code>. Por lo tanto, ahora siempre que invocamos <code>boundToCat</code>
el contexto está claro y no cambia dependiendo del contexto de invocación.</p>
<p>Pero qué pasaría si asignamos nuestra función <code>talk</code> a una propiedad de un
objeto?</p>
<pre><code class=\\"language-js\\">const cat = {
  talk: talk,
  sound: 'meeow!'
};

cat.talk(); // meeow!
talk(); // undefined
</code></pre>
<p><code>talk</code> y <code>cat.talk</code> hacen referencia a exactamente la misma función, pero se
comportan de manera distinta por el contexto. Al asignar <code>talk</code> a una propiedad
de <code>cat</code>, ahora cuando invocamos <code>cat.talk()</code> JavaScript automáticamente infiere
que el contexto es <code>cat</code>. Nótese que la función <code>talk</code> no ha cambiado, sólo ha
cabiado el hecho de que ahora la estamos invocando como un método de un objeto.</p>
<p>Qué pasaría si ahora asignamos ese método a una variable?</p>
<pre><code class=\\"language-js\\">const balbucea = cat.talk
balbucea(); // undefined
</code></pre>
<p>Tanto <code>cat.talk</code> como <code>balbucea</code> hacen referencia a la misma función <code>talk</code>,
pero podemos ver claramente que se comportan de maneras distintas dependiendo
del contexto.</p>
<p>Veamos como <code>bind</code> nos puede ayudar a \\"aclarar\\" el contexto de una función y así
poder asegurar el valor de <code>this</code>:</p>
<pre><code class=\\"language-js\\">const cat = {
  sound: 'meeow!'
};

cat.talk = talk.bind(cat);

cat.talk(); // meeow!
talk(); // undefined

const catTalk = cat.talk;
catTalk(); // meeow!
</code></pre>
<p>Para terminar esta sección, veamos un último ejemplo confuso y enrevesado:</p>
<pre><code class=\\"language-js\\">function talk() {
  console.log(this.sound); // qué valor tiene \`this\`?
}

const cat = {
  talk: talk,
  sound: 'meeow!'
};

const dog = {
  talk: cat.talk,
  sound: 'woof!'
};

dog.talk(); // woof!
</code></pre>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Capítulos de libros:</p>
<ul>
<li><a href=\\"http://eloquentjavascript.net/06_object.html\\" target=\\"_blank\\">Eloquent JavaScript - Chapter 6: The Secret Life of Objects</a></li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\\" target=\\"_blank\\">MDN - instanceof</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\\" target=\\"_blank\\">MDN - this</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\\" target=\\"_blank\\">MDN - Function.bind</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\\" target=\\"_blank\\">MDN - Function.call</a></li>
</ul>
",
      "duration": 10,
      "embeds": Array [
        Object {
          "href": "https://laboratoria.wistia.com/medias/wuv699tbbx?wvideo=wuv699tbbx",
          "id": "wuv699tbbx",
          "provider": "wistia",
          "type": "video",
        },
      ],
      "format": "self-paced",
      "title": "\`this\` y \`bind\`",
      "type": "read",
    },
    "02-object-create": Object {
      "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/y3ka2dold6?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>En JavaScript todo objeto tiene un \\"prototipo\\", aunque no lo especifiquemos.
Cuando creamos un objeto literal, el prototipo del objeto por defecto es
<code>Object.prototype</code>.</p>
<pre><code class=\\"language-js\\">console.log(Object.prototype.isPrototypeOf({})); // true
console.log({} instanceof Object); // true
</code></pre>
<p>En la lección anterior vimos como podemos usar <em>constructores</em> para crear
objetos con un prototipo determinado. Cuando usamos un constructor los objetos
nuevos tendrán como prototipo la propiedad <code>prototype</code> del constructor.</p>
<pre><code class=\\"language-js\\">function Robot(name) {
  this.name = name;
}

Robot.prototype.say = function () {
  console.log('Hi! I\\\\'m ' + this.name + '!');
};

const ada = new Robot('ada');
ada.say(); // Hi! I'm ada!

console.log(ada instanceof Robot); // true
console.log(Robot.prototype.isPrototypeOf(ada)); // true
</code></pre>
<p>Los constructores son comunes porque se parecen a las \\"clases\\" que hay en otros
lenguajes, pero no son la única manera de crear objetos con un prototipo
determinado. Hay una manera más simple y más natural para el modelo prototipal:
<a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\\" target=\\"_blank\\"><code>Object.create()</code></a>.</p>
<pre><code class=\\"language-js\\">// otra manera de asignar el prototipo: \`Object.create()\`
const robot = {
  say: function () {
    console.log('Hi! I\\\\'m ' + this.name + '!');
  }
};

const johnny = Object.create(robot);
johnny.name = 'johnny';
johnny.say(); // Hi! I'm johnny!

const betty = Object.create(robot);
betty.name = 'betty';
betty.say(); // Hi! I'm betty!

console.log(robot.isPrototypeOf(johnny)); // true
console.log(robot.isPrototypeOf(betty)); // true
</code></pre>
<p>JavaScript implementa \\"herencia\\" a través de prototipos, lo que quiere decir que
no heredamos de una clase, sino de un objeto. Así que podemos concentrarnos en
los prototipos sin necesidad de un constructor, <code>new</code> y <code>Function#prototype</code>.</p>
<p>A diferencia de los constructores, cuando usamos directamente <code>Object.create</code> no
tenemos dónde escribir lógica de inicialización. Para solventar esto podríamos
refactorizar el constructor anterior en una función que explícitamente crea un
nuevo objeto usando <code>Object.create()</code> y le asigna la propiedad <code>name</code>.</p>
<pre><code class=\\"language-js\\">function createRobot(name) {
  const obj = Object.create(robot);
  obj.name = name;
  return obj;
}
</code></pre>
<p>Como alternativa, una convención común cuando necesitamos lógica de constructor
es añadir un método <code>init</code> que se encargue de inicializar el objeto:</p>
<pre><code class=\\"language-js\\">const robot = {
  init: function (name) {
    this.name = name;
  },
  say: function () {
    console.log('Hi! I\\\\'m ' + this.name + '!');
  }
};
</code></pre>
<hr>
<p>PRO TIP:</p>
<p>Si nuestro métodod <code>init</code> retorna una referencia a <code>this</code>, podemos encadenar las
invocaciones:</p>
<pre><code class=\\"language-js\\">const robot = {
  init: function (name) {
    this.name = name;
    return this;
  },
  say: function () {
    console.log('Hi! I\\\\'m ' + this.name + '!');
  }
};

const johnny = Object.create(robot).init('johnny');
</code></pre>
<hr>
<p>Por ahora hemos invocado <code>Object.create()</code> con un solo argumento: el prototipo
que queremos que tenga el nuevo objeto. Pero <code>Object.create()</code> nos ofrece la
posibilidad de pasar un segundo argumento: un objeto cuyas propiedades serán
agregadas al objeto recién creado, con los nombres de propiedad
correspondientes. Estas propiedades corresponden al segundo argumento de
<a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\\" target=\\"_blank\\"><code>Object.defineProperties</code></a>.</p>
<pre><code class=\\"language-js\\">function createRobot(name) {
  return Object.create(robot, {
    name: {
      value: name,
      enumerable: true
    }
  });
}

const grace = createRobot('grace');
grace.say(); // Hi! I'm grace!
console.log(grace); // { name: 'grace' }
</code></pre>
<hr>
<p>BONUS FACT:</p>
<p><code>Object.create()</code> fue originalmente implementada y popularizada por <a href=\\"http://javascript.crockford.com/prototypal.html\\" target=\\"_blank\\">Douglas
Crockford</a>, el abuelito gruñón
del JavaScript, con la intención de aclarar los malos entendidos que generan los
constructores, que parecen clases pero no lo son, y en cambio se centra en los
prototipos. Hoy en día <code>Object.create()</code> ya es parte del lenguaje en sí.</p>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Videos:</p>
<ul>
<li><div class=\\"iframe-container\\"><iframe width=\\"640\\" height=\\"360\\" src=\\"https://www.youtube.com/embed/YkoelSTUy7A?autoplay=0\\" frameborder=\\"0\\" gesture=\\"media\\" allow=\\"encrypted-media\\" allowfullscreen=\\"true\\"></iframe></div>,
<code>19:19</code>, <a href=\\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\\" target=\\"_blank\\">funfunfunction</a>,
22 ago. 2016</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\\" target=\\"_blank\\">MDN - Object.create</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\\" target=\\"_blank\\">MDN - Object.defineProperties</a></li>
</ul>
",
      "duration": 10,
      "embeds": Array [
        Object {
          "href": "https://laboratoria.wistia.com/medias/y3ka2dold6?wvideo=y3ka2dold6",
          "id": "y3ka2dold6",
          "provider": "wistia",
          "type": "video",
        },
        Object {
          "href": "https://www.youtube.com/watch?v=YkoelSTUy7A",
          "id": "YkoelSTUy7A",
          "provider": "youtube",
          "type": "video",
        },
      ],
      "format": "self-paced",
      "title": "Object.create()",
      "type": "read",
    },
    "03-prototypal-inheritance": Object {
      "body": "<p><div class=\\"iframe-container\\"><iframe width=\\"100%\\" height=\\"100%\\" src=\\"//fast.wistia.net/embed/iframe/6p1jbpi4qk?videoFoam=true\\" frameborder=\\"0\\" scrolling=\\"no\\" allowfullscreen=\\"true\\" mozallowfullscreen=\\"true\\" webkitallowfullscreen=\\"true\\" oallowfullscreen=\\"true\\" msallowfullscreen=\\"true\\" allowtransparency=\\"true\\"></iframe></div></p>
<p>Hasta ahora nos hemos concetrado en el concepto de prototipo y cómo crear
objetos con un prototipo determinado. También hemos mencionado el concepto
de <em>cadena de prototipos</em> y cómo JavaScript \\"resuleve\\" (busca) las propiedades
de un objeto empezando por aquellas definidas directamente sobre la instacia,
después el prototipo, de ahí el prototipo del prototipo y así sucesivamente.</p>
<p>También hemos hablado de cómo el concepto de \\"herencia\\" y las \\"jerarquías de
herencia\\" son fundamentales en la programación orientada a objetos. Ahora es la
hora de ver cómo usamos lo que hemos aprendido de prototipos y <code>Object.create</code>
para implementar una jerarquía de herencia, donde un objeto hereda de otro
objeto que a su vez hereda de otro.</p>
<p>Para heredar de un objeto existente, podemos crear un nuevo constructor y
a su prototipo asignarle un objeto que tenga como prototipo el prototipo del
constructor que queremos \\"extender\\". Para crear ese objeto que podamos usar como
prototipo del nuevo constructor vamos a usar <code>Object.create()</code>, que nos permite
crear un nuevo objeto especificando su prototipo.</p>
<p>Continuando con el ejemplo de la lección anterior, implementemos un nuevo tipo
de nota que herede de <code>Note</code>.</p>
<pre><code class=\\"language-js\\">//
// Note (constructor base que vamos a extender, copiado de la lección anterior)
//
function Note(text) {
  this.text = text || '';
  this.createdAt = new Date();
  this.completed = false;
}

Note.prototype.toString = function () {
  let str = '[' + (this.completed ? 'X' : ' ') + ']';
  str += ' | ' + this.createdAt.toDateString();
  str += ' | ' + this.text;
  return str;
};

//
// ImageNote (constructor que hereda de Note)
//
function ImageNote(url) {
  this.url = url;
}

// Heredamos de \`Note.prototype\`
ImageNote.prototype = Object.create(Note.prototype);

console.log(new ImageNote('http://foo.com/bar.png'));
// Note { url: 'http://foo.com/bar.png' }
</code></pre>
<p>Hemos creado un constructor <code>ImageNote</code>, y antes de fijarnos en el cuerpo del
constructor veamos primero el mecanismo de herencia. A <code>ImageNote.prototype</code> le
asignamos un objeto nuevo que tiene <code>Note.prototype</code> como prototipo usando
<code>Object.create()</code>.</p>
<p>Nuestra implementación de <code>ImageNote</code> todavía está incompleta, pero ya podemos
ver cómo hemos preparado el escenario para que herede de <code>Note.prototype</code>. En el
caso de <code>Note</code>, habíamos asignado propiedades a <code>Note.prototype</code>, pero no
habíamos asignado el objeto <code>Note.prototype</code> en sí. Ahora en <code>ImageNote</code> hacemos
algo muy distinto: usamos <code>Object.create()</code> para crear un nuevo objeto que tenga
como prototipo <code>Note.prototype</code>, y éste nuevo objeto lo asignamos a
<code>ImageNote.prototype</code>. Lo que estamos haciendo es construir una cadena de
prototipos. Los objetos creados con <code>new ImageNote()</code> tendrán como prototipo un
objeto que a su vez tiene <code>Note.prototype</code> como prototipo. Esto puede sonar
bastante confuso al principio. Tómate tu tiempo para entender lo que está
pasando.</p>
<p>Hemos dicho que nuestra implementación no está completa. Si nos fijamos en el
constructor <code>Note</code> vemos que inicializa el nuevo objeto con tres propiedades:
<code>text</code>, <code>createdAt</code> y <code>completed</code>. Podríamos \\"duplicar\\" la lógica dentro del
constructor <code>ImageNote</code>, pero si estamos usando herencia, es precisamente para
poder reusar código y evitar repetición!</p>
<p>Antes hemos visto como podemos usar <code>bind</code> para definir de forma explícita el
valor de <code>this</code>. Ahora veamos cómo otro método de las funciones nos permite
\\"invocar\\" una función asignando <code>this</code> a lo que queramos.</p>
<pre><code class=\\"language-js\\">function ImageNote(url) {
  this.url = url;
  Note.call(this, 'an image note');
}

// Heredamos de \`Note.prototype\`
ImageNote.prototype = Object.create(Note.prototype);

console.log(new ImageNote('http://foo.com/bar.png'));
</code></pre>
<p>En la consola deberías ver algo así:</p>
<pre><code class=\\"language-text\\">Note {
  url: 'http://foo.com/bar.png',
  text: 'an image note',
  createdAt: 2017-06-22T15:05:21.013Z,
  completed: false }
</code></pre>
<p>Dentro de nuestro constructor <code>ImageNote</code> hemos añadido una invocación al
constructor <code>Note</code>. De esa forma podemos reusar la lógica del constructor
<code>Note</code>, y para asegurarnos de que <code>Note</code> opera sobre el <code>this</code> de la nueva nota
creada con <code>ImageNote</code> usamos <code>call()</code>. <code>Function.prototype.call</code> es muy
parecida a <code>Function.prototype.bind</code>, pero en vez de retornar una función con
el contexto fijado, lo que hace es invocar la función con el contexto deseado.</p>
<p>También podemos ver, al hacer <code>console.log</code>, que el objeto aparece como de
\\"tipo\\" <code>Note</code> y no <code>ImageNote</code>. Eso es porque el prototipo de una función guarda
una referencia a su constructor en una propiedad llamada <code>constructor</code>. Al
reemplazar el prototipo de <code>ImageNote</code> con el objeto creado con <code>Object.create</code>,
la propiedad <code>constructor</code> ahora resuleve al constructor de <code>Note</code>. Podemos
corregir esto explícitamente asignando <code>ImageNote.prototype.constructor</code>:</p>
<pre><code class=\\"language-js\\">function ImageNote(url) {
  this.url = url;
  Note.call(this, 'an image note');
}

// Heredamos de \`Note.prototype\`
ImageNote.prototype = Object.create(Note.prototype);
// Asignamos constructor al nuevo prototipo
ImageNote.prototype.constructor = ImageNote;

console.log(new ImageNote('http://foo.com/bar.png'));
</code></pre>
<p>En la consola deberías ver algo así:</p>
<pre><code class=\\"language-text\\">ImageNote {
  url: 'http://foo.com/bar.png',
  text: 'an image note',
  createdAt: 2017-06-22T15:12:40.163Z,
  completed: false }
</code></pre>
<p>Yay! Ya tenemos un constructor que hereda de <code>Note</code>! Ahora vamos a modificar la
funcionalidad del método <code>Note#toString</code> para que se adapte a <code>ImageNote</code> y nos
muestre la url de la imagen:</p>
<pre><code class=\\"language-js\\">function ImageNote(url) {
  this.url = url;
  Note.call(this, 'an image note');
}

// Heredamos de \`Note.prototype\`
ImageNote.prototype = Object.create(Note.prototype);
ImageNote.prototype.constructor = ImageNote;

// Sobreescribimos el método \`toString\` para instancias de \`ImageNote\`
ImageNote.prototype.toString = function () {
  return Note.prototype.toString.call(this) + ' | ' + this.url;
};
</code></pre>
<p>Hemos declarado un nuevo método <code>toString</code> sobre el prototipo de <code>ImageNote</code>, y
en la implementación de ese método estamos reusando <code>Note.prototype.toString</code>,
haciendo uso de <code>Function#call</code> otra vez ;-)</p>
<p>Ahora instanciemos nuestro objeto y veamos como se comporta:</p>
<pre><code class=\\"language-js\\">const imageNote = new ImageNote('http://foo.bar/baz.jpg');

console.log(imageNote);
console.log(imageNote.toString());
// [ ] | Thu Jun 22 2017 | an image note | http://foo.bar/baz.jpg

console.log(note instanceof ImageNote); // false
console.log(imageNote instanceof Note); // true
console.log(imageNote instanceof ImageNote); // true

console.log(Note.prototype.isPrototypeOf(imageNote)); // true
console.log(ImageNote.prototype.isPrototypeOf(note)); // false
console.log(ImageNote.prototype.isPrototypeOf(imageNote)); // true
</code></pre>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Capítulos de libros:</p>
<ul>
<li><a href=\\"http://eloquentjavascript.net/06_object.html\\" target=\\"_blank\\">Eloquent JavaScript - Chapter 6: The Secret Life of Objects</a></li>
</ul>
<p>Blog posts:</p>
<ul>
<li><a href=\\"https://css-tricks.com/understanding-javascript-constructors/\\" target=\\"_blank\\">Understanding JavaScript Constructors</a>,
Faraz Kelhini, CSS Tricks, Sep 24 2015</li>
</ul>
<p>Videos:</p>
<ul>
<li><a href=\\"https://frontendmasters.com/courses/javascript-jquery-dom/prototypal-inheritance/\\" target=\\"_blank\\">Prototypal Inheritance</a>,
<code>8:52</code>, Justin Meyer, <a href=\\"https://frontendmasters.com/\\" target=\\"_blank\\">Frontend Masters</a></li>
<li>Playlist: <a href=\\"https://www.youtube.com/playlist?list=PL0zVEGEvSaeHBZFy6Q8731rcwk0Gtuxub\\" target=\\"_blank\\">Object Creation in JavaScript</a>,
<code>aprox. 3h</code>, <a href=\\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\\" target=\\"_blank\\">funfunfunction</a>,
2016</li>
<li><div class=\\"iframe-container\\"><iframe width=\\"640\\" height=\\"360\\" src=\\"https://www.youtube.com/embed/riDVvXZ_Kb4?autoplay=0\\" frameborder=\\"0\\" gesture=\\"media\\" allow=\\"encrypted-media\\" allowfullscreen=\\"true\\"></iframe></div>,
<code>11:55</code>, <a href=\\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\\" target=\\"_blank\\">funfunfunction</a>,
25 Jan 2016</li>
<li><div class=\\"iframe-container\\"><iframe width=\\"640\\" height=\\"360\\" src=\\"https://www.youtube.com/embed/YkoelSTUy7A?autoplay=0\\" frameborder=\\"0\\" gesture=\\"media\\" allow=\\"encrypted-media\\" allowfullscreen=\\"true\\"></iframe></div>,
<code>19:19</code>, <a href=\\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\\" target=\\"_blank\\">funfunfunction</a>,
22 ago. 2016</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\\" target=\\"_blank\\">MDN - instanceof</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\\" target=\\"_blank\\">MDN - this</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\\" target=\\"_blank\\">MDN - Function.bind</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\\" target=\\"_blank\\">MDN - Function.call</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\\" target=\\"_blank\\">MDN - Object.create</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\\" target=\\"_blank\\">MDN - Object.defineProperties</a></li>
</ul>
",
      "duration": 12,
      "embeds": Array [
        Object {
          "href": "https://laboratoria.wistia.com/medias/6p1jbpi4qk?wvideo=6p1jbpi4qk",
          "id": "6p1jbpi4qk",
          "provider": "wistia",
          "type": "video",
        },
        Object {
          "href": "https://www.youtube.com/watch?v=riDVvXZ_Kb4",
          "id": "riDVvXZ_Kb4",
          "provider": "youtube",
          "type": "video",
        },
        Object {
          "href": "https://www.youtube.com/watch?v=YkoelSTUy7A",
          "id": "YkoelSTUy7A",
          "provider": "youtube",
          "type": "video",
        },
      ],
      "format": "self-paced",
      "title": "Herencia prototipal",
      "type": "read",
    },
    "04-ejercicios": Object {
      "duration": 90,
      "exercises": Object {
        "01-simple-objects": Object {
          "body": "<p>Hay muchas formas de crear objetos en JavaScript, pero la más sencilla es usando
objetos \\"literales\\":</p>
<pre><code class=\\"language-js\\">const alien = {
  legs: 3
};
</code></pre>
<h2 id=\\"desafío\\">Desafío</h2>
<p>Escribe un programa que haga lo siguiente:</p>
<ul>
<li>Crea un objeto que se llame <code>robot</code> usando un objeto literal</li>
<li><code>robot</code> debe tener una propiedad llamada <code>smart</code> con un valor <code>true</code></li>
</ul>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "c2ltcGxlT2JqZWN0cy5qcw==": "// -> Crea un objeto llamado 'robot' usando un objeto literal
// -> robot debe tener una propiedad 'smart' con el valor true
__

// Exports de Common JS para verificación, no modificar
module.exports = { robot };
",
            },
            "c29sdXRpb24=": Object {
              "c2ltcGxlT2JqZWN0cy5qcw==": "const robot = {
  smart: true
};

module.exports = { robot };
",
            },
            "dGVzdA==": Object {
              "c2ltcGxlT2JqZWN0cy5zcGVjLmpz": "'use strict';


const globalScope = (typeof WorkerNavigator !== 'undefined' ? WorkerNavigator : global);
const Assert = globalScope.Assert = require('chai').assert;
const Submission = require('../solution/simpleObjects');


describe('module', () => {

  it('debería exportar un objeto con una propiedad \\"robot\\"', () => {
    Assert.equal(typeof Submission, 'object');
    Assert.ok(Submission.hasOwnProperty('robot'));
  });

  describe('robot', () => {

    it('debería ser un objeto', () => {
      Assert.equal(typeof Submission.robot, 'object');
    });

    it('debería tener una propiedad \\"smart\\"', () => {
      Assert.ok(Submission.robot.hasOwnProperty('smart'));
    });

    describe('robot.smart', () => {

      it('debería ser true', () => {
        Assert.equal(Submission.robot.smart, true);
      });

    });

  });

});
",
            },
          },
          "title": "Objetos simples",
        },
        "02-proto": Object {
          "body": "<p>Para entender las cadenas de prototipos, no hay nada más simple que la propiedad
<code>__proto__</code>. Desgraciadamente <code>__proto__</code> todavía no es parte de la interfaz
estándar de JavaScript, y está depreciada. Así que probablemente no
deberías usarlo en el mundo real. No obstante, ayuda mucho a explicar los
prototipos de una forma sencilla.</p>
<pre><code class=\\"language-js\\">// creémos un objeto alien
const alien = {
  kind: 'alien'
};

// y un objeto robot
const robot = {
  kind: 'robot'
};

// y un objeto llamado 'zippy'
const zippy = {};

// asignamos alien como el prototipo de zippy
zippy.__proto__ = alien;

// zippy ahora está vinculado a alien
// 'hereda' las propiedades de alien
console.log(zippy.kind); //=&gt; 'alien'

// asignamos robot como el prototipo de zippy
zippy.__proto__ = robot;

// y ahora zippy está vinculado a robot
console.log(zippy.kind); //=&gt; 'robot'
</code></pre>
<p>Como puedes ver, la propiedad <code>__proto__</code> es bastante clara y fácil de usar.
Incluso si no deberíamos usar <code>__proto__</code> en producción, creo que estos ejemplos
nos dan una buena base para entender la modelo de objetos de JavaScript.</p>
<p>Puedes comprobar si un objeto es el prototipo de otro objeto así:</p>
<pre><code class=\\"language-js\\">console.log(alien.isPrototypeOf(zippy));
//=&gt; true
</code></pre>
<h2 id=\\"desafío\\">Desafío</h2>
<p>En la pestaña de código encontrarás el 'boilerplate' con las instrucciones y los
lugares donde añadir tu código debidamente señalados.</p>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "cHJvdG8uanM=": "// -> Crea un objeto 'machine'
//    con una propiedad 'motors' = 4
__

// -> Crea un objeto robot
//    con una propiedad 'friendly' = true
__

// -> Crea un objeto 'robby'
__

// -> Haz que 'machine' sea el prototipo de 'robot'
__

// -> Haz que 'robot' sea el prototipo de 'robby'
__

// -> Qué es \`robby.motors\`?
claim(robby.motors, __);

// -> Qué es \`robby.friendly\`?
claim(robby.friendly, __);


// ------------------------------------------------
// Exports de Common JS para verificación, no modificar
module.exports = {
  machine,
  robot,
  robby,
};
",
            },
            "c29sdXRpb24=": Object {
              "cHJvdG8uanM=": "const machine = {
  motors: 4
};

const robot = {
  friendly: true
};

const robby = {};

robot.__proto__ = machine;

robby.__proto__ = robot;

claim(robby.motors, 4);

claim(robby.friendly, true);

module.exports = {
  machine,
  robot,
  robby,
};
",
            },
            "dGVzdA==": Object {
              "cHJvdG8uc3BlYy5qcw==": "'use strict';


const Assert = require('chai').assert;
const Sinon = require('sinon');
const globalScope = (typeof self !== 'undefined' ? self : global);
const claim = globalScope.claim = (actual, expected) => Assert.equal(actual, expected);
const spy = Sinon.spy(globalScope, 'claim');
const Submission = require('../solution/proto');
const { machine, robot, robby } = Submission;


describe('proto', () => {

  it('debería exportar un objeto con las propiedades \\"machine\\", \\"robot\\" y \\"robby\\"', () => {
    Assert.equal(typeof Submission, 'object');
    Assert.ok(Submission.hasOwnProperty('machine'));
    Assert.ok(Submission.hasOwnProperty('robot'));
    Assert.ok(Submission.hasOwnProperty('robby'));
  });

  it('debería invocar claim 2 veces', () => {
    Assert.equal(spy.callCount, 2);
  });

  describe('primera invocación a claim', () => {
    it('debería comparar 4 con 4', () => {
      Assert.deepEqual(spy.getCall(0).args, [4, 4]);
    })
  });

  describe('segunda invocación a claim', () => {
    it('debería comparar true con true', () => {
      Assert.deepEqual(spy.getCall(1).args, [true, true]);
    })
  });

  describe('machine', () => {

    it('debería ser un objeto con una propiedad \\"motors\\"', () => {
      Assert.equal(typeof machine, 'object');
      Assert.ok(machine.hasOwnProperty('motors'));
    });

    describe('machine.motors', () =>
      it('debería ser 4', () => Assert.equal(machine.motors, 4)));

  });

  describe('robot', () => {

    it('debería ser un objeto con una propiedad \\"friendly\\"', () => {
      Assert.equal(typeof robot, 'object');
      Assert.ok(robot.hasOwnProperty('friendly'));
    });

    describe('robot.friendly', () =>
      it('debería ser true', () => Assert.equal(robot.friendly, true)));

  });

  describe('robby', () => {

    it('debería ser un objeto sin propiedades propias', () => {
      Assert.equal(Object.keys(robby).length, 0);
    });

    describe('robby.__proto__', () =>
      it('debería ser robot', () => Assert.equal(robby.__proto__, robot)));

    describe('robby.__proto__.__proto__', () =>
      it('debería ser machine', () => Assert.equal(robby.__proto__.__proto__, machine)));

    describe('robby.motors', () =>
      it('debería resolver a 4', () => Assert.equal(robby.motors, 4)));

    describe('robby.friendly', () =>
      it('debería resolver a true', () => Assert.equal(robby.friendly, true)));

  });

});
",
            },
          },
          "title": "El objeto __proto__",
        },
        "03-dynamic-lookups": Object {
          "body": "<p>Las búsquedas en el prototipo son dinámicas.</p>
<p>Puedes añadir propiedades al prototipo de un objeto en cualquier momento. La
cadena de prototipos (prototype chain) encontrará la nueva propiedad:</p>
<pre><code class=\\"language-js\\">const alien = {};

const zippy = {};
zippy.__proto__ = alien;

// zippy no resuelve (encuentra) una propiedad 'kind' en este punto
console.log(zippy.kind); //=&gt; undefined

// añadimos 'kind' a alien
alien.kind = 'alien';

// ahora zippy si resuelve 'kind'
// porque lo encuentra en 'alien'
console.log(zippy.kind); //=&gt; 'alien'
</code></pre>
<h2 id=\\"conclusiones\\">Conclusiones</h2>
<ul>
<li>Los objetos delegan la resolución/búsqueda (lookup) de propiedades a su
prototipo</li>
<li>Un prototipo puede ser compartido entre varios objetos</li>
</ul>
<h2 id=\\"desafío\\">Desafío</h2>
<p>El 'boilerplate' contiene las instrucciones y los lugares donde añadir tu código
debidamente señalados.</p>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "ZHluYW1pY0xvb2t1cHMuanM=": "// -> Declaremos tres objetos: 'machine' 'vehicle' y 'robot'
const machine = {};
const vehicle = {};
const robot = {};

// -> Haz que \`machine\` sea el prototipo de \`vehicle\`
// -> Haz que \`machine\` sea el prototipo de \`robot\`
__

// -> Qué es \`vehicle.motors\`?
claim(vehicle.motors, __);

// -> Qué es \`robot.motors\`?
claim(robot.motors, __);

// -> Define una propiedad \`motors\` en \`machine\` y asígnale el valor \`4\`
__

// -> Qué es \`vehicle.motors\` ahora?
claim(vehicle.motors, __);

// -> Qué es \`robot.motors\`?
claim(robot.motors, __);


// ------------------------------------------------
// Exports de Common JS para verificación, no modificar
module.exports = {
  machine,
  vehicle,
  robot,
};
",
            },
            "c29sdXRpb24=": Object {
              "ZHluYW1pY0xvb2t1cHMuanM=": "const machine = {};
const vehicle = {};
const robot = {};

vehicle.__proto__ = machine;
robot.__proto__ = machine;

// What is vehicle.motors
claim(vehicle.motors, undefined);
// What is robot.motors?
claim(robot.motors, undefined);

machine.motors = 4;

// -> What is \`vehicle.motors\` now?
claim(vehicle.motors, 4);

// -> What is \`robot.motors\`?
claim(robot.motors, 4);

// ------------------------------------------------
module.exports = {
  machine,
  vehicle,
  robot,
};
",
            },
            "dGVzdA==": Object {
              "ZHluYW1pY0xvb2t1cHMuc3BlYy5qcw==": "'use strict';


const Assert = require('chai').assert;
const Sinon = require('sinon');
const globalScope = (typeof self !== 'undefined' ? self : global);
const claim = globalScope.claim = (actual, expected) => Assert.equal(actual, expected);
const spy = Sinon.spy(globalScope, 'claim');
const Submission = require('../solution/dynamicLookups');
const { machine, vehicle, robot } = Submission;


describe('dynamicLookup', () => {

  it('debería exportar un objeto con las propiedades \\"machine\\", \\"vehicle\\" y \\"robot\\"', () => {
    Assert.equal(typeof Submission, 'object');
    Assert.ok(Submission.hasOwnProperty('machine'));
    Assert.ok(Submission.hasOwnProperty('vehicle'));
    Assert.ok(Submission.hasOwnProperty('robot'));
  });

  it('debería invocar claim 4 veces', () => {
    Assert.equal(spy.callCount, 4);
  });

  [
    [undefined, undefined],
    [undefined, undefined],
    [4, 4],
    [4, 4]
  ].forEach((args, idx) => {
    describe(\`invocación \${idx + 1} a claim\`, () => {
      it(\`debería comparar \${args[0]} con \${args[1]}\`, () => {
        Assert.deepEqual(spy.getCall(idx).args, args);
      })
    });
  });

  describe('machine', () => {

    it('debería ser un objeto con una propiedad \\"motors\\"', () => {
      Assert.equal(typeof machine, 'object');
      Assert.ok(machine.hasOwnProperty('motors'));
    });

    describe('machine.motors', () =>
      it('debería ser 4', () => Assert.equal(machine.motors, 4)));

  });

  describe('vehicle', () => {

    it('debería ser un objeto sin propiedades propias', () => {
      Assert.equal(typeof vehicle, 'object');
      Assert.equal(Object.keys(vehicle).length, 0);
    });

    it('debería ser un objeto con machine como prototipo', () => {
      Assert.equal(vehicle.__proto__, machine);
    });

    describe('vehicle.motors', () =>
      it('debería resolver a 4', () => Assert.equal(vehicle.motors, 4)));

  });

  describe('robot', () => {

    it('debería ser un objeto sin propiedades propias', () => {
      Assert.equal(typeof robot, 'object');
      Assert.equal(Object.keys(robot).length, 0);
    });

    it('debería ser un objeto con machine como prototipo', () => {
      Assert.equal(robot.__proto__, machine);
    });

    describe('robot.motors', () =>
      it('debería resolver a 4', () => Assert.equal(robot.motors, 4)));

  });

});
",
            },
          },
          "title": "Búsquedas dinámicas (dynamic lookups)",
        },
        "04-property-assignments": Object {
          "body": "<p>Qué pasa si actualizas una propiedad que ya existía en el prototipo? Veamos:</p>
<pre><code class=\\"language-js\\">const alien = {
  kind: 'alien'
};

const zippy = {};
zippy.__proto__ = alien;

zippy.kind = 'zippy';

console.log(zippy.kind); //=&gt; 'zippy'
// zippy ahora tiene una propiedad \`kind\`

console.log(alien.kind); //=&gt; 'alien'
// alien no se ha modificado
</code></pre>
<p>Las propiedades nuevas o actualizadas son asignadas al objeto, no a su
prototipo. Ten en cuenta que la propiedad <code>kind</code> ahora existe tanto en <code>alien</code>
como en <code>zippy</code>.</p>
<h2 id=\\"desafío\\">Desafío</h2>
<p>El 'boilerplate' tiene las instrucciones y los lugares donde añadir tu código
debidamente señalados.</p>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "cHJvcGVydHlBc3NpZ25tZW50cy5qcw==": "// -> Define tres objetos: 'machine', 'robot' y 'vehicle'
//    En la definición de \`machine\` añade la propiedad \`motors\` y asígnale null.
__

// -> Hacemos que \`machine\` sea el prototipo de \`robot\` y \`vehicle\`
vehicle.__proto__ = machine;
robot.__proto__ = machine;

// -> Qué son \`machine.motors\`, \`robot.motors\` y \`vehicle.motors\`?
claim(machine.motors, __);
claim(robot.motors, __);
claim(vehicle.motors, __);

// -> Asigna \`4\` a \`robot.motors\`.
__

// -> ¿Qué son \`machine.motors\`, \`robot.motors\` y \`vehicle.motors\` ahora?
claim(machine.motors, __);
claim(robot.motors, __);
claim(vehicle.motors, __);


// ------------------------------------------------
// Exports de Common JS para verificación, no modificar
module.exports = {
  machine,
  vehicle,
  robot,
};
",
            },
            "c29sdXRpb24=": Object {
              "cHJvcGVydHlBc3NpZ25tZW50cy5qcw==": "const machine = { motors: null };
const vehicle = {};
const robot = {};

// -> Let's make machine the prototype of robot and vehicle
vehicle.__proto__ = machine;
robot.__proto__ = machine;

claim(machine.motors, null);
claim(robot.motors, null);
claim(vehicle.motors, null);

robot.motors = 4;

claim(machine.motors, null);
claim(robot.motors, 4);
claim(vehicle.motors, null);

module.exports = {
  machine,
  vehicle,
  robot,
};
",
            },
            "dGVzdA==": Object {
              "cHJvcGVydHlBc3NpZ25tZW50cy5zcGVjLmpz": "'use strict';


const Assert = require('chai').assert;
const Sinon = require('sinon');
const globalScope = (typeof self !== 'undefined' ? self : global);
const claim = globalScope.claim = (actual, expected) => Assert.equal(actual, expected);
const spy = Sinon.spy(globalScope, 'claim');
const Submission = require('../solution/propertyAssignments');
const { machine, vehicle, robot } = Submission;


describe('propertyAssignments', () => {

  it('debería exportar un objeto con las propiedades \\"machine\\", \\"vehicle\\" y \\"robot\\"', () => {
    Assert.equal(typeof Submission, 'object');
    Assert.ok(Submission.hasOwnProperty('machine'));
    Assert.ok(Submission.hasOwnProperty('vehicle'));
    Assert.ok(Submission.hasOwnProperty('robot'));
  });

  it('debería invocar claim 6 veces', () => {
    Assert.equal(spy.callCount, 6);
  });

  [
    [null, null],
    [null, null],
    [null, null],
    [null, null],
    [4, 4],
    [null, null],
  ].forEach((args, idx) => {
    describe(\`invocación \${idx + 1} a claim\`, () =>
      it(\`debería comparar \${args[0]} con \${args[1]}\`, () =>
        Assert.deepEqual(spy.getCall(idx).args, args)
      )
    );
  });

  describe('machine', () => {

    it('debería tener una propiedad motors', () => {
      Assert.ok(robot.hasOwnProperty('motors'));
    });

    describe('machine.motors', () =>
      it('debería tener valor null', () => Assert.equal(machine.motors, null))
    );

  });

  describe('vehicle', () => {

    it('debería ser un objeto con machine como prototipo', () => {
      Assert.equal(vehicle.__proto__, machine);
    });

  });

  describe('robot', () => {

    it('debería ser un objeto con machine como prototipo', () => {
      Assert.equal(robot.__proto__, machine);
    });

    it('debería tener una propiedad motors', () => {
      Assert.ok(robot.hasOwnProperty('motors'));
    });

    describe('robot.motors', () =>
      it('debería tener valor 4', () => Assert.equal(robot.motors, 4))
    );

  });

});
",
            },
          },
          "title": "Asignación de propiedades",
        },
        "05-arrays-and-objects": Object {
          "body": "<p>Los arreglos y objetos podrían no comportarse como esperas.</p>
<p>Veamos qué pasa cuando modificamos un arreglo:</p>
<pre><code class=\\"language-js\\">const alien = {
  skills: ['morph']
};

const zorg = {};
zorg.__proto__ = alien;

zorg.skills.push('clone');

console.log(zorg.skills); //=&gt; morph, clone
// es lo que esperabamos

console.log(alien.skills); //=&gt; morph, clone
// quizás no esperábamos esto, pero funciona así porque hemos modificado el
// arreglo del prototipo.
</code></pre>
<p>Cuando modificas un arreglo u objeto, el cambio se hace directamente sobre el objeto.</p>
<h2 id=\\"desafío\\">Desafío</h2>
<p>El 'boilerplate' tiene las instrucciones y los
lugares donde añadir tu código debidamente señalados.</p>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "YXJyYXlzQW5kT2JqZWN0cy5qcw==": "// -> Crea tres objetos: 'machine', 'robot' y 'vehicle'
// -> En la definición de \`machine\` incluye una propiedad \`parts\`, y dale un
//    array vacío como valor: \`[]\`
// -> En la definición de \`machine\` incluye una propiedad 'capabilities', y
//    asígnale un objeto vacío: \`{}\`
__

// -> Hagamos que el prototipo de tanto \`robot\` como \`vehicle\` sea \`machine\`
robot.__proto__ = machine;
vehicle.__proto__ = machine;

// -> ¿Qué es \`robot.parts\`?
claim(robot.parts, __);

// -> ¿Qué es \`vehicle.parts\`?
claim(vehicle.parts, __);

// -> ¿Qué es \`robot.capabilities\`?
claim(robot.capabilities, __);

// -> ¿Qué es \`vehicle.capabilities\`?
claim(vehicle.capabilities, __);

// -> Añadamos 'core' a \`parts\` del robot
robot.parts.push('core');

// -> ¿Qué es \`robot.parts\` ahora?
claim(robot.parts, __);

// -> ¿Qué es \`vehicle.parts\` ahora?
claim(vehicle.parts, __);

// -> Démosle una habilidad al vehículo...
vehicle.capabilities.fly = true;

// -> ¿Qué es \`robot.capabilities\` ahora?
claim(robot.capabilities, __);

// -> ¿Qué es \`vehicle.capabilities\` ahora?
claim(vehicle.capabilities, __);


// ------------------------------------------------
// Exports de Common JS para verificación, no modificar
module.exports = {
  machine: machine,
  vehicle: vehicle,
  robot:   robot
}
",
            },
            "c29sdXRpb24=": Object {
              "YXJyYXlzQW5kT2JqZWN0cy5qcw==": "// -> Crea tres objetos: 'machine', 'robot' y 'vehicle'
// -> En la definición de \`machine\` incluye una propiedad \`parts\`, y dale un
//    array vacío como valor: \`[]\`
// -> En la definición de \`machine\` incluye una propiedad 'capabilities', y
//    asígnale un objeto vacío: \`{}\`

const machine = {
	parts: [],
	capabilities: {}
};

const vehicle = {};
const robot = {};

// -> Hagamos que el prototipo de tanto \`robot\` como \`vehicle\` sea \`machine\`
robot.__proto__ = machine;
vehicle.__proto__ = machine;

// -> ¿Qué es \`robot.parts\`?
claim(robot.parts, []);

// -> ¿Qué es \`vehicle.parts\`?
claim(vehicle.parts, []);

// -> ¿Qué es \`robot.capabilities\`?
claim(robot.capabilities, {});

// -> ¿Qué es \`vehicle.capabilities\`?
claim(vehicle.capabilities, {});

robot.parts.push('core');

// -> ¿Qué es \`robot.parts\` ahora?
claim(robot.parts, ['core']);

// -> ¿Qué es \`vehicle.parts\` ahora?
claim(vehicle.parts, ['core']);

// -> Démosle una habilidad al vehículo...
vehicle.capabilities.fly = true;

claim(robot.capabilities, {fly: true});
claim(vehicle.capabilities, {fly: true});

module.exports = {
	machine,
	vehicle,
	robot
}
",
            },
            "dGVzdA==": Object {
              "YXJyYXlzQW5kT2JqZWN0cy5zcGVjLmpz": "'use strict';


const Assert = require('chai').assert;
const Sinon = require('sinon');
const globalScope = (typeof self !== 'undefined' ? self : global);

const claim = globalScope.claim = (actual, expected) =>
  Array.isArray(expected) || (typeof expected === 'object' && expected instanceof Object) ?
    Assert.deepEqual(actual, expected) :
    Assert.equal(actual,expected);

const spy = Sinon.spy(globalScope, 'claim');
const Submission = require('../solution/arraysAndObjects');
const { machine, vehicle, robot } = Submission;


describe('arraysAndObjects', () => {

  it('debería exportar un objeto con las propiedades \\"machine\\", \\"vehicle\\" y \\"robot\\"', () => {
    Assert.equal(typeof Submission, 'object');
    Assert.ok(Submission.hasOwnProperty('machine'));
    Assert.ok(Submission.hasOwnProperty('vehicle'));
    Assert.ok(Submission.hasOwnProperty('robot'));
  });

  it('debería invocar claim 8 veces', () => {
    Assert.equal(spy.callCount, 8);
  });

  [ [ [ 'core' ], [] ],
    [ [ 'core' ], [] ],
    [ { fly: true }, {} ],
    [ { fly: true }, {} ],
    [ [ 'core' ], [ 'core' ] ],
    [ [ 'core' ], [ 'core' ] ],
    [ { fly: true }, { fly: true } ],
    [ { fly: true }, { fly: true } ]
  ].forEach((args, idx) => {
    describe(\`invocación \${idx + 1} a claim\`, () =>
      it(\`debería comparar \${args[0]} con \${args[1]}\`, () =>
        Assert.deepEqual(spy.getCall(idx).args, args)
      )
    );
  })

  describe('machine', () => {

    it('debería tener una propiedad parts y capabilities', () => {
      Assert.ok(machine.hasOwnProperty('parts'));
      Assert.ok(machine.hasOwnProperty('capabilities'));
    });

    describe('machine.parts', () => {
      it('debería tener valor [\\"core\\"]', () => {
        Assert.deepEqual(machine.parts,['core']);
      });
    });

    describe('machine.capabilities', () => {
      it('debería tener valor { fly: true }', () => {
        Assert.deepEqual(machine.capabilities, { fly: true });
      });
    });
  });

  describe('vehicle', () => {

    it('debería ser un objeto con machine como prototipo', () => {
      Assert.equal(vehicle.__proto__, machine);
    });
  })

  describe('robot', () => {

    it('debería ser un objeto con machine como prototipo', () => {
      Assert.equal(robot.__proto__, machine);
    });
  })

});
",
            },
          },
          "title": "Arreglos y objetos en prototipos",
        },
        "06-object-create": Object {
          "body": "<p>Como comentamos anteriormente, <code>__proto__</code> no es una manera estándar de asignar
prototipos. Una manera más sencilla es usando <code>Object.create()</code>,
disponible en ES5 y para navegadores antiguos podemos usar
<a href=\\"https://github.com/kriskowal/es5-shim\\" target=\\"_blank\\">es5-shim</a>.</p>
<pre><code class=\\"language-js\\">const alien = {
  kind: 'alien'
};

// creamos un nuevo objeto con \`alien\` como prototipo
const zack = Object.create(alien);

console.log(zack.kind); // =&gt; 'alien'
</code></pre>
<p>Podemos pasar un objeto a <code>Object.create</code> para añadir propiedades al nuevo
objeto:</p>
<pre><code class=\\"language-js\\">const zack = Object.create(alien, {age: {value:  13} });
console.log(zack.age); // =&gt; '13'
</code></pre>
<p>Sí, el objeto que tenemos que pasar es un poco complicado, pero así es. Puedes
ver más en la
<a href=\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create\\" target=\\"_blank\\">documentación oficial</a>.</p>
<h2 id=\\"objectgetprototypeof\\"><code>Object.getPrototypeOf</code></h2>
<p>Puedes acceder al prototipo de un objeto usando <code>Object.getPrototypeOf</code>:</p>
<pre><code class=\\"language-js\\">const zack = Object.create(alien);
Object.getPrototypeOf(zack); //=&gt; alien
</code></pre>
<h2 id=\\"objectsetprototypeof\\"><code>Object.setPrototypeOf</code></h2>
<p>A partir de ES2015, también tenemos <code>Object.setPrototypeOf(object, prototype)</code>
como una alternativa oficial para cambiar la propiedad <code>__proto__</code>. Aún así,
no es recomendable alterar el prototipo durante la ejecución ya que es un
proceso lento. Siempre es mejor definir el prototipo <em>antes</em> de crear el objeto,
por ejemplo usando <code>Object.create()</code>.</p>
<h2 id=\\"desafío\\">Desafío</h2>
<p>El 'boilerplate' tiene las instrucciones y los
lugares donde añadir tu código debidamente señalados.</p>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "b2JqZWN0Q3JlYXRlLmpz": "// -> Creamos un objeto llamado \`machine\`
const machine = {};

// -> Usa Object.create para crear otro objeto llamado \`robot\` con \`machine\`
//    como prototipo
__

// -> Usa Object.create para crear otro objeto llamado \`robby\` con \`robot\`
//    como prototipo
__

// -> ¿Cuál es el resultado de \`machine.isPrototypeOf(robby)\`?
claim(machine.isPrototypeOf(robby), __);

// -> ¿Cuál es el resultado de \`robot.isPrototypeOf(robby)\`?
claim(robot.isPrototypeOf(robby), __);

// -> ¿Qué objeto es el prototipo directo de \`robby\`?
claim(Object.getPrototypeOf(robby), __);


// ------------------------------------------------
// Exports de Common JS para verificación, no modificar
module.exports = {
  machine,
  robot,
  robby
}
",
            },
            "c29sdXRpb24=": Object {
              "b2JqZWN0Q3JlYXRlLmpz": "const machine = {}

const robot = Object.create(machine);
const robby = Object.create(robot);

// -> ¿Cuál es el resultado de \`machine.isPrototypeOf(robby)\`?
claim(machine.isPrototypeOf(robby), true);

// -> ¿Cuál es el resultado de \`robot.isPrototypeOf(robby)\`?
claim(robot.isPrototypeOf(robby), true);

// -> ¿Qué objeto es el prototipo directo de \`robby\`?
claim(Object.getPrototypeOf(robby), robot);

// ------------------------------------------------
module.exports = {
	machine,
	robot,
	robby
}
",
            },
            "dGVzdA==": Object {
              "b2JqZWN0Q3JlYXRlLnNwZWMuanM=": "'use strict';


const Assert = require('chai').assert;
const Sinon = require('sinon');
const globalScope = (typeof self !== 'undefined' ? self : global);

const claim = globalScope.claim = (actual, expected) =>
  Array.isArray(expected) || (typeof expected === 'object' && expected instanceof Object) ?
    Assert.deepEqual(actual, expected) :
    Assert.equal(actual,expected);

const spy = Sinon.spy(globalScope, 'claim');
const Submission = require('../solution/objectCreate');
const { machine, robot, robby } = Submission;

describe('objectCreate', () => {

  it('debería exportar un objeto con las propiedades \\"machine\\", \\"robot\\" y \\"robby\\"', () => {
    Assert.equal(typeof Submission, 'object');
    Assert.ok(Submission.hasOwnProperty('machine'));
    Assert.ok(Submission.hasOwnProperty('robot'));
    Assert.ok(Submission.hasOwnProperty('robby'));
  });

  it('debería invocar claim 3 veces', () => {
    Assert.equal(spy.callCount, 3);
  });

  [
    [ true, true ],
    [ true, true ],
    [ {}, {} ]
  ].forEach((args, idx) => {
    describe(\`invocación \${idx + 1} a claim\`, () =>
      it(\`debería comparar \${args[0]} con \${args[1]}\`, () =>
        Assert.deepEqual(spy.getCall(idx).args, args)
      )
    );
  });

  describe('robot', () => {

    it('debería ser un objeto con machine como prototipo', () => {
      Assert.equal(robot.__proto__, machine);
    });
  });

  describe('robby', () => {

    it('debería ser un objeto con machine como prototipo', () => {
      Assert.equal(robby.__proto__.__proto__, machine);
    });

    it('debería ser un objeto con robot como prototipo', () => {
      Assert.equal(robby.__proto__, robot);
    });
  });

})
",
            },
          },
          "title": "Object.create",
        },
        "07-dot-new": Object {
          "body": "<p>Llegado a este punto, sabemos suficiente como para hacer cosas increibles con
objetos en JavaScript.</p>
<h2 id=\\"desafío\\">Desafío</h2>
<ul>
<li>Define un objeto llamado <code>Robot</code></li>
<li>Define un método llamado <code>new</code> en <code>Robot</code></li>
<li>Cuando invocamos <code>Robot.new()</code>, debe retornar un objeto nuevo con <code>Robot</code> como
prototipo. Por ejemplo:</li>
</ul>
<pre><code class=\\"language-js\\">const robby = Robot.new();
// Robot debe ser el prototipo de Robby
</code></pre>
<h2 id=\\"boilerplate\\">Boilerplate</h2>
<p>El 'boilerplate' tiene las instrucciones y los
lugares donde añadir tu código debidamente señalados.</p>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "ZG90TmV3Lmpz": "// -> Define un objeto llamado \`Robot\`
// -> Define un método llamado \`new\` en \`Robot\`
// -> Cuando llamamos a \`Robot.new()\` debe retornar un objeto nuevo con Robot
//    como prototipo
//    Por ejemplo: const robby = Robot.new();
//    \`Robot\` debe ser el prototipo de \`robby\`

__


// ------------------------------------------------
// Exports de Common JS para verificación, no modificar
module.exports = {
  Robot
}
",
            },
            "c29sdXRpb24=": Object {
              "ZG90TmV3Lmpz": "// -> Define un objeto llamado \`Robot\`
// -> Define un método llamado \`new\` en \`Robot\`
// -> Cuando llamamos a \`Robot.new()\` debe retornar un objeto nuevo con Robot
//    como prototipo
//    Por ejemplo: const robby = Robot.new();
//    \`Robot\` debe ser el prototipo de \`robby\`

const Robot = {
	new: function () {
		return Object.create(this);
	}
}

// ------------------------------------------------
// Exports de Common JS para verificación, no modificar
module.exports = {
	Robot
}
",
            },
            "dGVzdA==": Object {
              "ZG90TmV3LnNwZWMuanM=": "'use strict';


const Assert = require('chai').assert;
const Sinon = require('sinon');
const globalScope = (typeof self !== 'undefined' ? self : global);

const claim = globalScope.claim = (actual, expected) =>
  Array.isArray(expected) || (typeof expected === 'object' && expected instanceof Object) ?
    Assert.deepEqual(actual, expected) :
    Assert.equal(actual,expected);

const spy = Sinon.spy(globalScope, 'claim');
const Submission = require('../solution/dotNew');
const { Robot } = Submission;

describe('dotNew', () => {

  it('debería exportar un objeto con las propiedades \\"Robot\\"', () => {
    Assert.equal(typeof Submission, 'object');
    Assert.ok(Submission.hasOwnProperty('Robot'));
  });

  describe('Robot', () => {

    it('debería tener una función llamada \\"new\\"', () => {
      Assert.equal(typeof Robot.new,'function');
    });

    describe('Robot.new', () => {

      it('debería devolver un objeto que tiene como prototipo a Robot',() => {
        Assert.equal(Robot.new().__proto__, Robot);
      });

    });

  });

});
",
            },
          },
          "title": "Nuestro propio 'new'",
        },
        "08-constructor-functions": Object {
          "body": "<p>Los <strong>Constructores</strong> son probablemente la manera más común de implementar
cadenas de prototipos. La popularidad de los constructores se debe a que estos
eran la manera en la que originalmente se construían \\"tipos\\".
Algunos motores están altamente optimizados para usar constructores.</p>
<p>En JavaScript puedes crear un objeto de esta manera:</p>
<pre><code class=\\"language-js\\">function Alien() {
  this.age = 10;
}

const zippy = new Alien();
</code></pre>
<p>Cuando usamos funciones con la palabra clave <code>new</code>, se comportan de una manera
un tanto especial; crean objetos. El nuevo objeto creado se vincula a la función
a través del prototipo (más sobre esto más adelante). Así que en JavaScript, a
estos objetos creados por constructores los llamamos una <strong>instancia</strong> de la
función.</p>
<pre><code class=\\"language-js\\">// zippy is an instance of Alien
console.log(zippy instanceof Alien); //=&gt; true
</code></pre>
<h2 id=\\"desafío\\">Desafío</h2>
<p>El 'boilerplate' tiene las instrucciones y los
lugares donde añadir tu código debidamente señalados.</p>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "Y29uc3RydWN0b3JGdW5jdGlvbnMuanM=": "// -> Define un constructor 'Robot'
// -> Dentro de la función \`Robot\` asigna una propiedad 'motors' en 'this',
//    y dale el valor \`2\` a \`motors\`
// -> Crear una instancia de \`Robot\` llamada \`robby\`

__

// -> ¿Cuál es el resultado de \`(robby instanceof Robot)\`?
claim(robby instanceof Robot, __);

// -> ¿Qué valor tiene \`robby.motors\`?
claim(robby.motors, __);


// ------------------------------------------------
// Exports de Common JS para verificación, no modificar
module.exports = {
  Robot,
  robby
}
",
            },
            "c29sdXRpb24=": Object {
              "Y29uc3RydWN0b3JGdW5jdGlvbnMuanM=": "// -> Define un constructor 'Robot'
// -> Dentro de la función \`Robot\` asigna una propiedad 'motors' en 'this',
//    y dale el valor \`2\` a \`motors\`
// -> Crear una instancia de \`Robot\` llamada \`robby\`

function Robot() {
	this.motors = 2;
};

const robby = new Robot();

// -> ¿Cuál es el resultado de \`(robby instanceof Robot)\`?
claim(robby instanceof Robot, true);

// -> ¿Qué valor tiene \`robby.motors\`?
claim(robby.motors, 2);

// ------------------------------------------------
// Exports de Common JS para verificación, no modificar
module.exports = {
	Robot,
	robby
}
",
            },
            "dGVzdA==": Object {
              "Y29uc3RydWN0b3JGdW5jdGlvbnMuc3BlYy5qcw==": "'use strict';


const Assert = require('chai').assert;
const Sinon = require('sinon');
const globalScope = (typeof self !== 'undefined' ? self : global);

const claim = globalScope.claim = (actual, expected) =>
  Array.isArray(expected) || (typeof expected === 'object' && expected instanceof Object) ?
    Assert.deepEqual(actual, expected) :
    Assert.equal(actual,expected);

const spy = Sinon.spy(globalScope, 'claim');
const Submission = require('../solution/constructorFunctions');
const { Robot, robby } = Submission;

describe('objectCreate', () => {

  it('debería exportar un objeto con las propiedades \\"Robot\\", \\"robby\\"', () => {
    Assert.equal(typeof Submission, 'object');
    Assert.ok(Submission.hasOwnProperty('Robot'));
    Assert.ok(Submission.hasOwnProperty('robby'));
  });

  it('debería invocar claim 2 veces', () => {
    Assert.equal(spy.callCount, 2);
  });

  [
    [ true, true ],
    [ 2, 2 ]
  ].forEach((args, idx) => {
    describe(\`invocación \${idx + 1} a claim\`, () =>
      it(\`debería comparar \${args[0]} con \${args[1]}\`, () =>
        Assert.deepEqual(spy.getCall(idx).args, args)
      )
    );
  });

  describe('Robot', () => {

    it('debería ser un constructor', () => {
      Assert.equal(typeof Robot,'function');
    });

  });

  describe('robby', () => {

    it('debería ser una una instancia de robot',() => {
      Assert.equal(robby.__proto__,new Robot().__proto__);
    });

    it('debería tener una propiedad motors con valor 2', () => {
      Assert.equal(robby.motors,2);
    });

  });


});
",
            },
          },
          "title": "Constructores",
        },
        "09-implicit-this": Object {
          "body": "<p>Cuando usamos <code>new</code> con una función, JavaScript inyecta una referencia implícita
al nuevo objeto creado a través de la pseudo-variable <code>this</code>.
Además, retorna esta referencia implícitamente al final de la función.</p>
<p>Cuando hacemos esto:</p>
<pre><code class=\\"language-js\\">function Alien() {
  this.kind = 'alien';
}

const zippy = new Alien();
zippy.kind; //=&gt; 'alien'
</code></pre>
<p>Detrás de las cortinas JavaScript hace algo como:</p>
<pre><code class=\\"language-js\\">function Alien() {
  var this = {}; // no es JavaScript válido, sólo para ilustrar el concepto
  this.__proto__ = Alien.prototype;

  this.kind = 'alien';

  return this;
}
</code></pre>
<p>Hay que estar atentos al hecho que <code>this</code> sólo se asigna implícitamente al
nuevo objeto cuando usamos el keyword <code>new</code>. Si te olvidas de poner <code>new</code>, la
pseudo-variable <code>this</code> será una referencia al objeto global. Esto hace que <code>new</code>
sea una causa común de errores, así que no te olvides de usar <code>new</code> cuando sea
necesario.</p>
<p>Una convención popular es poner la primera letra en mayúscula al nombrar la
función (por ejemplo <code>Alien</code>), así resulta más fácil identificar el hecho de que
la función debe ser llamada con <code>new</code>.</p>
<h2 id=\\"desafío\\">Desafío</h2>
<p>El 'boilerplate' tiene las instrucciones y los
lugares donde añadir tu código debidamente señalados.</p>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "aW1wbGljaXRUaGlzLmpz": "// -> Define dos constructores: 'Robot' y 'Vehicle'
// -> Cuando \`Robot\` se invoque con 'new' debe retornar el 'this' implícito
// -> Cuando \`Vehicle\` se invoque con 'new', debe retornar un objeto cualquiera,
//    no el 'this' implícito.

__


// ------------------------------------------------
// Exports de Common JS para verificación, no modificar
module.exports = {
  Robot,
  Vehicle
}
",
            },
            "c29sdXRpb24=": Object {
              "aW1wbGljaXRUaGlzLmpz": "// -> Define dos constructores: 'Robot' y 'Vehicle'
// -> Cuando \`Robot\` se invoque con 'new' debe retornar el 'this' implícito
// -> Cuando \`Vehicle\` se invoque con 'new', debe retornar un objeto cualquiera,
//    no el 'this' implícito.

function Robot() {

}

function Vehicle() {
	return {};
}

// ------------------------------------------------
// Exports de Common JS para verificación, no modificar
module.exports = {
	Robot,
	Vehicle
}
",
            },
            "dGVzdA==": Object {
              "aW1wbGljaXRUaGlzLnNwZWMuanM=": "'use strict';


const Assert = require('chai').assert;
const Sinon = require('sinon');
const globalScope = (typeof self !== 'undefined' ? self : global);

const claim = globalScope.claim = (actual, expected) =>
  Array.isArray(expected) || (typeof expected === 'object' && expected instanceof Object) ?
    Assert.deepEqual(actual, expected) :
    Assert.equal(actual,expected);

const spy = Sinon.spy(globalScope, 'claim');
const Submission = require('../solution/implicitThis');
const { Robot, Vehicle } = Submission;

describe('implicitThis', () => {

  it('debería exportar un objeto con las propiedades \\"Robot\\", \\"Vehicle\\"', () => {
    Assert.equal(typeof Submission, 'object');
    Assert.ok(Submission.hasOwnProperty('Robot'));
    Assert.ok(Submission.hasOwnProperty('Vehicle'));
  });

  describe('Robot', () => {

    it('debería ser un constructor', () => {
      Assert.equal(typeof Robot,'function');
    });

    describe('new Robot', () => {

      it('debería retornar una instancia de robot', () => {
        const robot = new Robot();
        Assert.equal(robot instanceof Robot,true);
      })
    })

  });

  describe('Vehicle', () => {

    it('debería ser un constructor', () => {
      Assert.equal(typeof Vehicle, 'function');
    });

    describe('new Vehicle', () => {

      it('no debería retornar una instancia de Vehicle', () => {
        const vehicle = new Vehicle();
        Assert.equal(vehicle instanceof Vehicle, false);
      });

    });


  });


});
",
            },
          },
          "title": "'this' se asigna implícitamente",
        },
        "10-function-prototype": Object {
          "body": "<p>Toda función en JavaScript tiene una propiedad especial llamada <code>prototype</code>.</p>
<pre><code class=\\"language-js\\">function Alien() {}

Alien.prototype;
</code></pre>
<p>Aunque parezca confuso, esta propiedad <code>prototype</code> no es el prototipo real
(<code>__proto__</code>) de la función.</p>
<pre><code class=\\"language-js\\">Alien.__proto__ === Alien.prototype; //=&gt; false
</code></pre>
<p>Esto obviamente genera mucha confusión a la hora de usar el término \\"prototipo\\"
para refererirnos a cosas diferentes.</p>
<p>Una buena acalaración es siempre usar '<strong>prototipo de función</strong>' para
refererirnos a este <code>prototype</code> especial, y nunca simplemente \\"prototype\\".</p>
<p>Este <code>prototype</code> apunta al objeto que será asignado como el prototipo de
instancias creadas con la función (el constructor) cuando se use con <code>new</code>.</p>
<p>Confundida? Veamos un ejemplo:</p>
<pre><code class=\\"language-js\\">function Alien(name) {
  this.name = name;
}

// la función Alien tiene una propiedad prototype
// podemos añadir propiedades al prototipo de la función
Alien.prototype.kind = 'alien';

// creamos un objeto usando \`new\`
var zippy = new Alien('Zippy');

// el __proto__ del nuevo objeto apunta a Alien.prototype
zippy.__proto__ == Alien.prototype; //=&gt; true

// en el nuevo objeto tenemos acceso a las propiedades definidas en Alien.prototype
zippy.kind; //=&gt; alien
</code></pre>
<p>Acá puedes ver un <a href=\\"https://docs.google.com/drawings/d/1AKJcvxs0t3iGtqkRV8rFAWlo7tojkOSwjfhr1NWaTb0/pub?w=889&amp;h=482\\" target=\\"_blank\\">diagrama que muestra esta relación</a>.</p>
<p>Así que si tienes dos instancias de <code>Alien</code>, ambas recibirán <code>Alien.prototype</code>
como su <code>__proto__</code>. Lo que pongas ahí será compartido por todas las instancias.</p>
<p>Esto es casi todo lo que hay que saber sobre el \\"JavaScript object model\\".
Entender cómo se relacionan <code>__proto__</code> y <code>function.prototype</code> te dará
incontables momentos de alegría y satisfacción. O quizás no ;-)</p>
<h2 id=\\"desafío\\">Desafío</h2>
<p>El 'boilerplate' tiene las instrucciones y los
lugares donde añadir tu código debidamente señalados.</p>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "ZnVuY3Rpb25Qcm90b3R5cGUuanM=": "// -> Define un constructor 'Robot'
// -> Crea dos instancias de Robot: 'robby' y 'cranky'
// -> Tanto robby como cranky deben tener 'parts' y 'capabilities', éstas deben
//    ser arrays vacíos al inicio

__

// -> ¿Cúal es el resultado de robby.parts?
claim(robby.parts, __);
// -> ¿Cúal es el resultado de cranky.parts?
claim(cranky.parts, __);
// -> ¿Cúal es el resultado de robby.capabilities?
claim(robby.capabilities, __);
// -> ¿Cúal es el resultado de cranky.capabilities?
claim(cranky.capabilities, __);

// -> Añade 'core' a robby.parts, cranky.parts debería tener todavía un arreglo vacío
// -> Añade 'fly' a robby.capabilities, después de esto cranky.capabilities debe
//    también tener 'fly' sin añadírselo directamente, así que esta propiedad
//    debe ser compartida.

__

// -> ¿Cúal es el resultado de robby.parts?
claim(robby.parts, __);
// -> ¿Cúal es el resultado de cranky.parts?
claim(cranky.parts, __);
// -> ¿Cúal es el resultado de robby.capabilities?
claim(robby.capabilities, __);
// -> ¿Cúal es el resultado de cranky.capabilities?
claim(cranky.capabilities, __);


// ------------------------------------------------
// Exports de Common JS para verificación, no modificar
module.exports = {
  Robot,
  robby,
  cranky
}
",
            },
            "c29sdXRpb24=": Object {
              "ZnVuY3Rpb25Qcm90b3R5cGUuanM=": "// -> Define un constructor 'Robot'
// -> Crea dos instancias de Robot: 'robby' y 'cranky'
// -> Tanto robby como cranky deben tener 'parts' y 'capabilities', éstas deben
//    ser arrays vacíos al inicio
function Robot() {
	this.parts = [];
}

Robot.prototype.capabilities = [];

var robby = new Robot();
var cranky = new Robot();

// -> ¿Cúal es el resultado de robby.parts?
claim(robby.parts, []);
// -> ¿Cúal es el resultado de cranky.parts?
claim(cranky.parts, []);
// -> ¿Cúal es el resultado de robby.capabilities?
claim(robby.capabilities, []);
// -> ¿Cúal es el resultado de cranky.capabilities?
claim(cranky.capabilities, []);

// -> Añade 'core' a robby.parts, cranky.parts debería tener todavía un arreglo vacío
// -> Añade 'fly' a robby.capabilities, después de esto cranky.capabilities debe
//    también tener 'fly' sin añadírselo directamente, así que esta propiedad
//    debe ser compartida.
robby.parts.push('core');
robby.capabilities.push('fly');

// -> ¿Cúal es el resultado de robby.parts?
claim(robby.parts, ['core']);
// -> ¿Cúal es el resultado de cranky.parts?
claim(cranky.parts, []);
// -> ¿Cúal es el resultado de robby.capabilities?
claim(robby.capabilities, ['fly']);
// -> ¿Cúal es el resultado de cranky.capabilities?
claim(cranky.capabilities, ['fly']);

// ------------------------------------------------
// Exports de Common JS para verificación, no modificar
module.exports = {
	Robot,
	robby,
	cranky
}
",
            },
            "dGVzdA==": Object {
              "ZnVuY3Rpb25Qcm90b3R5cGUuc3BlYy5qcw==": "'use strict';


const Assert = require('chai').assert;
const Sinon = require('sinon');
const globalScope = (typeof self !== 'undefined' ? self : global);

const claim = globalScope.claim = (actual, expected) =>
  Array.isArray(expected) || (typeof expected === 'object' && expected instanceof Object) ?
    Assert.deepEqual(actual, expected) :
    Assert.equal(actual,expected);

const spy = Sinon.spy(globalScope, 'claim');
const Submission = require('../solution/functionPrototype');
const { Robot, robby, cranky } = Submission;

describe('functionPrototype', () => {

  it('debería exportar un objeto con las propiedades \\"Robot\\", \\"robby\\", \\"cranky\\" ', () => {
    Assert.equal(typeof Submission, 'object');
    Assert.ok(Submission.hasOwnProperty('Robot'));
    Assert.ok(Submission.hasOwnProperty('robby'));
    Assert.ok(Submission.hasOwnProperty('cranky'));
  });

  describe('Robot',() => {

    it('debería ser una función', () => {
      Assert.isFunction(Robot);
    });

    it('debería tener una instancia de parts', () => {
      const other = new Robot();
      Assert.isDefined(other.parts);
    });

    it('debería tener una instancia de capabilities', () => {
      const other = new Robot();
      Assert.isDefined(other.capabilities);
    });

    it('debería comenzar vacío',() => {
      const other = new Robot();
      Assert.equal(other.parts.length,0);
    });

    describe('Robot.parts',() => {

      it('debería ser un array', () => {
        const other = new Robot();
        Assert.isArray(other.parts);
      })
    });

    describe('Robot.capabilities',() => {

      it('debería ser un array', () => {
        const other = new Robot();
        Assert.isArray(other.capabilities);
      });
    });

  });

  describe('robby',() => {

    it ('debería ser una instancia de Robot',() => {
      Assert.instanceOf(robby, Robot);
    });

    it('debería tener un elemento', () => {
      Assert.equal(robby.parts.length, 1);
    });

    it('debería tener un elemento que sea \\"core\\"', () => {
      Assert.equal(robby.parts[0],'core');
    });

    describe('robby.capabilities', () => {

      it ('debería tener un elemento', () => {
        Assert.equal(robby.capabilities.length, 1);
      });

      it('Su primer elemento debería ser \\"fly\\"', () => {
        Assert.equal(robby.capabilities[0],'fly');
      });
    });

  });

  describe('cranky',() => {

    it ('debería ser una instancia de Robot',() => {
      Assert.instanceOf(cranky, Robot);
    });

    describe('cranky.parts', () => {

      it('debería tener 0 elementos', () => {
        Assert.equal(cranky.parts.length, 0);
      });

    });

    describe('cranky.capabilities', () => {

      it('no esta agregado directamente a cranky', () => {
        Assert.isFalse(cranky.hasOwnProperty('capabilities'));
      });

      it('debería tener un elemento', () => {
        Assert.equal(cranky.capabilities.length, 1);
      });

      it('Su primer elemento debería ser \\"fly\\"', () => {
        Assert.equal(cranky.capabilities[0],'fly');
      });

    })
  });


});
",
            },
          },
          "title": "Prototipos de funciones",
        },
      },
      "format": "self-paced",
      "title": "Ejercicios",
      "type": "practice",
    },
    "06-closing": Object {
      "body": "<h2 id=\\"resumen\\">Resumen</h2>
<p><code>this</code> es una pseudo-variable que existe dentro de las funciones. El valor de
<code>this</code> debe ser <em>inferido</em> del contexto donde aparece, y por eso puede ser
motivo de confusión.</p>
<p>El método <code>bind</code> de las funciones nos permite crear una nueva versión de la
función pero con <code>this</code> seteado a un valor específico.</p>
<p>Cuando usamos una función como un <em>método</em> de un objeto, <code>this</code> toma el valor
del objeto que contiene al <em>método</em>.</p>
<p>También podemos usar constructores para crear objetos con un prototipo
específico, así como <code>Object.create</code>.</p>
<p>El operador <code>instanceof</code> nos permite determinar si un objeto fue creado con un
constructor específico y <code>Object.prototype.isPrototypeOf</code> para determinar si un
objeto está la cadena de prototipos de otro objeto.</p>
<p>Todo objeto tiene un prototipo, que a su vez es un objeto que puede tener su
propio prototipo. Esto crea lo que llamamos <strong>cadena de prototipos</strong> y nos
permite implementar herencia.</p>
<h2 id=\\"respondamos-juntxs-las-preguntas-de-la-apertura\\">Respondamos juntxs las preguntas de la apertura</h2>
<ul>
<li>Qué valor toma <code>this</code> cuando no puede ser inferido por el contexto?</li>
<li>Qué hace el método <code>bind</code> que tienen todas las funciones?</li>
<li>Cómo infiere JavaScript el valor de <code>this</code> dentro de una función?</li>
<li>Qué es un <strong>constructor</strong>?</li>
<li>Cómo usar <code>new</code> para crear instancias de un constructor?</li>
<li>Cómo usar <code>instanceof</code> para determinar si un objeto fue creado con un
constructor específico?</li>
<li>Cómo usar <code>Object.prototype.isPrototypeOf</code> para determinar si un objeto está
la cadena de prototipos de otro objeto?</li>
<li>Cómo añadir propiedades al prototipo de un constructor usando <code>Function.prototype</code>?</li>
<li>Cómo usar <code>Object.create</code> para crear objetos con un prototipo específico?</li>
<li>Cómo implementar <strong>herencia prototipal</strong>?</li>
</ul>
",
      "duration": 5,
      "format": "self-paced",
      "title": "Cierre",
      "type": "read",
    },
  },
  "06-composition": Object {
    "00-opening": Object {
      "body": "<h2 id=\\"¿por-qué-aprender-esto\\">¿Por qué aprender esto?</h2>
<p>Como parte de los paradigmas de programación, veremos <strong>composición</strong>. Para
esto, emprenderemos un camino visitando cierto conceptos fundamentales, que a lo
largo de esta lección nos darán nociones claras de ¿qué es?, ¿para qué sirve? y
¿cómo se utiliza? la <strong>composición</strong>.</p>
<p>Como vimos en la lección anterior, revisamos los conceptos que definen la
<strong>P</strong>rogramación <strong>O</strong>rientada a <strong>O</strong>bjetos (POO), y como vimos, ésta nos
permite modelar el comportamiento de ciertos elementos del mundo real, en otras
palabras, respondimos la pregunta \\"¿qué son?\\", utilizando propiedades y acciones
para definir su comportamiento. En cambio con la <strong>composición</strong>, y a medida que
avanzamos en esta lección será más claro, modelamos \\"qué hacen\\", definiendo sus
métodos/acciones por medio de las <strong>funciones</strong>.</p>
<p>Es por esto, que revisaremos algunos conceptos asociados a la programación
funcional. Analizaremos las diferencias entre <strong>composición</strong> y <strong>herencia</strong>,
ventajas y desventajas de este nuevo paradigma; y revisaremos ejemplos concretos
donde se verá aplicado este nuevo paradigma.</p>
<p>Al final de esta unidad, habremos aprendido una nueva técnica de programación,
que nos permitirá crear y mantener mejor código y que además tendremos en
nuestra caja de herramientas, para utilizar en nuestros futuros proyectos.</p>
<h2 id=\\"guía-de-preguntas-y-conceptos-clave\\">Guía de preguntas y conceptos clave</h2>
<p>Cuando empezamos a estudiar un tema nuevo, es útil tener una idea de los
conceptos más importantes de lo que vamos a aprender y de los temas centrales
que debemos prestar particular atención.</p>
<p>A continuación te presentamos una serie de preguntas que debes ser capaz de
responder al terminar esta unidad. Utiliza estas preguntas como guía para
orientar tus esfuerzos de aprendizaje. Regresa a ellas constantemente a medida
que avanzas para validar que estás avanzando en la dirección correcta. Que te
sirva como un \\"checklist\\" que vas marcando a medida que vas progresando.</p>
<ul>
<li>Principios básicos de la <strong>programación funcional</strong>.</li>
<li>Cómo usar <strong>composición</strong> como alternativa a la <em>herencia</em>.</li>
<li><code>Object.assign</code>.</li>
<li>Qué beneficios tienen las <strong>Factories</strong>.</li>
<li>Cómo beneficiarse del <strong>Clousure</strong>.</li>
</ul>
",
      "duration": 5,
      "format": "self-paced",
      "title": "Apertura",
      "type": "read",
    },
    "01-closures": Object {
      "body": "<p>Para poder entender las funciones <em>factory</em> y el mecanismo de composición de
objetos que vamos ver más adelante, es esencial sentirse cómoda con el concepto
de <em>closure</em>.</p>
<p>En JavaScript las <em>funciones</em> no son sólo \\"funciones\\", también son <em>closures</em>.
Esto quiere decir que cuando declaramos una función, el cuerpo de la función
tiene acceso al scope dónde se declaró la funcíon además de su scope local.
<em>Closure</em> significa que las funciones se \\"cierran\\" alrededor de las variables a
las que tiene acceso. Por lo tanto, una función creada dentro de otra función
tiene acceso a las variables del scope de la función que la envuelve, incluso
después de que ésta haya retornado. Considera el siguiente snippet:</p>
<pre><code class=\\"language-js\\">const makeFunction = function () {
  var foo = true;
  return function () {
    return foo;
  };
};

var myFunc = makeFunction();
myFunc(); // true
</code></pre>
<p>En el ejemplo de arriba podemos ver que <code>makeFunction</code> es una función anónima
que retorna otra función anónima, y ésta última todavía tiene acceso a <code>foo</code>
(una variable local de <code>makeFunction</code>) después de que <code>makeFunction</code> ya ha
retornado.</p>
<p>Los closures son un \\"feature\\" muy poderoso y nos van a permitir crear scopes
\\"privados\\" (sólo visibles para aquellas funciones creadas dentro de un scope
compartido.</p>
<p>Esto no sólo se aplica a variables declaradas dentro del scope, sino a todas las
variables \\"visibles\\" dentro de ese scope, incluyendo los argumentos de
invocación.</p>
<pre><code class=\\"language-js\\">// una función que crea un objeto, y sus métodos tienen acceso a los argumentos
// con los que se invocó la función que creó el objeto.
const createNote = text =&gt; ({
  print: () =&gt; console.log(text)
});

const note = createNote('lorem ipsum')
note.print() // Outputs: \\"lorem ipsum\\"


// una función que hace referencia a una variable declarada fuera de su scope
let name = 'Lupo';
function say() {
  console.log('Hola soy ' + name);
}
say(); // \\"Hola soy Lupo\\"
name = 'Pedro Picapiedra';
say(); // \\"Hola soy Pedro Picapiedra\\"
</code></pre>
<p>En un lenguaje sin \\"closures\\", a la hora de invocar <code>say()</code> en este ejemplo,
tendríamos que haber explícitamente pasado <code>name</code> como argumento. En JavaScript
la función <code>say()</code> tiene acceso al contexto exterior, incluso si invocáramos la
función desde otro lugar, o como un callback de una operación asíncrona, siempre
va a recordar ese contexto exterior (outer scope) y puede hacer referencia a él.</p>
<p>Pero... por qué, para qué? Veamos un ejemplo.</p>
<pre><code class=\\"language-js\\">function fetchData() {
  var reqId = 123;
  $.get('/some-url', function () {
    alert('Request ' + reqId + ' completed');
  });
}
</code></pre>
<p>En el código de arriba la función <code>fetchData()</code> va a hacer una llamada AJAX
(usando jQuery), y cuando la llamada retorna (esto ocurre después de que
<code>fetchData</code> haya retornado) el callback todavía tiene acceso a <code>reqId</code>. Esto es
muy útil a la hora programar operaciones asíncronas, ente otras cosas.</p>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Capítulos de libros:</p>
<ul>
<li><a href=\\"http://eloquentjavascript.net/03_functions.html\\" target=\\"_blank\\">Eloquent JavaScript - Chapter 3: Functions</a></li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\\" target=\\"_blank\\">MDN - Closures</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\\" target=\\"_blank\\">MDN - Function</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\\" target=\\"_blank\\">MDN - Arrow functions</a></li>
</ul>
",
      "duration": 3,
      "format": "self-paced",
      "title": "Closures",
      "type": "read",
    },
    "02-factories": Object {
      "body": "<p>Las <code>factories</code> o <code>factory functions</code> son simplemente funciones que crean
objetos. Podemos usar factories como alternativa a los constructores, siendo más
simples y por la tanto más fácil visualizar lo que hacen. Nada de <code>this</code>, <code>new</code>
o <code>Function.prototype</code>. En la lección anterior vimos una función <code>createNote</code>
que creaba un objeto. Era una factory!</p>
<pre><code class=\\"language-js\\">const createNote = text =&gt; ({
  text,
  createdAt: new Date(),
  completed: false
});
</code></pre>
<p>Esta función es muy sencilla, pero comparada al constructor <code>Note</code>, que también
vimos en la lección pasada, le falta añadir la funcionalidad que le habíamos
añadido a los objetos creados con <code>Note</code> a través de <code>Note.prototype</code> (habíamos
añadido un método <code>Note.prototype.toString</code>). Para solventar esto, podríamos
añadir el método <code>toString</code> directamente sobre la instancia que retorna nuestro
factory:</p>
<pre><code class=\\"language-js\\">const createNote = text =&gt; ({
  text,
  createdAt: new Date(),
  completed: false,
  toString: () =&gt; {}
});
</code></pre>
<p>Pero, cómo hacemos referencia a <code>createdAt</code> y <code>completed</code> desde <code>toString</code>?
Closures al rescate!</p>
<pre><code class=\\"language-js\\">const createNote = text =&gt; {
  let createdAt = new Date();
  let completed = false;

  return {
    text,
    createdAt,
    completed,
    toString: () =&gt; '[' + (completed ? 'X' : ' ') + '] | ' +
      createdAt.toDateString() + ' | ' + text
  }
};

console.log(createNote('hahah').toString());
// [ ] | Sat Jul 01 2017 | hahah
</code></pre>
<p>Esta nueva implementación hace uso de un closure para dar acceso a <code>text</code>,
<code>createdAt</code> y <code>completed</code> a todos los métodos del objeto que crea nuestra
factory.</p>
<p>Vayamos un paso más allá. Cuando usábamos constructores resultaba cómodo tener
las propiedades del objeto creado disponibles en <code>this</code>, de esa manera
compartíamos \\"estado\\" entre los métodos de nuestro objeto. Organicemos el
\\"estado\\" de nuestra nota en un objeto, y ahora sólo expongamos métodos en el
objeto que retorna nuestra factory. Esto nos va a permitir esconder esta data
y tratarla como privada. Esto es una gran ventaja con respecto a los
constructores, ya que nos permite decidir qué data queremos que se pueda acceder
y cómo.</p>
<pre><code class=\\"language-js\\">const createNote = text =&gt; {
  const state = {
    text,
    createdAt: new Date(),
    completed: false
  };

  return {
    complete: bool =&gt; typeof bool !== 'undefined' ?
      state.completed = !!bool : state.completed,
    toString: () =&gt; '[' + (state.completed ? 'X' : ' ') + '] | ' +
      state.createdAt.toDateString() + ' | ' + state.text
  };
};

const note = createNote('comprar arroz');

console.log(note.complete()); // false
console.log(note.complete(true)); // true
console.log(note.complete()); // true

console.log(note.toString());
// [X] | Sat Jul 01 2017 | comprar arroz
</code></pre>
<p>En esta nueva versión el objeto retornado por <code>createNote</code> tiene los métodos
<code>complete()</code>, que nos permite marcar la nota como completada y comprobar si está
completada, y <code>toString()</code>, sin necesidad de exponer sus estado interno, lo cual
puede ser muy útil además de resultar en <em>interfaces</em> más limpias.</p>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Videos:</p>
<ul>
<li>Playlist: <a href=\\"https://www.youtube.com/playlist?list=PL0zVEGEvSaeHBZFy6Q8731rcwk0Gtuxub\\" target=\\"_blank\\">Object Creation in JavaScript</a>,
<code>aprox. 3h</code>, <a href=\\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\\" target=\\"_blank\\">funfunfunction</a>,
2016</li>
</ul>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\\" target=\\"_blank\\">MDN - Arrow functions</a></li>
</ul>
",
      "duration": 5,
      "format": "self-paced",
      "title": "Factories",
      "type": "read",
    },
    "03-object-assign": Object {
      "body": "<p>Llegado a este punto, probablemente te estés preguntando cómo podemos acceder
ahora a <code>text</code> y <code>createdAt</code>. En nuestro caso, estas propiedades no necesitan
ser \\"privadas\\", así que vamos a \\"exponerlas\\". Para ello, en vez de exponerlas
directamente sobre el objeto, vamos a añadir un método que nos de una \\"copia\\"
del estado, y así asegurar la immutabilidad del estado desde afuera. Vamos a
llamar a éste nuevo método <code>toJSON</code>.</p>
<pre><code class=\\"language-js\\">const createNote = text =&gt; {
  const state = {
    text,
    createdAt: new Date(),
    completed: false
  };

  return {
    complete: bool =&gt; typeof bool !== 'undefined' ?
      state.completed = !!bool : state.completed,
    toString: () =&gt; '[' + (state.completed ? 'X' : ' ') + '] | ' +
      state.createdAt.toDateString() + ' | ' + state.text,
    toJSON: () =&gt; Object.assign({}, state)
  };
};

const note = createNote('comprar arroz');
console.log(note.toJSON());
</code></pre>
<p>En la consola deberías de ver algo así:</p>
<pre><code class=\\"language-text\\">{ text: 'comprar arroz',
  createdAt: 2017-07-01T07:06:24.345Z,
  completed: false }
</code></pre>
<p>En la implementación de <code>toJSON</code> hemos usado <code>Object.assign()</code>. Esto significa
que retornamos un nuevo objeto, al cual le hemos copiado todas las propiedades
de <code>state</code>. <code>Object.assign(destino, fuente1, fuente2, ... fuenteN)</code> se utiliza
para copiar los valores de todas la <em>propiedades enumerables</em> de uno o más
objetos fuente a un objeto destino, y retorna el objeto destino. Esto nos
permite fácilmente \\"mezclar\\" objetos o simplemente copiar un objeto.</p>
<pre><code class=\\"language-js\\">const obj = { foo: 'bar', baz: true };
const objCopy = Object.assign({}, obj);
console.log(objCopy); // { foo: 'bar', baz: true }

objCopy.foo = 'aaaa';
console.log(objCopy); // { foo: 'aaaa', baz: true } MODIFICADO!
console.log(obj); // { foo: 'bar', baz: true } NO MODIFICADO!

// como comparación, en el caso de los arrays usamos \`Array#slice\` para esto
const arr = [1, 2, 3];
const arrCopy = arr.slice(0);
console.log(arrCopy); // [1, 2, 3]

arrCopy.push(4);
console.log(arrCopy); // [1, 2, 3, 4] MODIFICADO!
console.log(arr); // [1, 2, 3] NO MODIFICADO!
</code></pre>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Otros recursos:</p>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\\" target=\\"_blank\\">MDN - Object.assign</a></li>
</ul>
",
      "duration": 5,
      "format": "self-paced",
      "title": "Object.assign()",
      "type": "read",
    },
    "04-composition-over-inheritance": Object {
      "body": "<p>Por lo general, a la hora de \\"diseñar\\" programas tratamos de favorecer la
composición con respecto a la herencia. El motivo principal es la flexibilidad
de no estar amarrado a una jerarquía rígida de herencia, que además debe existir
desde el principio del desarrollo, a veces obligándonos a modelar un problema
que todavía no conocemos.</p>
<p>La composición se concentra en la \\"funcionalidad\\", los métodos que implementa
un objeto, y para ello en vez de heredar, simplemente \\"tenemos\\" otros objetos
a partir de los cuales vamos a componer una nueva interfaz.</p>
<p>En programación funcional tratamos de evitar el estado compartido, y para ello
normalmente vamos a enviar todo lo que necesitemos explícitamente como
argumentos.</p>
<p>Ahora que hemos abstraido el estado a un objeto y ya conocemos
<code>Object.assign()</code>, podemos descomponer nuestra implementación de <code>createNote</code> en
diferentes funciones puras, cada una responsable de una parte de la
funcionalidad, y así poder componer nuestro objeto a partir de varios objetos.</p>
<pre><code class=\\"language-js\\">const serializer = state =&gt; ({
  toString: _ =&gt; '[' + (state.completed ? 'X' : ' ') + '] | ' +
    state.createdAt.toDateString() + ' | ' + state.text,
  toJSON: _ =&gt; Object.assign({}, state)
});

const completer = state =&gt; ({
  complete: bool =&gt; typeof bool !== 'undefined' ?
    state.completed = !!bool : state.completed
});

const createNote = text =&gt; {
  const state = {
    text,
    createdAt: new Date(),
    completed: false
  };
  return Object.assign({}, completer(state), serializer(state));
};

const note = createNote('comprar arroz');

console.log(note);
console.log(note.complete()); // false
console.log(note.complete(true)); // true
console.log(note.complete()); // true

console.log(note.toString());
console.log(note.toJSON());
</code></pre>
<p>Continuando el paralelo con herencia prototipal, implementemos ahora una función
que cree objetos que extiendan la funcionalidad de nuestras notas:</p>
<pre><code class=\\"language-js\\">const createImageNote = url =&gt; {
  const note = createNote('an image');
  return Object.assign({}, note, {
    toString: () =&gt; note.toString() + ' | ' + url,
    toJSON: () =&gt; Object.assign(note.toJSON(), { url: url })
  });
};


const imageNote = createImageNote('http://foo.com/bar.png');

console.log(imageNote.complete()); // false
console.log(imageNote.complete(true)); // true
console.log(imageNote.complete()); // true

console.log(imageNote.toString());
console.log(imageNote.toJSON());
</code></pre>
<p>La función <code>createImageNote</code> simplemente usa un objeto creado con <code>createNote</code>
internamente (<code>note</code>) y de ahí reemplaza los métodos <code>toString</code> y <code>toJSON</code>, los
cuales a su vez hacen uso de los métodos de <code>note</code>.</p>
<p>Nótese que podríamos usar muchos otros objetos con los componer la interfaz de
los objetos creados con <code>createImageNote</code>. No estamos limitados a heredar de
un sólo objeto (o jerarquía de objetos).</p>
<p>Como conclusión, la mayor diferencia entre composición y herencia es que cuando
pensamos en herencia nos concentramos en \\"qué\\" es un objeto, a qué familia
pertenece, mientreas que cuando usamos composición nos centramos en qué
funcionalidad implementa. En herencia pensamos en \\"qué es un objeto\\" (es un X),
mientras que en composición pensamos en \\"lo que tiene\\", independientemente de
cadenas de herencia. De esta forma, usando composición tenemos mucho más
flexibilidad a la hora de \\"componer\\" objetos, ya que no estamos amarrados a una
jerarquía de herencia que quizás nos obligue a heredar funcionalidad que no
necesitamos además de no permitirnos heredar de jerarquías separadas.</p>
<hr>
<h2 id=\\"referencias\\">Referencias</h2>
<p>Videos:</p>
<ul>
<li>Playlist: <a href=\\"https://www.youtube.com/playlist?list=PL0zVEGEvSaeHBZFy6Q8731rcwk0Gtuxub\\" target=\\"_blank\\">Object Creation in JavaScript</a>,
<code>aprox. 3h</code>, <a href=\\"https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q\\" target=\\"_blank\\">funfunfunction</a>,
2016</li>
</ul>
",
      "duration": 10,
      "format": "self-paced",
      "title": "Composition over inheritance",
      "type": "read",
    },
    "05-exercises": Object {
      "duration": 90,
      "exercises": Object {
        "01-hof": Object {
          "body": "<p>Una función de orden superior (higher-order function) es una función que cumple
por lo menos una de estas condiciones:</p>
<ul>
<li>Recibe una o más funciones como input</li>
<li>Devuelve una función</li>
</ul>
<p>Todas las demás funciones son de primer orden (first order functions). [1]</p>
<p>A diferencia de muchos otros lenguajes con características imperativas,
JavaScript nos permite usar higher-order functions ya que tiene funciones
\\"first-class\\". Lo que significa que las funciones pueden ser tratadas como
cualquier otro valor en JavaScript: igual que Strings o Numbers, valores de tipo
Function pueden ser almacenados en variables, propiedades de objetos o pasados
a otras funciones como argumentos. Los valores de tipo Function de hecho son
Objects (que heredan de <code>Function.prototype</code>), así que podemos incluso añadir
propiedades y asignar valores igual que en cualquir otro objeto.</p>
<p>La principal diferencia entre las funciones y el resto de valores en JavaScript
es la sintáxis de invocación. Si una referencia a una función está seguida de
paréntesis y opcionalmente una lista de argumentos separados por comas:
<code>someFunctionValue(arg1, arg2, etc)</code>, entonces el cuerpo de la función será
ejecutada con los argumentos pasados (si hubiere).</p>
<p>En este ejercicio vamos a demostrar que las funciones pueden ser pasadas como
valores. Te vamos a pasar una función como argumento.</p>
<h2 id=\\"tarea\\">Tarea</h2>
<p>Implementa una función que reciba una función como primer argumento, y un número
<code>num</code> como segundo argumento. La función debe ejecutar la función <code>num</code> veces.</p>
<p>Usa el boilerplate provisto para empezar. Todos (o casi todos) los ejercicios
incluirán un boilerplate.</p>
<h2 id=\\"argumentos\\">Argumentos</h2>
<ul>
<li><code>operation</code>: Una función, no recibe argumentos, no retorna ningún valor útil.</li>
<li><code>num</code>: el número de veces que queremos invocar <code>operation</code></li>
</ul>
<h2 id=\\"pistas\\">Pistas</h2>
<ul>
<li>No lo des demasiadas vueltas, el código debe ser muy simple.</li>
<li>No pasa nada si usas un loop. Bonus para quien implemente usando recursión.</li>
<li>No te despistes si ves output. Esto viene de la función que te estamos pasando.</li>
<li>No tienes que usar console.log para nada.</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions_and_function_scope\\" target=\\"_blank\\">Funciones y alcance de la función - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype\\" target=\\"_blank\\">Function.prototype - MDN</a></li>
</ul>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "aG9mLmpz": "//
// TAREA
//
// Implementa una función que reciba una función como primer argumento
// \`operation\`, y un número \`num\` como segundo argumento. La función debe
// ejecutar la función \`num\` veces.
//

module.exports = function repeat(operation, num) {
  //Escribe aquí tu código.

};
",
            },
            "c29sdXRpb24=": Object {
              "aG9mLmpz": "module.exports = function repeat(operation, num) {
  if (num <= 0) {
    return;
  }
  operation();
  return repeat(operation, num - 1);
};
",
            },
            "dGVzdA==": Object {
              "aG9mLnNwZWMuanM=": "'use strict';


const Assert =  require('chai').assert;
const Submission = require('../solution/hof');


describe('repeat', () => {

  it('debería exportar una función', () => {
    Assert.equal(typeof Submission, 'function');
  });

  it('debería invocar la operación num veces', () => {
    let count = 0;
    Submission(_ => count++, 3);
    Assert.equal(count, 3);
  });

});
",
            },
          },
          "title": "Higher Order Functions",
        },
        "02-map": Object {
          "body": "<h2 id=\\"tarea\\">Tarea</h2>
<p>Refactorizar el siguiente código reemplazando el bucle <code>for</code> con <code>Array#map</code>:</p>
<pre><code class=\\"language-js\\">function doubleAll(numbers) {
  var result = [];
  for (var i = 0; i &lt; numbers.length; i++) {
    result.push(numbers[i] * 2);
  }
  return result;
}
</code></pre>
<h2 id=\\"argumentos\\">Argumentos</h2>
<ul>
<li>numbers: Un Array de 0 a 20 números enteros entre 0 y 9</li>
</ul>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li>Tu solución debe usar <code>Array.prototype.map()</code>.</li>
<li>No uses ningún bucle <code>for/while</code> o <code>Array.prototype.forEach</code>.</li>
<li>No crees ninguna función extra (helpers, ...).</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\\" target=\\"_blank\\">Array.map - MDN</a></li>
</ul>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "bWFwLmpz": "//
// TAREA
//
// Refactorizar la siguiente función reemplazando el bucle \`for\` con
// \`Array#map\`.
//

module.exports = function doubleAll(numbers) {
  var result = [];
  for (var i = 0; i < numbers.length; i++) {
    result.push(numbers[i] * 2);
  }
  return result;
};
",
            },
            "c29sdXRpb24=": Object {
              "bWFwLmpz": "module.exports = numbers => numbers.map(num => num * 2);
",
            },
            "dGVzdA==": Object {
              "bWFwLnNwZWMuanM=": "'use strict';


const Assert = require('chai').assert;
const Submission = require('../solution/map');


describe('doubleAll()', () => {

  it('debería retornar array con números multiplicados por 2', () => {
    Assert.deepEqual(Submission([1, 2, 3]), [2, 4, 6]);
  });

  it('NO debería modificar array de entrada', () => {
    const input = [1, 2, 3];
    Assert.deepEqual(Submission(input), [2, 4, 6]);
    Assert.deepEqual(input, [1, 2, 3]);
  });

  it('NO debería usar for o while', () => {
    Assert.equal(/(for|while)\\\\s+\\\\(/g.test(Submission.toString()), false);
  });

  it('debería invocar Array.prototype.map', () => {
    const map = Array.prototype.map;
    let mapCount = 0;
    let operationCount = 0;

    Array.prototype.map = function (fn) {
      mapCount++;
      return map.call(this, function () {
        operationCount++;
        return fn.apply(null, Array.prototype.slice.call(arguments));
      });
    };

    Assert.deepEqual(Submission([1, 2, 3]), [2, 4, 6]);
    Assert.equal(mapCount, 1);
    Assert.equal(operationCount, 3);

    Array.prototype.map = map;
  });

});
",
            },
          },
          "title": "Map",
        },
        "03-filter": Object {
          "body": "<h2 id=\\"tarea\\">Tarea</h2>
<p>Usa <code>Array#filter</code> para implementar una función llamada <code>getShortMessages</code>.</p>
<p>La función <code>getShortMessages</code> recibe un array de objetos con una propiedad
<code>message</code> y retorna un array con los mensajes que tengan <em>menos de &lt; 50
caracteres</em>.</p>
<p>La función debe retornar un array con los mensajes (strings), <em>no objetos</em>.</p>
<h2 id=\\"argumentos\\">Argumentos</h2>
<ul>
<li><code>messages</code>: un <code>Array</code> de 10 a 100 objetos con este formato:</li>
</ul>
<pre><code class=\\"language-js\\">{
  message: 'Esse id amet quis eu esse aute officia ipsum.' // random
}
</code></pre>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li>No uses ningún bucle <code>for/while</code> o <code>Array.prototype.forEach</code>.</li>
<li>No crees ninguna función extra (helpers, ...).</li>
</ul>
<h2 id=\\"pistas\\">Pistas</h2>
<ul>
<li>Prueba a \\"encadenar\\" métodos de <code>Array</code>!</li>
</ul>
<h2 id=\\"ejemplo\\">Ejemplo</h2>
<p>La función debe retornar algo parecido a:</p>
<pre><code class=\\"language-js\\">[ 'Tempor quis esse consequat sunt ea eiusmod.',
  'Id culpa ad proident ad nulla laborum incididunt.',
  'Ullamco in ea et ad anim anim ullamco est.',
  'Est ut irure irure nisi.' ]
</code></pre>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\\" target=\\"_blank\\">Array.filter - MDN</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\\" target=\\"_blank\\">Array.map - MDN</a></li>
</ul>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "ZmlsdGVyLmpz": "//
// TAREA
//
// La función \`getShortMessages\` recibe un array de objetos con una propiedad
// \`message\` y retorna un array con los mensajes que tengan menos de < 50
// caracteres.
//

module.exports = function getShortMessages(messages) {
  // Escribe aquí tu código.

};
",
            },
            "c29sdXRpb24=": Object {
              "ZmlsdGVyLmpz": "module.exports = messages =>
  messages
    .filter(item => item.message.length < 50)
    .map(item => item.message);
",
            },
            "dGVzdA==": Object {
              "ZmlsdGVyLnNwZWMuanM=": "'use strict';


const Assert = require('chai').assert;
const Submission = require('../solution/filter');


const message = () => {
  return Assert.deepEqual(Submission([{
      message: 'Tempor quis esse consequat sunt ea eiusmod.'
    }, {
      message: 'Id culpgetShortMessages.speca ad proident ad nulla laborum incididunt. Blah blah'
    }, {
      message: 'Ullamco in ea et ad anim anim ullamco est.'
    }, {
      message: 'Est ut irure irure nisi.'
    }]), [
      'Tempor quis esse consequat sunt ea eiusmod.',
      'Ullamco in ea et ad anim anim ullamco est.',
      'Est ut irure irure nisi.'
    ]);
};


describe('getShortMessages()', () => {

  it('debería retornar [ ] cuando input array es [ ]', ( )  => {
    Assert.deepEqual(Submission([]), []);
  });

  it('debería retornar arreglo de strings con mensajes de menos de 50 chars', () => {
    message();
  });

  it('NO debería usar for o while', () => {
    Assert.equal(/(for|while)\\\\s+\\\\(/g.test(Submission.toString()), false);
  });

  it('debería invocar Array.prototype.filter' , () => {
    const filter = Array.prototype.filter;
    let filterCount = 0;

    Array.prototype.filter = function (fn) {
      filterCount++;
      return filter.call(this, function () {
        return fn.apply(null, Array.prototype.slice.call(arguments));
      });
    };

    message();
    Assert.equal(filterCount, 1);

    Array.prototype.filter = filter;
  });

  it('debería invocar Array.prototype.map', () => {
    const map = Array.prototype.map;
    let mapCount = 0;

    Array.prototype.map = function (fn) {
      mapCount++;
      return map.call(this, function () {
        return fn.apply(null, Array.prototype.slice.call(arguments));
      });
    };
    message();
    Assert.equal(mapCount, 1);
    Array.prototype.map = map;
  });

});
",
            },
          },
          "title": "Filter",
        },
        "04-reduce": Object {
          "body": "<h2 id=\\"tarea\\">Tarea</h2>
<p>Dado un <code>Array</code> de strings, usa <code>Array#reduce</code> para crear un objeto que contenga
el número de veces que aparece cada string en el array. Retorna el object
directamente (no hay necesidad de hacer <code>console.log</code>).</p>
<h2 id=\\"ejemplo\\">Ejemplo</h2>
<pre><code class=\\"language-js\\">var inputWords = ['Apple', 'Banana', 'Apple', 'Durian', 'Durian', 'Durian']

console.log(countWords(inputWords))

// =&gt; { Apple: 2, Banana: 1, Durian: 3 }
</code></pre>
<h2 id=\\"argumentos\\">Argumentos</h2>
<ul>
<li><code>inputWords</code>: Un array de Strings.</li>
</ul>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li>No uses ningún bucle <code>for/while</code> o <code>Array.prototype.forEach</code>.</li>
<li>No crees ninguna función extra (helpers, ...).</li>
</ul>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://en.wikipedia.org/wiki/Reduce_(higher-order_function)\\" target=\\"_blank\\">Reduce - Wikipedia</a></li>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\\" target=\\"_blank\\">Array.reduce - MDN</a></li>
</ul>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "cmVkdWNlLmpz": "//
// TAREA
//
// Dado un \`Array\` de strings, usa \`Array#reduce\` para crear un objeto
// que contenga el número de veces que aparece cada string en el array.
// Retorna el object directamente (no hay necesidad de hacer \`console.log\`).
//

module.exports = (arr) => {
  // ...
};
",
            },
            "c29sdXRpb24=": Object {
              "cmVkdWNlLmpz": "module.exports = (arr) => arr.reduce((countMap, word) => {
  countMap[word] = ++countMap[word] || 1;
  return countMap;
}, {});
",
            },
            "dGVzdA==": Object {
              "cmVkdWNlLnNwZWMuanM=": "'use strict';


const Assert = require('chai').assert;
const Submission = require('../solution/reduce');


describe('countWords()', () => {

  it('debería retornar un objeto que contenga el número de veces que aparece cada string en el array', () => {
    const input = ['Apple', 'Banana', 'Apple', 'Durian', 'Durian', 'Durian'];
    Assert.deepEqual(Submission(input), { Apple: 2, Banana: 1, Durian: 3 });
  });

  it('NO debería usar for o while', () => {
    Assert.equal(/(for|while)\\\\s+\\\\(/g.test(Submission.toString()), false);
  });

  it('debería invocar Array.prototype.reduce', () => {
    const reduce = Array.prototype.reduce;
    let reduceCount = 0;

    Array.prototype.reduce = function (fn, initial) {
      reduceCount++;
      return reduce.call(this, function () {
        return fn.apply(null, Array.prototype.slice.call(arguments));
      }, initial);
    };

    Assert.deepEqual(Submission(['foo', 'foo']), { foo: 2 });
    Assert.equal(reduceCount, 1);

    Array.prototype.reduce = reduce;
  });

});
",
            },
          },
          "title": "Reduce",
        },
        "05-arrow-functions": Object {
          "body": "<p>Una <em>función flecha</em> (arrow function) es una expresión con una sintáxis más
corta comparada con la expresión de función convencional (<code>function</code>) y se
diferencia de ésta en los siguiente:</p>
<ul>
<li>no vincula su propio <code>this</code>, <code>arguments</code>, <code>super</code>, o <code>new.target</code></li>
<li>siempre son anónimas</li>
<li>no pueden ser usadas como constructores</li>
</ul>
<p>Por todo esto, las funciones flecha se prestan para funciones que no sean
<em>métodos</em> (miembros de un objeto).</p>
<h2 id=\\"tarea\\">Tarea</h2>
<p>Implementa las funciones implementadas en los ejercicios anteriores (<code>repeat</code>,
<code>doubleAll</code>, <code>getShortMessages</code> y <code>countWords</code>), pero esta vez usando funciones
flecha, y haciendo uso de retorno implícito cuando sea posible.</p>
<h2 id=\\"requisitos\\">Requisitos</h2>
<p>Los mismos que en los ejercicios anteriores, pero esta vez debes usar funciones
flecha.</p>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\\" target=\\"_blank\\">Arrow_functions - MDN</a></li>
</ul>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "YXJyb3dGdW5jdGlvbnMuanM=": "exports.repeat = (operation, num) => {
  // Escribe tu código aquí.

};

exports.doubleAll = (numbers) => {
  // Escribe tu código aquí.

};

exports.getShortMessages = (messages) => {
  //Escribe tu código aquí.

};

exports.countWords = (arr) => {
  //Escribe tu código aquí.

};

//
// TAREA
//
// Implementa las funciones implementadas en los ejercicios anteriores
// (\`repeat\`,\`doubleAll\`, \`getShortMessages\` y \`countWords\`), pero esta vez
// usando funciones flecha, y haciendo uso de retorno implícito cuando sea
// posible.
",
            },
            "c29sdXRpb24=": Object {
              "YXJyb3dGdW5jdGlvbnMuanM=": "exports.repeat = (operation, num) => {
  if (num <= 0) {
    return;
  }
  operation();
  return exports.repeat(operation, --num);
};

exports.doubleAll = numbers => numbers.map(num => num * 2);

exports.getShortMessages = messages => messages
  .filter(item => item.message.length < 50)
  .map(item => item.message);

exports.countWords = arr => arr.reduce((countMap, word) => {
  countMap[word] = ++countMap[word] || 1;
  return countMap;
}, {});
",
            },
            "dGVzdA==": Object {
              "YXJyb3dGdW5jdGlvbnMuc3BlYy5qcw==": "'use strict';

const Assert = require('chai').assert;
const { getShortMessages, repeat, doubleAll, countWords } = require('../solution/arrowFunctions');

const message = (_ => {
  return Assert.deepEqual(getShortMessages([{
      message: 'Tempor quis esse consequat sunt ea eiusmod.'
    }, {
      message: 'Id culpgetShortMessages.speca ad proident ad nulla laborum incididunt. Blah blah'
    }, {
      message: 'Ullamco in ea et ad anim anim ullamco est.'
    }, {
      message: 'Est ut irure irure nisi.'
    }]), [
      'Tempor quis esse consequat sunt ea eiusmod.',
      'Ullamco in ea et ad anim anim ullamco est.',
      'Est ut irure irure nisi.'
    ]);
});

describe('Arrow functions', () => {

  describe('getShortMessages()', () => {

    it('debería retornar [] cuando input array es []', () => {
      Assert.deepEqual(getShortMessages([]), []);
    });

    it('debería retornar arreglo de strings con mensajes de menos de 50 chars', () => {
      message();
    });

    it('NO debería usar for o while', () => {
      Assert.equal(/(for|while)\\\\s+\\\\(/g.test(getShortMessages.toString()), false);
    });

    it('debería invocar Array.prototype.filter', () => {
      const filter = Array.prototype.filter;
      let filterCount = 0;

      Array.prototype.filter = function (fn) {
        filterCount++;
        return filter.call(this, function () {
          return fn.apply(null, Array.prototype.slice.call(arguments));
        });
      };

      message();
      Assert.equal(filterCount, 1);

      Array.prototype.filter = filter;
    });

    it('debería invocar Array.prototype.map', () => {
      const map = Array.prototype.map;
      let mapCount = 0;

      Array.prototype.map = function (fn) {
        mapCount++;
        return map.call(this, function () {
          return fn.apply(null, Array.prototype.slice.call(arguments));
        });
      };

      message();

      Assert.equal(mapCount, 1);

      Array.prototype.map = map;
    });

  });

  describe('repeat', () => {

    it('debería exportar una función', () => {
      Assert.equal(typeof repeat, 'function');
    });

    it('debería invocar la operación num veces', () => {
      let count = 0;
      repeat( _ => count++, 3);
      Assert.equal(count, 3);
    });

  });

  describe('doubleAll()', () => {

    it('debería retornar array con números multiplicados por 2', () => {
      Assert.deepEqual(doubleAll([1, 2, 3]), [2, 4, 6]);
    });

    it('NO debería modificar array de entrada', () => {
      const input = [1, 2, 3];
      Assert.deepEqual(doubleAll(input), [2, 4, 6]);
      Assert.deepEqual(input, [1, 2, 3]);
    });

    it('NO debería usar for o while', () => {
      Assert.equal(/(for|while)\\\\s+\\\\(/g.test(doubleAll.toString()), false);
    });

    it('debería invocar Array.prototype.map', () => {
      const map = Array.prototype.map;
      let mapCount = 0;
      let operationCount = 0;

      Array.prototype.map = function (fn) {
        mapCount++;
        return map.call(this, function () {
          operationCount++;
          return fn.apply(null, Array.prototype.slice.call(arguments));
        });
      };

      Assert.deepEqual(doubleAll([1, 2, 3]), [2, 4, 6]);
      Assert.equal(mapCount, 1);
      Assert.equal(operationCount, 3);

      Array.prototype.map = map;
    });

  });

  describe('countWords()', () => {

    it('debería retornar un objeto que contenga el número de veces que aparece cada string en el array', () => {
      const input = ['Apple', 'Banana', 'Apple', 'Durian', 'Durian', 'Durian'];
      Assert.deepEqual(countWords(input), { Apple: 2, Banana: 1, Durian: 3 });
    });

    it('NO debería usar for o while', () => {
      Assert.equal(/(for|while)\\\\s+\\\\(/g.test(countWords.toString()), false);
    });

    it('debería invocar Array.prototype.reduce', () => {
      const reduce = Array.prototype.reduce;
      let reduceCount = 0;

      Array.prototype.reduce = function (fn, initial) {
        reduceCount++;
        return reduce.call(this, function () {
          return fn.apply(null, Array.prototype.slice.call(arguments));
        }, initial);
      };

      Assert.deepEqual(countWords(['foo', 'foo']), { foo: 2 });
      Assert.equal(reduceCount, 1);

      Array.prototype.reduce = reduce;
    });

  });

});
",
            },
          },
          "title": "Arrow Functions",
        },
        "06-closures": Object {
          "body": "<h2 id=\\"tarea\\">Tarea</h2>
<p>Implementa una función llamada <code>createLogger</code>. Esta función debe recibir un
argumento (<code>namespace</code>) de tipo string, y debe retornar una función anónima que
a su vez reciba un string (<code>str</code>) e imprima a la consola el string recibido,
precedido de <code>[namespace]:</code>.</p>
<p>Por ejemplo:</p>
<pre><code class=\\"language-js\\">const warn = createLogger('warning');
warn('houston, we have a problem');
</code></pre>
<p>Debe producir el siguiente output en la consola:</p>
<pre><code class=\\"language-text\\">[warning]: houston, we have a problem
</code></pre>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\\" target=\\"_blank\\">Closures - MDN</a></li>
</ul>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "Y2xvc3VyZXMuanM=": "const createLogger = function (namespace) {
  //Escribe aquí tu código

};

module.exports = createLogger;
",
            },
            "c29sdXRpb24=": Object {
              "Y2xvc3VyZXMuanM=": "const createLogger = namespace => str => console.log(\`[\${namespace}]: \${str}\`);

module.exports = createLogger;
",
            },
            "dGVzdA==": Object {
              "Y2xvc3VyZXMuc3BlYy5qcw==": "'use strict';


const Assert =  require('chai').assert;
const Sinon = require('sinon');
const Submission = require('../solution/closures');


describe('createLogger()', () => {

  it('debería de ser una función', () => {
    Assert.equal(typeof Submission, 'function');
  });

  it('debería de retornar una función', () => {
    Assert.equal(typeof Submission(), 'function');
  });

  it('debería de retornar una función que imprime a la consola con el namespace', () => {
    const stub = Sinon.stub(console, 'log');
    const warn = Submission('warning');
    warn('houston, we have a problem');

    Assert.equal(stub.callCount, 1);
    Assert.equal(stub.getCall(0).args[0], '[warning]: houston, we have a problem');

    stub.restore();
  });

});
",
            },
          },
          "title": "Closures",
        },
        "07-factories": Object {
          "body": "<p>Las factories o factory functions son simplemente functiones que crean objetos.
Podemos usar factories como alternativa a los constructores, siendo más simples
y por la tanto más fácil visualizar lo que hacen.</p>
<h2 id=\\"tarea\\">Tarea</h2>
<p>Implementa una función que se llame <code>createStore</code>. Esta función no recibe ningún
argumento y retorna un objeto con los siguientes métodos:</p>
<ul>
<li><code>get(key)</code>: retorna el valor guardado en la \\"llave\\" (<code>key</code>).</li>
<li><code>set(key, value)</code>: guarda el valor (<code>value</code>) en la \\"llave\\" (<code>key</code>) del store y
  retorna el valor guardado.</li>
<li><code>keys()</code>: retorna un array con las llaves que tiene el store.</li>
<li><code>clear()</code>: borra todas las llaves/valores del store.</li>
</ul>
<p>Ejemplo:</p>
<pre><code class=\\"language-js\\">const store = createStore();
console.log(store.keys()); // =&gt; []
console.log(store.get('foo')); // =&gt; undefined
console.log(store.set('foo', 'lalala')); // =&gt; lalala
console.log(store.get('foo')); // =&gt; lalala
console.log(store.keys()); // =&gt; ['foo']
console.log(store.clear()); // =&gt; {}
console.log(store.keys()); // =&gt; []
console.log(store.get('foo')); // =&gt; undefined
</code></pre>
<h2 id=\\"pistas\\">Pistas</h2>
<p>Puedes usar <code>Object.keys()</code> para obtener un arreglo con las propiedades de un
objeto.</p>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "ZmFjdG9yaWVzLmpz": "module.exports = function createStore() {
  // TAREA
  // Implementa una función que se llame \`createStore\`. Esta función no recibe
  // ningún argumento y retorna un objeto con los siguientes métodos:
  // \`get(key)\`, \`set(key, value)\` ,\`keys()\` y \`clear()\`.
  let data = {};
  return {
    // Escribe aquí  tu código.
  };
};
",
            },
            "c29sdXRpb24=": Object {
              "ZmFjdG9yaWVzLmpz": "module.exports = function createStore() {

  let data = {};

  return {
    get  : (key) => data[key],
    set  : (key, value) => data[key] = value,
    keys : () => Object.keys(data),
    clear: () => data = {}
  };
};
",
            },
            "dGVzdA==": Object {
              "ZmFjdG9yaWVzLnNwZWMuanM=": "'use strict';


const Assert = require('chai').assert;
const Submission = require('../solution/factories');
const store = Submission();


describe('Factories', () => {

  describe('createStore()', () => {

    it('debería exportar una función', () => {
      Assert.equal(typeof Submission, 'function');
    });

    it('debería retornar un objeto con método get', () => {
      Assert.equal(typeof store.get, 'function');
    });

    it('debería retornar un objeto con método set', () => {
      Assert.equal(typeof store.set, 'function');
    });

    it('debería retornar un objeto con método keys', () => {
      Assert.equal(typeof store.keys, 'function');
    });

    it('debería retornar un objeto con método clear', () => {
      Assert.equal(typeof store.clear, 'function');
    });

  });

  describe('store.get() / store.set()', () => {

    it('deberían retornar el valor guardado en la llave específicada', () => {
      const store = Submission();
      Assert.equal(store.get('foo'), undefined);
      Assert.equal(store.set('foo', true), true);
      Assert.equal(store.get('foo'), true);
      Assert.equal(store.set('foo', 'lalala'), 'lalala');
      Assert.equal(store.get('foo'), 'lalala');
    });

  });

  describe('store.keys()', () => {

    it('debería retornar un arreglo con las llaves del store', () => {
      const store = Submission();
      Assert.deepEqual(store.keys(), []);
      Assert.equal(store.set('foo', true), true);
      Assert.deepEqual(store.keys(), ['foo']);
      Assert.equal(store.set('bar', 'lalala'), 'lalala');
      Assert.deepEqual(store.keys(), ['foo', 'bar']);
    });

  });

  describe('store.clear()', () => {

    it('debería vaciar el store', () => {
      Assert.deepEqual(store.keys(), []);
      Assert.equal(store.set('foo', true), true);
      Assert.deepEqual(store.keys(), ['foo']);
      Assert.equal(store.set('bar', 'lalala'), 'lalala');
      Assert.deepEqual(store.keys(), ['foo', 'bar']);
      Assert.deepEqual(store.clear(), {});
      Assert.deepEqual(store.keys(), []);
    });

  });
});
",
            },
          },
          "title": "Object factories",
        },
        "08-object-assign": Object {
          "body": "<h2 id=\\"tarea\\">Tarea</h2>
<p>Implementa una función llamada <code>extend</code>. Esta función debe comportarse muy
parecido a <code>Object.assign()</code>, pero siempre retorna un objeto nuevo, con las
propiedades de todas los objetos que reciba como argumentos.</p>
<pre><code class=\\"language-js\\">const obj1 = { foo: true, bar: false };
const obj2 = { baz: 1, bar: true };
console.log(extend(obj1, obj2));
// { foo: true, bar: true, baz: 1 }
</code></pre>
<h2 id=\\"requisitos\\">Requisitos</h2>
<ul>
<li>Tu implementación debe hacer uso de <code>Object.assign</code>.</li>
</ul>
<h2 id=\\"pistas\\">Pistas</h2>
<p>En las funciones flecha no tenemos <code>arguments</code>, pero podemos usar <code>...args</code>. Más
info sobre esto en la página de MDN (ver link más abajo).</p>
<h2 id=\\"recursos\\">Recursos</h2>
<ul>
<li><a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\\" target=\\"_blank\\">Arrow.function - MDN</a></li>
</ul>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "b2JqZWN0QXNzaWduLmpz": "exports.extend = function () {
  // Escribe aquí tu código.
};
",
            },
            "c29sdXRpb24=": Object {
              "b2JqZWN0QXNzaWduLmpz": "exports.extend = (...sources) => Object.assign({}, ...sources);

// Implementación usando \`bind\` (aplicación parcial)
// exports.extend = Object.assign.bind(Object, {});
",
            },
            "dGVzdA==": Object {
              "b2JqZWN0QXNzaWduLnNwZWMuanM=": "'use strict';


const Assert =  require('chai').assert;
const Submission = require('../solution/objectAssign');


describe('extend', () => {

  it('debería exportar un objeto', () => {
    Assert.equal(typeof Submission, 'object');
  });

  it('debería exportar el objeto con un método \\"extend\\"', () => {
    Assert.equal(typeof Submission.extend, 'function');
  });

  it('debería crear un objeto nuevo con todas las propiedades de las fuentes', () => {
    const obj1 = { foo: true, bar: false };
    const obj2 = { baz: 1, bar: true };
    const obj3 = { baz: 2, bar: false };

    const obj4 = Submission.extend(obj1);
    Assert.deepEqual(obj4, { foo: true, bar: false });
    obj4.foo = 'hola';
    Assert.deepEqual(obj4, { foo: 'hola', bar: false });
    Assert.deepEqual(obj1, { foo: true, bar: false });

    Assert.deepEqual(Submission.extend(obj1, obj2), { foo: true, bar: true, baz: 1 });
    Assert.deepEqual(Submission.extend(obj1, obj2, obj3), { foo: true, bar: false, baz: 2 });
  });

});
",
            },
          },
          "title": "Object.assign()",
        },
        "09-composition": Object {
          "body": "<h2 id=\\"tarea\\">Tarea</h2>
<p>Tómate el tiempo para considerar este snippet. Las funciones <code>pooper</code>, <code>barker</code>,
<code>driver</code> y <code>killer</code> crean un objeto cada una. Después, creamos <code>dog</code>, <code>robot</code> y
<code>murderRobot</code>, que simplemente \\"componen\\" los objetos creados por las funciones
anteriores.</p>
<pre><code class=\\"language-js\\">const pooper = state =&gt; ({
  poop: () =&gt; console.log('💩')
});

const barker = state =&gt; ({
  bark: () =&gt; console.log('woof! my name is ' + state.name)
});

const driver = state =&gt; ({
  drive: () =&gt; state.position = state.position + state.speed
});

const killer = state =&gt; ({
  kill: () =&gt; console.log('time to kill!')
});

const dog = name =&gt; {
  const state = {
    name: name,
    speed: 100,
    position: 0
  };

  return Object.assign({}, pooper(state), barker(state));
};

const robot = name =&gt; {
  const state = {
    name: name,
    speed: 100,
    position: 0
  };

  return Object.assign({}, driver(state));
};
</code></pre>
<p>Siguiendo este patrón, implementa:</p>
<ul>
<li><code>murderRobot</code> (con lo mismo que <code>robot</code> pero además de <code>killer</code>)</li>
<li><code>murderDog</code> (con todo lo que tiene <code>dog</code> además de <code>killer</code>)</li>
<li><code>murderRobotDog</code>, que debe combinar la capacidad de ladrar (bark) con la
funcionalidad de <code>driver</code> y <code>killer</code>.</li>
</ul>
",
          "env": "js",
          "files": Object {
            "Ym9pbGVycGxhdGU=": Object {
              "Y29tcG9zaXRpb24uanM=": "const pooper = state => ({
  poop: () => console.log('💩')
});

const barker = state => ({
  bark: () => console.log('woof! my name is ' + state.name)
});

const driver = state => ({
  drive: () => state.position = state.position + state.speed
});

const killer = state => ({
  kill: () => console.log('time to kill!')
});

const dog = name => {
  const state = {
    name: name,
    speed: 20,
    position: 0
  };
  return Object.assign({}, pooper(state), barker(state));
};

const robot = name => {
  const state = {
    name: name,
    speed: 100,
    position: 0
  };
  return Object.assign({}, driver(state));
};

exports.murderRobot = name => {
  //Escribe aquí tu código

};

exports.murderDog = name => {
  //Escribe aquí tu código

};

exports.murderRobotDog = name => {
  //Escribe aquí tu código

};
",
            },
            "c29sdXRpb24=": Object {
              "Y29tcG9zaXRpb24uanM=": "const pooper = state => ({
  poop: () => console.log('💩')
});

const barker = state => ({
  bark: () => console.log('woof! my name is ' + state.name)
});

const driver = state => ({
  drive: () => state.position = state.position + state.speed
});

const killer = state => ({
  kill: () => console.log('time to kill!')
});

const dog = name => {
  const state = {
    name: name,
    speed: 100,
    position: 0
  };
  return Object.assign({}, pooper(state), barker(state));
};

const robot = name => {
  const state = {
    name: name,
    speed: 100,
    position: 0
  };
  return Object.assign({}, driver(state));
};

exports.murderRobot = name => {
  const state = {
    name: name,
    speed: 100,
    position: 0
  };
  return Object.assign({}, driver(state), killer(state));
};

exports.murderDog = name => {
  const state = {
    name: name,
    speed: 100,
    position: 0
  };
  return Object.assign({}, barker(state), pooper(state), killer(state));
};

exports.murderRobotDog = name => {
  const state = {
    name: name,
    speed: 100,
    position: 0
  };
  return Object.assign({}, barker(state), driver(state), killer(state));
};
",
            },
            "dGVzdA==": Object {
              "Y29tcG9zaXRpb24uc3BlYy5qcw==": "'use strict';


const Assert = require('chai').assert;
const Submission = require('../solution/composition');


describe('Object composition', () => {

  describe('murderDog()', () => {

    it('debería ser una función', () => {
      Assert.equal(typeof Submission.murderDog, 'function');
    });

    it('debería retornar un objeto con bark, poop y kill', () => {
      const obj = Submission.murderDog();
      Assert.deepEqual(Object.keys(obj), ['bark', 'poop', 'kill']);
      Assert.equal(typeof obj.bark, 'function');
      Assert.equal(typeof obj.poop, 'function');
      Assert.equal(typeof obj.kill, 'function');
    });

  });

  describe('murderRobot()', () => {

    it('debería ser una función', () => {
      Assert.equal(typeof Submission.murderRobot, 'function');
    });

    it('debería retornar un objeto con drive y kill', () => {
      const obj = Submission.murderRobot();
      Assert.deepEqual(Object.keys(obj), ['drive', 'kill']);
      Assert.equal(typeof obj.drive, 'function');
      Assert.equal(typeof obj.kill, 'function');
    });

  });

  describe('murderRobotDog()', () => {

    it('debería ser una función', () => {
      Assert.equal(typeof Submission.murderRobotDog, 'function');
    });

    it('debería retornar un objeto con bark, drive y kill', () => {
      const obj = Submission.murderRobotDog();
      Assert.deepEqual(Object.keys(obj), ['bark', 'drive', 'kill']);
      Assert.equal(typeof obj.bark, 'function');
      Assert.equal(typeof obj.drive, 'function');
      Assert.equal(typeof obj.kill, 'function');
    });

  });
});
",
            },
          },
          "title": "Object composition",
        },
      },
      "format": "self-paced",
      "title": "Ejercicios",
      "type": "practice",
    },
    "07-closing": Object {
      "body": "<h2 id=\\"resumen\\">Resumen</h2>
<p><code>Clousure</code> es el cuerpo de la función, dónde ésta tiene acceso al <em>scope</em> donde
se declaró, además de su scope local. Closure significa que las funciones se
\\"cierran\\" alrededor de las variables a las que tiene acceso.</p>
<p>Las <code>factories</code> o <code>factory functions</code> son simplemente funciones que crean
objetos. Podemos usar factories como alternativa a los constructores, siendo más
simples y por la tanto, más fácil de visualizar qué hacen.</p>
<p><code>Object.assign()</code> recibe un objeto como primer argumento, al cual se le copian
todas las propiedades de los objetos \\"fuente\\" que se le pasan al objeto destino.
Esto nos permite fácilmente \\"mezclar\\" objetos o simplemente copiar un objeto.</p>
<ul>
<li><code>Object.assign(destino, fuente1, fuente2, ... fuenteN)</code></li>
</ul>
<p><code>Composition over inheritance</code>, la composición se concentra en la
\\"funcionalidad\\", los métodos que implementa un objeto, y para ello en vez de
heredar, simplemente \\"tenemos\\" otros objetos a partir de los cuales vamos a
componer una nueva interfaz. La composición no nos ata a la jerarquia que impone
la herecia, haciendo que ésta sea muchisimo más flexible a la hora de
desarrollar.</p>
<h2 id=\\"respondamos-juntxs-las-preguntas-de-la-apertura\\">Respondamos juntxs las preguntas de la apertura</h2>
<ul>
<li>Cómo usar <strong>composición</strong> como alternativa a la <em>herencia</em>?</li>
<li>Qué beneficios tienen las <strong>Factories</strong>?</li>
<li>Cómo beneficiarse del <strong>Clousure</strong>?</li>
</ul>
",
      "duration": 5,
      "format": "self-paced",
      "title": "Cierre",
      "type": "read",
    },
  },
}
`;
